<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"archive.next.arttnba3.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0x00.绪论本来不想这么快又开一篇新的blog的（毕竟一篇OJ就是一个坑，前面的好多坑才刚刚开挖），不过因为刚好做了每日一题的前置题目而刚好这道题又是树&#x2F;图题所以想找个地方记录下来因此就开了一篇新博客 题好难做啊.jpg">
<meta property="og:type" content="article">
<meta property="og:title" content="【OJ-0x0005-Leetcode】树部分write up by arttnba3">
<meta property="og:url" content="http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="0x00.绪论本来不想这么快又开一篇新的blog的（毕竟一篇OJ就是一个坑，前面的好多坑才刚刚开挖），不过因为刚好做了每日一题的前置题目而刚好这道题又是树&#x2F;图题所以想找个地方记录下来因此就开了一篇新博客 题好难做啊.jpg">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/09/18/X7l15qIoGtLN9hJ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/17/cuRZvFXGaizQsom.png">
<meta property="og:image" content="https://i.loli.net/2020/09/17/O1CDTlZgMUpXzVw.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/23/wXgivj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/23/wXgJVx.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/24/wxTxSA.png">
<meta property="og:image" content="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png">
<meta property="og:image" content="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png">
<meta property="og:image" content="https://i.loli.net/2020/10/12/ZO73tM64GYXsf1c.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png">
<meta property="og:image" content="https://i.loli.net/2020/04/23/xOrMznpe3V6hmJ5.png">
<meta property="og:image" content="https://i.loli.net/2020/09/17/3VoQgCI1NvSJ7wt.png">
<meta property="og:image" content="https://i.loli.net/2020/09/17/Hsxip4fmnoXAyvC.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/RaA7r8BHmc9K2yX.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/hx5F6qdKp2tzr7D.png">
<meta property="og:image" content="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/485DnfumcRterSM.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png">
<meta property="og:image" content="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/485DnfumcRterSM.png">
<meta property="og:image" content="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png">
<meta property="og:image" content="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png">
<meta property="og:image" content="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png">
<meta property="og:image" content="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png">
<meta property="og:image" content="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png">
<meta property="article:published_time" content="2020-09-16T19:22:48.000Z">
<meta property="article:modified_time" content="2020-10-14T16:35:16.276Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="题解">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="链表">
<meta property="article:tag" content="树">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="图论">
<meta property="article:tag" content="无向图">
<meta property="article:tag" content="并查集">
<meta property="article:tag" content="深度优先搜索（DFS）">
<meta property="article:tag" content="广度优先搜索（BFS）">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/09/18/X7l15qIoGtLN9hJ.png">

<link rel="canonical" href="http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>【OJ-0x0005-Leetcode】树部分write up by arttnba3 | arttnba3's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">arttnba3's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">- arttnba3的隐秘小窝 -</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/arttnba3" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://archive.next.arttnba3.cn/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="arttnba3">
      <meta itemprop="description" content="- 做了关于你的梦，所以不愿醒来呢 -">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="arttnba3's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【OJ-0x0005-Leetcode】树部分write up by arttnba3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-17 03:22:48" itemprop="dateCreated datePublished" datetime="2020-09-17T03:22:48+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-15 00:35:16" itemprop="dateModified" datetime="2020-10-15T00:35:16+08:00">2020-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Online-Judge/" itemprop="url" rel="index"><span itemprop="name">Online Judge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>本来不想这么快又开一篇新的blog的（<del>毕竟一篇OJ就是一个坑，前面的好多坑才刚刚开挖</del>），不过因为刚好做了每日一题的前置题目而刚好这道题又是树/图题所以想找个地方记录下来因此就开了一篇新博客</p>
<p>题好难做啊.jpg</p>
<a id="more"></a>

<h2 id="pre-什么是树"><a href="#pre-什么是树" class="headerlink" title="pre.什么是树"></a>pre.什么是树</h2><blockquote>
<p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n(n&gt;0)n(n&gt;0) 个有限节点组成一个具有层次关系的集合。</p>
<p><img src="https://i.loli.net/2020/09/18/X7l15qIoGtLN9hJ.png" alt="image.png"></p>
<p>把它叫做「树」是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
<p>它具有以下的特点：</p>
<p>每个节点都只有有限个子节点或无子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>树里面没有环路。</p>
<p>链接：<a href="https://leetcode-cn.com/tag/tree/" target="_blank" rel="noopener">https://leetcode-cn.com/tag/tree/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>构造一棵<strong>树</strong>的最简单的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">child</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种结构是以下图的方式来保存一棵树的：</p>
<p><img src="https://i.loli.net/2020/09/17/cuRZvFXGaizQsom.png" alt="image.png"></p>
<p>构造一棵<strong>二叉树</strong>的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是不是很相似呢？其实可以把树的图歪过来康康…</p>
</blockquote>
<h1 id="0x01-难度：简单"><a href="#0x01-难度：简单" class="headerlink" title="0x01.难度：简单"></a>0x01.难度：简单</h1><h2 id="0x00-二叉树的最大深度"><a href="#0x00-二叉树的最大深度" class="headerlink" title="0x00.二叉树的最大深度"></a>0x00.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回它的最大深度 3 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>我们很容易想到使用<strong>递归</strong>的方式获取其最大深度，即深度优先搜索</p>
<p>故构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    i=maxDepth(root-&gt;left)+<span class="number">1</span>;</span><br><span class="line">    j=maxDepth(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i&gt;j?i:j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，递归会占用大量栈空间，因此内存消耗上并不是那么的理想（</p>
<p><img src="https://i.loli.net/2020/09/17/O1CDTlZgMUpXzVw.png" alt="image.png"></p>
<h2 id="0x01-翻转二叉树"><a href="#0x01-翻转二叉树" class="headerlink" title="0x01.翻转二叉树"></a>0x01.<a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h2><blockquote>
<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>4</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>备注:<br>这个问题是受到 Max Howell 的 原问题 启发的 ：</p>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：该题为2020.9.16的每日一题</p>
</blockquote>
<p>很常规的也很简单的一道题目，只需<strong>逐层交换左右节点</strong>即可（<del>homebrew的开发者居然写不出这个题么</del>（<del>估计是太紧张le</del>（<del>👈不要在意这家伙天天乱讲</del></p>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>一层一层交换结点的做法，我们很容易就想到递归，故构造代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">temp</span>;</span></span><br><span class="line">    temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，递归调用会占用大量的栈空间（每次进行函数调用都会生成一个新的栈帧），所以空间复杂度上不是很好看（</p>
<p><img src="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png" alt="image.png"></p>
<h3 id="解法二：广度优先搜索（队列）"><a href="#解法二：广度优先搜索（队列）" class="headerlink" title="解法二：广度优先搜索（队列）"></a>解法二：广度优先搜索（队列）</h3><p>大概过程如下：</p>
<ul>
<li>头结点入队</li>
<li>交换左右结点</li>
<li>左右结点入队</li>
<li>头结点出队</li>
</ul>
<p>队列为空时停止即可</p>
<p>因为数据范围不像OI那么变态（x），所以直接用一个很小的数组来储存即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * (<span class="title">queue</span>[1000]), *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">queue</span>[start] = root;</span><br><span class="line">    <span class="keyword">while</span>(start!=<span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>[start] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;left = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;right = temp;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>] = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>+<span class="number">1</span>] = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">end</span> += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png" alt="image.png"></p>
<blockquote>
<p>以及这个故事实在是太搞了</p>
<p><img src="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png" alt="image.png"></p>
</blockquote>
<h2 id="0x02-左叶子之和"><a href="#0x02-左叶子之和" class="headerlink" title="0x02. 左叶子之和"></a>0x02.<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener"> 左叶子之和</a></h2><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<p> 3<br>/ \<br>9  20<br>     / \<br>   15   7</p>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-left-leaves</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="解法一：深度优先搜索（DFS）"><a href="#解法一：深度优先搜索（DFS）" class="headerlink" title="解法一：深度优先搜索（DFS）"></a>解法一：深度优先搜索（DFS）</h3><p>一层一层地搜下去，若左结点为叶子结点（无子女）则加上左结点的值，否则搜索子结点，若右结点不为子结点则搜索右结点的子节点</p>
<p>得代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += root-&gt;left ? (isLeaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left)) : <span class="number">0</span>;</span><br><span class="line">    ans += (root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;!isLeaf(root-&gt;right)) ? dfs(root-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用三目运算符的一行流</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right ? root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right) : sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png" alt="image.png"></p>
<h3 id="解法二：广度优先搜索（BFS）-队列"><a href="#解法二：广度优先搜索（BFS）-队列" class="headerlink" title="解法二：广度优先搜索（BFS）+ 队列"></a>解法二：广度优先搜索（BFS）+ 队列</h3><p>这个解法是从官方的题解上看来的</p>
<p>使用队列数据结构来实现广度优先搜索</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeafNode</span><span class="params">(struct TreeNode *node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> **<span class="title">q</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span> *) * 1001);</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> = <span class="title">q</span>[<span class="title">left</span>++];</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeafNode(node-&gt;left)) </span><br><span class="line">            &#123;</span><br><span class="line">                ans += node-&gt;left-&gt;val;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isLeafNode(node-&gt;right)) </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这么做有一个缺点就是需要提前开辟较大的空间</p>
<p><img src="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png" alt="image.png"></p>
<h2 id="0x03-把二叉搜索树转换为累加树"><a href="#0x03-把二叉搜索树转换为累加树" class="headerlink" title="0x03.把二叉搜索树转换为累加树"></a>0x03.<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">把二叉搜索树转换为累加树</a></h2><blockquote>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p>
<p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p>
<p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：该题为2020.9.21的每日一题</p>
</blockquote>
<p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p>
<h3 id="解法：深度优先搜索-反序中序遍历"><a href="#解法：深度优先搜索-反序中序遍历" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h3><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p>
<ul>
<li><strong>遍历右子树，将右子树结点值加到summary</strong></li>
<li><strong>将当前结点值加到summary</strong></li>
<li><strong>将当前结点值置为summary</strong></li>
<li><strong>遍历左子树</strong></li>
</ul>
<p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right,sum);</span><br><span class="line">    *sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=*sum;</span><br><span class="line">    dfs(root-&gt;left,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">convertBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png" alt="image.png"></p>
<h2 id="0x04-合并二叉树"><a href="#0x04-合并二叉树" class="headerlink" title="0x04. 合并二叉树"></a>0x04. <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">合并二叉树</a></h2><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                             \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / \<br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题为2020.9.23的每日一题</p>
</blockquote>
<h3 id="解法：递归-深度优先搜索（DFS）"><a href="#解法：递归-深度优先搜索（DFS）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h3><p>逐层递归，合并到t1上：</p>
<ul>
<li><strong>t1、t2若为空则直接返回其中非空的那一个</strong></li>
<li><strong>将t2的val加到t1的val上</strong></li>
<li><strong>合并t1左与t2左</strong></li>
<li><strong>合并t1右与t2右</strong></li>
</ul>
<p>得到代码如下：</p>
<h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>搜索的次数和结点数量线性增长，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><p>需要的栈空间数量和结点数量线性增长，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h3 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">mergeTrees</span><span class="params">(struct TreeNode* t1, struct TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/23/wXgivj.png" alt="wXgivj.png"></p>
<h3 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        t1.val += t2.val</span><br><span class="line">        t1.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        t1.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t1</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/23/wXgJVx.png" alt="wXgJVx.png"></p>
<h2 id="0x05-二叉搜索树中的众数"><a href="#0x05-二叉搜索树中的众数" class="headerlink" title="0x05.二叉搜索树中的众数"></a>0x05.<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树中的众数</a></h2><blockquote>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],</p>
<p>1<br> \<br>  2<br> /<br>2<br>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="解法：递归-深度优先搜索（DFS）-1"><a href="#解法：递归-深度优先搜索（DFS）-1" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h3><p>考虑到二叉搜索树中<strong>左子树所有结点的值小于当前结点值小于右子树所有结点的值</strong>，故还是采取<strong>深度优先搜索算法</strong></p>
<p>递归中序遍历，由于二叉搜索树的特殊性质，我们遍历的顺序一定是<strong>排序好的</strong></p>
<p>故构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;<span class="comment">//数量最多的数的数量</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//前一结点的连续结点个数</span></span><br><span class="line"><span class="keyword">int</span> pre;<span class="comment">//前一结点的值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//返回的数组的大小</span></span><br><span class="line"><span class="keyword">int</span> *retn;<span class="comment">//返回的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMode</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2150</span>);<span class="comment">//这是多次尝试后得出来的一个大概的边界值233333</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == pre)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//新序列</span></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="built_in">max</span>)<span class="comment">//相同结点数量比max还多，则进行重置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">        <span class="built_in">max</span> = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="built_in">max</span>)<span class="comment">//否则，放入数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = root-&gt;val;<span class="comment">//储存该结点值，继续遍历下一结点</span></span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/24/wxTxSA.png" alt="wxTxSA.png"></p>
<h2 id="0x06-二叉搜索树的最近公共祖先"><a href="#0x06-二叉搜索树的最近公共祖先" class="headerlink" title="0x06.二叉搜索树的最近公共祖先"></a>0x06.<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：该题为2020.9.27的每日一题</p>
</blockquote>
<h4 id="解法：深度优先搜索（DFS）"><a href="#解法：深度优先搜索（DFS）" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>二叉搜索树（BST）有一个很重要的性质就是<strong>左子树所有结点都小于当前节点，右子树所有结点都大于当前结点</strong>，所以我们可以直接通过比较结点的值来进行判断</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == q)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag1 = p-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">bool</span> flag2 = q-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(flag1 != flag2)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag1)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png" alt="@_I_39NAGH0__CROGOJD4XX.png"></p>
<h2 id="0x07-二叉搜索树的最小绝对差"><a href="#0x07-二叉搜索树的最小绝对差" class="headerlink" title="0x07 - 二叉搜索树的最小绝对差"></a>0x07 - <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">二叉搜索树的最小绝对差</a></h2><blockquote>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p>输入：</p>
<p>   1<br>    <br>     3<br>    /<br>   2</p>
<p>输出：<br>1</p>
<p>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
<p>提示：</p>
<p>树中至少有 2 个节点。<br>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="解法：深度优先搜索-中序遍历"><a href="#解法：深度优先搜索-中序遍历" class="headerlink" title="解法：深度优先搜索 + 中序遍历"></a>解法：深度优先搜索 + 中序遍历</h3><p>因为是二叉搜索树，所以当进行中序遍历时肯定会按照从小到大的结点进行遍历</p>
<p>最小绝对差肯定出现在相邻值结点中，这里就不再过多赘叙了</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">-1</span>)</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = (root-&gt;val - pre) &lt; ans ? (root-&gt;val - pre) : ans;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    ans = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png" alt="image.png"></p>
<h2 id="0x08-二叉搜索树节点最小距离"><a href="#0x08-二叉搜索树节点最小距离" class="headerlink" title="0x08 - 二叉搜索树节点最小距离"></a>0x08 - <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">二叉搜索树节点最小距离</a></h2><blockquote>
<p>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p>
<p>示例：</p>
<p>输入: root = [4,2,6,1,3,null,null]<br>输出: 1<br>解释:<br>注意，root是树节点对象(TreeNode object)，而不是数组。</p>
<p>给定的树 [4,2,6,1,3,null,null] 可表示为下图:</p>
<pre><code>      4
    /   \
  2      6
 / \    
1   3  </code></pre><p>最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。</p>
<p>注意：</p>
<p>二叉树的大小范围在 2 到 100。<br>二叉树总是有效的，每个节点的值都是整数，且不重复。<br>本题与 530：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>和上一题一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pre;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">min</span> = (root-&gt;val - pre &gt; <span class="built_in">min</span>) ? <span class="built_in">min</span> : (root-&gt;val - pre);</span><br><span class="line">    pre = root-&gt;val;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">min</span> = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/12/ZO73tM64GYXsf1c.png" alt="image.png"></p>
<h1 id="0x02-难度：中等"><a href="#0x02-难度：中等" class="headerlink" title="0x02.难度：中等"></a>0x02.难度：中等</h1><h2 id="0x00-二叉树中的列表"><a href="#0x00-二叉树中的列表" class="headerlink" title="0x00.二叉树中的列表"></a>0x00.<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">二叉树中的列表</a></h2><blockquote>
<p>给你一棵以 <code>root</code> 为根的二叉树和一个 <code>head</code> 为第一个节点的链表。</p>
<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 <code>head</code> 为首的链表中每个节点的值，那么请你返回 <code>True</code>，否则返回 <code>False</code> 。</p>
<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png" alt=""></p>
<blockquote>
<p>输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true<br>解释：树中蓝色的节点构成了与链表对应的子路径。</p>
</blockquote>
<p>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png" alt=""></p>
<blockquote>
<p>输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：true</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]<br>输出：false<br>解释：二叉树中不存在一一对应链表的路径。</p>
</blockquote>
<p>提示：</p>
<p>二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。<br>链表包含的节点数目在 1 到 100 之间。<br>二叉树包含的节点数目在 1 到 2500 之间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-in-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这题咋一看很难的样子，其实仔细一想，这不就是我们常用的递归算法中的二叉树的前序遍历🐎，一股熟悉的感觉扑面而来www</p>
<blockquote>
<p>前序遍历：先遍历根节点，再遍历左节点，再遍历又节点</p>
</blockquote>
<blockquote>
<p>不熟悉递归算法的可以先看看<a href="https://blog.csdn.net/arttnba3/article/details/102748671" target="_blank" rel="noopener">我以前的博文</a>，然后把<a href="http://noi.openjudge.cn/ch0205/1700/" target="_blank" rel="noopener">OpenJudge.1700:八皇后问题</a>给做了，那么这道题的算法你基本上也就该明白了</p>
</blockquote>
<p><strong>思路：递归前序遍历二叉树查找对应的&quot;链表&quot;，找到了直接返回True，遍历完整棵树都没找到则返回False</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">seek</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数进行对比</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//链表遍历完了，直接true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="comment">//链表没完树先到头肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val!=root-&gt;val)<span class="comment">//遍历到一半不一样，肯定是false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head-&gt;next,root-&gt;left)||<span class="built_in">seek</span>(head-&gt;next,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubPath</span><span class="params">(struct ListNode* head, struct TreeNode* root)</span><span class="comment">//此函数仅用作开始对比的入口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">seek</span>(head,root)||isSubPath(head,root-&gt;left)||isSubPath(head,root-&gt;right);<span class="comment">//根节点||左孩子做根节点||右孩子做根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/23/xOrMznpe3V6hmJ5.png" alt="QQ截图20200423032409.png"></p>
<h2 id="0x01-冗余连接"><a href="#0x01-冗余连接" class="headerlink" title="0x01. 冗余连接"></a>0x01.<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener"> 冗余连接</a></h2><blockquote>
<p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<p>示例 1：</p>
<p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的无向图为:<br>  1<br> / \<br>2 - 3<br>示例 2：</p>
<p>输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br>解释: 给定的无向图为:<br>5 - 1 - 2<br>    |     |<br>    4 - 3<br>注意:</p>
<p>输入的二维数组大小在 3 到 1000。<br>二维数组中的整数在1到N之间，其中N是输入数组的大小。<br>更新(2017-09-26):<br>我们已经重新检查了问题描述及测试用例，明确图是无向 图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><del>图有的时候是树，树无时无刻是图</del></p>
<h3 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h3><p>由于本题所给的是无向图，故不需要考虑边的方向</p>
<p>考虑<strong>并查集算法</strong>：将所有联通的点都纳入数个集合中以方便查找：</p>
<ul>
<li>初始化每个点为一个自身的集合</li>
<li>逐条边读入，分别查找两端点所属集合</li>
<li><strong>两点所属集合不同则合并两集合，否则返回该条边即可</strong></li>
</ul>
<h3 id="初版代码"><a href="#初版代码" class="headerlink" title="初版代码"></a>初版代码</h3><p>一开始我是这么写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">10000</span>][<span class="number">10000</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//第一维分配给每一个点，第二维作为该点的集合保存其他附庸点</span></span><br><span class="line"><span class="keyword">int</span> set_size[<span class="number">10000</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//0表示所属集合，1表示集合中点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> set_size[src][<span class="number">0</span>] == src ? src : find_x(set_size[src][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(set_size[s1][<span class="number">0</span>]!=s1)</span><br><span class="line">        s1 = set_size[s1][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(set_size[s2][<span class="number">0</span>]!=s2)</span><br><span class="line">        s2 = set_size[s2][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=set_size[s2][<span class="number">1</span>];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s1][<span class="number">1</span>]++;</span><br><span class="line">        <span class="built_in">set</span>[s1][set_size[s1][<span class="number">1</span>]] = <span class="built_in">set</span>[s2][i];</span><br><span class="line">    &#125;</span><br><span class="line">    set_size[s2][<span class="number">0</span>] = s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[i][<span class="number">0</span>] = <span class="built_in">set</span>[i][<span class="number">0</span>] = i;</span><br><span class="line">        set_size[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        flag1 = find_x(start);</span><br><span class="line">        flag2 = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1 == flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = start;</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        union_set(start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于一开始我们就初始化一个较大的二维数组，故空间复杂度上比较吃亏</p>
<p><img src="https://i.loli.net/2020/09/17/3VoQgCI1NvSJ7wt.png" alt="image.png"></p>
<h3 id="优化：减少冗余步骤与空间"><a href="#优化：减少冗余步骤与空间" class="headerlink" title="优化：减少冗余步骤与空间"></a>优化：减少冗余步骤与空间</h3><p>我们尝试改变之前一拍脑门时繁复冗杂的写法，在归并时仅记录长度进行归并即可（即小集合归并到大集合），并使用动态数组以尽量减少空间使用</p>
<p>思路还是合之前的一样，构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> *set_size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>[src] == src ? src : find_x(<span class="built_in">set</span>[src]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    s1 = find_x(s1);</span><br><span class="line">    s2 = find_x(s2);</span><br><span class="line">    <span class="keyword">if</span>(set_size[s1]&lt;set_size[s2])</span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s2] += set_size[s1];</span><br><span class="line">        <span class="built_in">set</span>[s1] = <span class="built_in">set</span>[s2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        set_size[s1] += set_size[s2];</span><br><span class="line">        <span class="built_in">set</span>[s2] = <span class="built_in">set</span>[s1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    set_size = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    ret[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">set</span>[i] = i;</span><br><span class="line">        set_size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        flag1 = find_x(start);</span><br><span class="line">        flag2 = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag1 == flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = start;</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="built_in">end</span>;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        union_set(start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（减少差不多一半空间，<del>但是看起来并没有什么用</del>…）</p>
<p><img src="https://i.loli.net/2020/09/17/Hsxip4fmnoXAyvC.png" alt="image.png"></p>
<h2 id="0x02-从二叉搜索树到更大和树"><a href="#0x02-从二叉搜索树到更大和树" class="headerlink" title="0x02.从二叉搜索树到更大和树"></a>0x02.<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">从二叉搜索树到更大和树</a></h2><blockquote>
<p>给出二叉 搜索 树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>
<p>示例：</p>
<p><img src="https://i.loli.net/2020/09/21/RaA7r8BHmc9K2yX.png" alt="image.png"></p>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>提示：</p>
<p>树中的节点数介于 1 和 100 之间。<br>每个节点的值介于 0 和 100 之间。<br>给定的树为二叉搜索树。</p>
<p>注意：该题目与 538: <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a>  相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题和上面<strong>【难度：简单】0x03.把二叉搜索树转换为累加树</strong>是<strong>一模一样的</strong>（<del>所以说为什么换一个名字难度就变成中等了啊</del></p>
<p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p>
<h3 id="解法：深度优先搜索-反序中序遍历-1"><a href="#解法：深度优先搜索-反序中序遍历-1" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h3><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p>
<ul>
<li><strong>遍历右子树，将右子树结点值加到summary</strong></li>
<li><strong>将当前结点值加到summary</strong></li>
<li><strong>将当前结点值置为summary</strong></li>
<li><strong>遍历左子树</strong></li>
</ul>
<p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=sum;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">bstToGst</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/hx5F6qdKp2tzr7D.png" alt="image.png"></p>
<h2 id="0x03-路径总和-II"><a href="#0x03-路径总和-II" class="headerlink" title="0x03.路径总和 II"></a>0x03.<a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></h2><blockquote>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>    5
   / \
  4   8
 /   / \
11  13  4</code></pre><p>   /  \    / <br>   7    2  5   1</p>
<p>返回:</p>
<p>[<br>[5,4,11,2],<br>[5,8,4,5]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="解法：深度优先搜索（DFS）-递归中序遍历"><a href="#解法：深度优先搜索（DFS）-递归中序遍历" class="headerlink" title="解法：深度优先搜索（DFS）+ 递归中序遍历"></a>解法：深度优先搜索（DFS）+ 递归中序遍历</h3><p>中序遍历，一层一层地搜下去就完事了，用一个栈来保存路径，遇到叶子结点且刚好到了这一层时sum已经被减到0了就保存路径</p>
<p>需要注意的是<strong>在每一层搜索结束后都要将该层结点弹出栈</strong></p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> **retn;</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> nums;</span><br><span class="line"><span class="keyword">int</span> retn_nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    <span class="built_in">set</span>[nums++] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> * path = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        <span class="built_in">memcpy</span>(path, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        (*returnColumnSizes)[retn_nums] = nums;</span><br><span class="line">        retn[retn_nums++] = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;left,sum,returnColumnSizes);</span><br><span class="line">    dfs(root-&gt;right,sum,returnColumnSizes);</span><br><span class="line">    nums--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">pathSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn_nums = nums = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    retn = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="number">1000</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        (*returnColumnSizes)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,returnColumnSizes);</span><br><span class="line">    *returnSize = retn_nums;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png" alt="image.png"></p>
<h2 id="0x04-填充每个节点的下一个右侧节点指针-II"><a href="#0x04-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="0x04.填充每个节点的下一个右侧节点指针 II"></a>0x04.<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针 II</a></h2><blockquote>
<p>给定一个二叉树</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="image.png"></p>
<p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p>提示：</p>
<p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题为2020.9.28的每日一题</p>
</blockquote>
<h3 id="解法一：层次遍历"><a href="#解法一：层次遍历" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h3><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p>
<p>大致过程如下图</p>
<p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p>
<h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<h4 id="C语言版：-1"><a href="#C语言版：-1" class="headerlink" title="C语言版："></a>C语言版：</h4><p>我么可以得到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a Node.</span><br><span class="line"> * struct Node &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct Node *left;</span><br><span class="line"> *     struct Node *right;</span><br><span class="line"> *     struct Node *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">struct Node * last_node, *next_start;</span><br><span class="line"></span><br><span class="line">void connectList(struct Node * node)</span><br><span class="line">&#123;</span><br><span class="line">    if(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node *connect(struct Node *root) </span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    struct Node *start &#x3D; root;</span><br><span class="line">    while(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node &#x3D; NULL, next_start &#x3D; NULL;</span><br><span class="line">        while(start)</span><br><span class="line">        &#123;</span><br><span class="line">            if(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            if(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start &#x3D; start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start &#x3D; next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png" alt="_XU940OX_R1_5XJK_H@N~5I.png"></p>
<h4 id="Python语言版：-1"><a href="#Python语言版：-1" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_node: <span class="string">'Node'</span></span><br><span class="line">        self.next_start: <span class="string">'Node'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        start = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">            self.last_node = <span class="literal">None</span></span><br><span class="line">            self.next_start = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> start.left != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.left</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.left</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> start.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.right</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.right</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.right</span><br><span class="line"></span><br><span class="line">                start = start.next</span><br><span class="line"></span><br><span class="line">            start = self.next_start</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectList</span><span class="params">(self, node: <span class="string">'Node'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">            self.last_node.next = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">            self.next_start = node</span><br><span class="line"></span><br><span class="line">        self.last_node = node</span><br></pre></td></tr></table></figure>



<p>![XTJUK27UN3_66_OSL5`_BZB.png](<a href="https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png</a>)</p>
<h2 id="0x05-二叉树的后序遍历"><a href="#0x05-二叉树的后序遍历" class="headerlink" title="0x05.二叉树的后序遍历"></a>0x05.<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></h2><blockquote>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>1<br> <br>  2<br> /<br>3 </p>
<p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题为2020.9.29的每日一题</p>
</blockquote>
<h3 id="解法一：深度优先搜索（DFS）-递归后续遍历"><a href="#解法一：深度优先搜索（DFS）-递归后续遍历" class="headerlink" title="解法一：深度优先搜索（DFS） + 递归后续遍历"></a>解法一：深度优先搜索（DFS） + 递归后续遍历</h3><p>后序遍历的顺序是<strong>左→右→根</strong>，使用递归可以三分钟内解决</p>
<h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> * retn;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png" alt="_B35__WY2L_Z`E_`27DA_FM.png"></p>
<h2 id="0x06-二叉搜索树中的插入操作"><a href="#0x06-二叉搜索树中的插入操作" class="headerlink" title="0x06. 二叉搜索树中的插入操作"></a>0x06.<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener"> 二叉搜索树中的插入操作</a></h2><blockquote>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>例如, </p>
<p>给定二叉搜索树:</p>
<pre><code>    4
   / \
  2   7
 / \
1   3</code></pre><p>和 插入的值: 5<br>你可以返回这个二叉搜索树:</p>
<pre><code>     4
   /   \
  2     7
 / \   /
1   3 5</code></pre><p>或者这个树也是有效的:</p>
<pre><code>     5
   /   \
  2     7
 / \   
1   3
     \
      4</code></pre><p>提示：</p>
<p>给定的树上的节点数介于 0 和 10^4 之间<br>每个节点都有一个唯一整数值，取值范围从 0 到 10^8<br>-10^8 &lt;= val &lt;= 10^8<br>新值和原始二叉搜索树中的任意节点值都不同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题为2020.9.30的每日一题</p>
</blockquote>
<h3 id="解法：深度优先搜索（DFS）-1"><a href="#解法：深度优先搜索（DFS）-1" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h3><p>深度优先搜索遍历这棵树， <strong>插入值大于结点值则往右子树插，否则往左子树插</strong></p>
<p><strong>递归</strong>可以很方便地解决这个问题</p>
<h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都有可能过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;right-&gt;val = val;</span><br><span class="line">            root-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;left-&gt;val = val;</span><br><span class="line">            root-&gt;left-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">insertIntoBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![Z08G_KN_4GTD1`J_3NC0__F.png](<a href="https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png</a>)</p>
<h2 id="0x07-填充每个节点的下一个右侧节点指针"><a href="#0x07-填充每个节点的下一个右侧节点指针" class="headerlink" title="0x07. 填充每个节点的下一个右侧节点指针"></a>0x07.<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener"> 填充每个节点的下一个右侧节点指针</a></h2><blockquote>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="image.png"></p>
<p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}</p>
<p>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}</p>
<p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p>提示：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题和2020.9.28的每日一题几乎完全一样</p>
</blockquote>
<h3 id="解法一：层次遍历-1"><a href="#解法一：层次遍历-1" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h3><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p>
<p>大致过程如下图</p>
<p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p>
<h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct Node *left;</span></span><br><span class="line"><span class="comment"> *     struct Node *right;</span></span><br><span class="line"><span class="comment"> *     struct Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last_node</span>, *<span class="title">next_start</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectList</span><span class="params">(struct Node * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">connect</span><span class="params">(struct Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">start</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node = <span class="literal">NULL</span>, next_start = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start = next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png" alt="image.png"></p>
<h1 id="0x03-难度：困难"><a href="#0x03-难度：困难" class="headerlink" title="0x03.难度：困难"></a>0x03.难度：困难</h1><h2 id="0x00-冗余连接-II"><a href="#0x00-冗余连接-II" class="headerlink" title="0x00. 冗余连接 II"></a>0x00.<a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener"> 冗余连接 II</a></h2><blockquote>
<p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p>示例 1:</p>
<p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>1<br>/ <br>v   v<br>2–&gt;3<br>示例 2:</p>
<p>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 &lt;- 1 -&gt; 2<br>  ^    |<br>  |    v<br>  4 &lt;- 3<br>注意:</p>
<p>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：该题为2020.9.17的每日一题</p>
</blockquote>
<h4 id="解法：并查集-1"><a href="#解法：并查集-1" class="headerlink" title="解法：并查集"></a>解法：并查集</h4><p>半夜三点多把前置题：<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a>给做了，感觉稍微有了点头绪，<del>其实还是啥都不知道</del>…</p>
<p>晚上大概想清楚了，同样是采用并查集的思想，不过考虑到该图为有向图，同时题目给定的图<strong>必定有且仅有一条多余的边使得该图无法成为一颗树</strong></p>
<p>可能存在如下情况：</p>
<ul>
<li><strong>一个节点的入度大于等于2</strong>（<strong>存在两个及以上父结点，本题数据构造保证只可能存在两个父结点的情况</strong>）</li>
<li><strong>图中存在回路</strong></li>
<li><strong>以上两种情况同时存在</strong></li>
</ul>
<p>如下图所示（字丑见谅QwQ）：</p>
<p><img src="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png" alt="33A2C56517F4926A49A4C03363AECFD0.png"></p>
<p>故我们很容易（并不Or2）能够得到解开这道题的算法：</p>
<ul>
<li><strong>将每一个结点初始化为一棵单独的树，其父结点初始化为自身</strong></li>
<li><strong>使用两个数组分别保存每个结点的父结点与所属的树的根结点</strong></li>
<li><strong>遍历每一条边，重新记录下每个结点的父结点与根节点</strong></li>
<li><strong>当一个结点的入度大于1时（出现第二个不是自身结点的父亲），记录该边为争议边</strong></li>
<li><strong>当一条边的始末结点同属于一棵树时，记录该条边为回路边</strong></li>
<li><strong>两种情况都不存在，则将该边的末结点的父结点标为该边的始结点，并合并两结点所在的树</strong></li>
<li><strong>当争议边不存在时，直接删除回路边</strong></li>
<li><strong>争议边若存在，若同时存在回路边，则删除争议边末尾结点及其父结点所构成边，否则删除争议边</strong></li>
</ul>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * ancestors;<span class="comment">//（并查集）记录每个节点的根结点</span></span><br><span class="line"><span class="keyword">int</span> * parent;<span class="comment">//记录每个节点的父结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查找该结点所属树的根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ancestors[x] ? x : (ancestors[x] = find_x(ancestors[x]));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_ancestor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ancestors[find_x(a)] = find_x(b);<span class="comment">//将两棵树合并为一棵树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ancestors = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    parent = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = ancestors[i] = i;<span class="comment">//初始化每个结点为单独的一棵树（并查集），结点的父结点标记为自身</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//conflict：可能存在争议的边</span></span><br><span class="line">    <span class="comment">//circle：可能形成回路的边</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>, a_start, a_end, conflict = <span class="number">-1</span>, <span class="built_in">circle</span> = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        a_start = find_x(start);</span><br><span class="line">        a_end = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(parent[<span class="built_in">end</span>] != <span class="built_in">end</span>)<span class="comment">//该条边的尾结点已经与其他结点相连（即加上这条边后入度大于1）</span></span><br><span class="line">        &#123;</span><br><span class="line">            conflict = i;<span class="comment">//记录该条边为争议边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">end</span>] = start;</span><br><span class="line">            <span class="keyword">if</span>(a_start == a_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">circle</span> = i;<span class="comment">//该条边两结点的根结点相同，可能形成回路</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                union_ancestor(start, <span class="built_in">end</span>);<span class="comment">//将两棵树合并为一棵树（并查集）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(conflict&lt;<span class="number">0</span>)<span class="comment">//不存在争议边，只存在形成回路的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = edges[<span class="built_in">circle</span>][<span class="number">0</span>];</span><br><span class="line">        ret[<span class="number">1</span>] = edges[<span class="built_in">circle</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在争议边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">circle</span>&gt;<span class="number">0</span>)<span class="comment">//同时存在回路边</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = parent[edges[conflict][<span class="number">1</span>]];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = edges[conflict][<span class="number">0</span>];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png" alt="image.png"></p>
<h2 id="0x01-监控二叉树"><a href="#0x01-监控二叉树" class="headerlink" title="0x01. 监控二叉树"></a>0x01.<a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener"> 监控二叉树</a></h2><blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="image.png"></p>
<p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="image.png"></p>
<p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p>
<p>提示：</p>
<p>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>该题为2020.9.22的每日一题</p>
</blockquote>
<p>仔细想想，对于一个结点是否需要安装摄像头，其实是<strong>由其子树的状态来决定的</strong>，那么我们可以使用<strong>动态规划算法</strong></p>
<h3 id="解法：递归-深度优先搜索（DFS）-动态规划（DP）"><a href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）"></a>解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</h3><p>大概如下图所示：<br><img src="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png" alt="image.png"></p>
<p>我们考虑有以下几种情况：</p>
<ul>
<li><strong>当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA</strong></li>
<li><strong>当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED</strong></li>
<li><strong>当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED</strong></li>
<li><strong>对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED</strong></li>
</ul>
<p>同时，<strong>我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头</strong></p>
<p>为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * status code</span></span><br><span class="line"><span class="comment"> * 0: waiting for pwn</span></span><br><span class="line"><span class="comment"> * 1: has been pwn</span></span><br><span class="line"><span class="comment"> * 2: camara here</span></span><br><span class="line"><span class="comment"> *-1: inner error, just a placeholder in fact</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNCOVERED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_COVERED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_CAMERA 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(struct TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts=<span class="number">0</span>;<span class="comment">//amounts of camera</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a camera to the root if status of root is 0</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(root,&amp;amounts) == STATUS_UNCOVERED)</span><br><span class="line">        amounts++;</span><br><span class="line">    <span class="keyword">return</span> amounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> * amounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NULL pointer signed as status 1</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the status of left and right node</span></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left, amounts);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right, amounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if one of both uncovered yet, a camera is needed</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED)</span><br><span class="line">    &#123;</span><br><span class="line">        (*amounts)++;</span><br><span class="line">        <span class="keyword">return</span> STATUS_CAMERA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both are covered, father's of root may need a camera</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNCOVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there's at least one camera in both childs, the root is covered</span></span><br><span class="line">    <span class="keyword">if</span>(left + right &gt; STATUS_CAMERA)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//error code(not used)</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png" alt="EE8895_CCLKZDA_OPW4_FT1.png"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
              <a href="/tags/%E9%A2%98%E8%A7%A3/" rel="tag"># 题解</a>
              <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
              <a href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag"># 链表</a>
              <a href="/tags/%E6%A0%91/" rel="tag"># 树</a>
              <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"># 二叉树</a>
              <a href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag"># 图论</a>
              <a href="/tags/%E6%97%A0%E5%90%91%E5%9B%BE/" rel="tag"># 无向图</a>
              <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag"># 并查集</a>
              <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/" rel="tag"># 深度优先搜索（DFS）</a>
              <a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/" rel="tag"># 广度优先搜索（BFS）</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/" rel="prev" title="【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3">
      <i class="fa fa-chevron-left"></i> 【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/17/%E3%80%90CTF%E8%B5%84%E6%96%99-0x0001%E3%80%91moeCTF2020-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E7%8B%B1%20by%20arttnba3/" rel="next" title="post">
      post <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-绪论"><span class="nav-number">1.</span> <span class="nav-text">0x00.绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pre-什么是树"><span class="nav-number">1.1.</span> <span class="nav-text">pre.什么是树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-难度：简单"><span class="nav-number">2.</span> <span class="nav-text">0x01.难度：简单</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-二叉树的最大深度"><span class="nav-number">2.1.</span> <span class="nav-text">0x00.二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-翻转二叉树"><span class="nav-number">2.2.</span> <span class="nav-text">0x01.翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一：递归"><span class="nav-number">2.2.1.</span> <span class="nav-text">解法一：递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二：广度优先搜索（队列）"><span class="nav-number">2.2.2.</span> <span class="nav-text">解法二：广度优先搜索（队列）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-左叶子之和"><span class="nav-number">2.3.</span> <span class="nav-text">0x02. 左叶子之和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一：深度优先搜索（DFS）"><span class="nav-number">2.3.1.</span> <span class="nav-text">解法一：深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解法二：广度优先搜索（BFS）-队列"><span class="nav-number">2.3.2.</span> <span class="nav-text">解法二：广度优先搜索（BFS）+ 队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-把二叉搜索树转换为累加树"><span class="nav-number">2.4.</span> <span class="nav-text">0x03.把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：深度优先搜索-反序中序遍历"><span class="nav-number">2.4.1.</span> <span class="nav-text">解法：深度优先搜索 + 反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-合并二叉树"><span class="nav-number">2.5.</span> <span class="nav-text">0x04. 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）"><span class="nav-number">2.5.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间复杂度："><span class="nav-number">2.5.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空间复杂度："><span class="nav-number">2.5.3.</span> <span class="nav-text">空间复杂度：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C语言版："><span class="nav-number">2.5.4.</span> <span class="nav-text">C语言版：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python语言版："><span class="nav-number">2.5.5.</span> <span class="nav-text">Python语言版：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-二叉搜索树中的众数"><span class="nav-number">2.6.</span> <span class="nav-text">0x05.二叉搜索树中的众数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）-1"><span class="nav-number">2.6.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-二叉搜索树的最近公共祖先"><span class="nav-number">2.7.</span> <span class="nav-text">0x06.二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索（DFS）"><span class="nav-number">2.7.0.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-二叉搜索树的最小绝对差"><span class="nav-number">2.8.</span> <span class="nav-text">0x07 - 二叉搜索树的最小绝对差</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：深度优先搜索-中序遍历"><span class="nav-number">2.8.1.</span> <span class="nav-text">解法：深度优先搜索 + 中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x08-二叉搜索树节点最小距离"><span class="nav-number">2.9.</span> <span class="nav-text">0x08 - 二叉搜索树节点最小距离</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-难度：中等"><span class="nav-number">3.</span> <span class="nav-text">0x02.难度：中等</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-二叉树中的列表"><span class="nav-number">3.1.</span> <span class="nav-text">0x00.二叉树中的列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-冗余连接"><span class="nav-number">3.2.</span> <span class="nav-text">0x01. 冗余连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：并查集"><span class="nav-number">3.2.1.</span> <span class="nav-text">解法：并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初版代码"><span class="nav-number">3.2.2.</span> <span class="nav-text">初版代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化：减少冗余步骤与空间"><span class="nav-number">3.2.3.</span> <span class="nav-text">优化：减少冗余步骤与空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-从二叉搜索树到更大和树"><span class="nav-number">3.3.</span> <span class="nav-text">0x02.从二叉搜索树到更大和树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：深度优先搜索-反序中序遍历-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">解法：深度优先搜索 + 反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-路径总和-II"><span class="nav-number">3.4.</span> <span class="nav-text">0x03.路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：深度优先搜索（DFS）-递归中序遍历"><span class="nav-number">3.4.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）+ 递归中序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-填充每个节点的下一个右侧节点指针-II"><span class="nav-number">3.5.</span> <span class="nav-text">0x04.填充每个节点的下一个右侧节点指针 II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一：层次遍历"><span class="nav-number">3.5.1.</span> <span class="nav-text">解法一：层次遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-1"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-1"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">空间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C语言版：-1"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">C语言版：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python语言版：-1"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">Python语言版：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-二叉树的后序遍历"><span class="nav-number">3.6.</span> <span class="nav-text">0x05.二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一：深度优先搜索（DFS）-递归后续遍历"><span class="nav-number">3.6.1.</span> <span class="nav-text">解法一：深度优先搜索（DFS） + 递归后续遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-2"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-2"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-二叉搜索树中的插入操作"><span class="nav-number">3.7.</span> <span class="nav-text">0x06. 二叉搜索树中的插入操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：深度优先搜索（DFS）-1"><span class="nav-number">3.7.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-3"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-3"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-填充每个节点的下一个右侧节点指针"><span class="nav-number">3.8.</span> <span class="nav-text">0x07. 填充每个节点的下一个右侧节点指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法一：层次遍历-1"><span class="nav-number">3.8.1.</span> <span class="nav-text">解法一：层次遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-4"><span class="nav-number">3.8.1.1.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-4"><span class="nav-number">3.8.1.2.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-难度：困难"><span class="nav-number">4.</span> <span class="nav-text">0x03.难度：困难</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-冗余连接-II"><span class="nav-number">4.1.</span> <span class="nav-text">0x00. 冗余连接 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：并查集-1"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">解法：并查集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-监控二叉树"><span class="nav-number">4.2.</span> <span class="nav-text">0x01. 监控二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）"><span class="nav-number">4.2.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="arttnba3"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">arttnba3</p>
  <div class="site-description" itemprop="description">- 做了关于你的梦，所以不愿醒来呢 -</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/arttnba3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;arttnba3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1543127579@qq.com" title="E-Mail → mailto:1543127579@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/7518681149" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7518681149" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/arttnba3" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;arttnba3" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Friends' Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.wootec.top/" title="https:&#x2F;&#x2F;www.wootec.top" rel="noopener" target="_blank">Reverier</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://luoq1an.github.io/" title="https:&#x2F;&#x2F;luoq1an.github.io" rel="noopener" target="_blank">luoqian</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ll1ng.github.io/" title="https:&#x2F;&#x2F;ll1ng.github.io" rel="noopener" target="_blank">ling</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://shal10w.github.io/" title="https:&#x2F;&#x2F;shal10w.github.io" rel="noopener" target="_blank">shallow</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://eqqie.cn/" title="https:&#x2F;&#x2F;eqqie.cn" rel="noopener" target="_blank">eqqie</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://cor1e.cn/" title="https:&#x2F;&#x2F;cor1e.cn" rel="noopener" target="_blank">cor1e</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yunq1ao.com/" title="https:&#x2F;&#x2F;yunq1ao.com" rel="noopener" target="_blank">yunqiao</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mercer5.github.io/" title="https:&#x2F;&#x2F;mercer5.github.io" rel="noopener" target="_blank">mercer</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">arttnba3</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'a040036b8e5ab6a9838d',
      clientSecret: '7b9006697fe7a78e56f22a025caf2deb03e14ea8',
      repo        : 'BlogComment',
      owner       : 'SakuraiHimeki',
      admin       : ['SakuraiHimeki'],
      id          : 'bf6c689da66c314361769527a2acf42b',
        language: '',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
