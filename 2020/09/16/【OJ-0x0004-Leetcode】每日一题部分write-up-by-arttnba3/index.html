<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法,C/C++,题解,链表,Leetcode,动态规划,树,二叉树,广度优先搜索（BFS）,深度优先搜索（DFS）,双指针,哈希表," />





  <link rel="alternate" href="/atom.xml" title="arttnba3's blog" type="application/atom+xml" />






<meta name="description" content="0x00.绪论为了保持编程的一个手感（毕竟疫情以来打的代码比以前少得多了），同时也为了提高自己的姿势水平（x），打算从今天开始刷Leetcode提供的每日一题并在此做一个小小的记录（x） 希望几年以后这里已经积累了上千道题⑧（没可能的">
<meta property="og:type" content="article">
<meta property="og:title" content="【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3">
<meta property="og:url" content="http://arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/index.html">
<meta property="og:site_name" content="arttnba3&#39;s blog">
<meta property="og:description" content="0x00.绪论为了保持编程的一个手感（毕竟疫情以来打的代码比以前少得多了），同时也为了提高自己的姿势水平（x），打算从今天开始刷Leetcode提供的每日一题并在此做一个小小的记录（x） 希望几年以后这里已经积累了上千道题⑧（没可能的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/10/15/rqasE7pNAxQXy9l.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png">
<meta property="og:image" content="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png">
<meta property="og:image" content="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png">
<meta property="og:image" content="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png">
<meta property="og:image" content="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/46tKB3T1NSufJcR.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/WjVik4QFfobyUmM.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/pKmsDOZvUP9BgHT.png">
<meta property="og:image" content="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png">
<meta property="og:image" content="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png">
<meta property="og:image" content="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png">
<meta property="og:image" content="https://i.loli.net/2020/09/22/2tbv6R7LizECw3e.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/23/wXgivj.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/23/wXgJVx.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/24/wxTxSA.png">
<meta property="og:image" content="https://i.loli.net/2020/09/25/sYMeb6NL3aSJxdC.png">
<meta property="og:image" content="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png">
<meta property="og:image" content="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/485DnfumcRterSM.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png">
<meta property="og:image" content="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png">
<meta property="og:image" content="https://i.loli.net/2020/10/02/HrSx812GPa97JtT.png">
<meta property="og:image" content="https://i.loli.net/2020/10/04/uSQzNqR4AcZYTtX.png">
<meta property="og:image" content="https://i.loli.net/2020/10/07/MEFrixChODK4c1n.png">
<meta property="og:image" content="https://i.loli.net/2020/10/08/EzXUN93shxaOjVn.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://i.loli.net/2020/10/09/PtGJv5EIz3RgAWd.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/09/23/wXfJ6e.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://i.loli.net/2020/10/10/9kICpfDBudOlQUF.png">
<meta property="og:image" content="https://i.loli.net/2020/10/10/Mo8YQgWPSTHKRwD.png">
<meta property="og:image" content="https://i.loli.net/2020/10/10/YJ9p1S3ryl6jkuM.png">
<meta property="og:image" content="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png">
<meta property="og:image" content="https://i.loli.net/2020/10/14/WenKdZaqkslmrFg.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png">
<meta property="og:image" content="https://i.loli.net/2020/09/28/485DnfumcRterSM.png">
<meta property="og:image" content="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png">
<meta property="article:published_time" content="2020-09-16T10:52:28.000Z">
<meta property="article:modified_time" content="2020-10-14T16:35:12.074Z">
<meta property="article:author" content="arttnba3">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="题解">
<meta property="article:tag" content="链表">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="树">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="广度优先搜索（BFS）">
<meta property="article:tag" content="深度优先搜索（DFS）">
<meta property="article:tag" content="双指针">
<meta property="article:tag" content="哈希表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/10/15/rqasE7pNAxQXy9l.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arttnba3.cn/2020/09/16/【OJ-0x0004-Leetcode】每日一题部分write-up-by-arttnba3/"/>





  <title>【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3 | arttnba3's blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/arttnba3" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">arttnba3's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">- arttnba3的隐秘小窝 -</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="arttnba3">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="arttnba3's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-16T18:52:28+08:00">
                2020-09-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-15T00:35:12+08:00">
                2020-10-15
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Online-Judge/" itemprop="url" rel="index">
                    <span itemprop="name">Online Judge</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  14,286 字
                </span>
              

              

              
            </div>
          

          

          
              <i class="fa fa-thumb-tack"></i>
              <font color=green>置顶</font>
              <span class="post-meta-divider">|</span>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="0x00-绪论"><a href="#0x00-绪论" class="headerlink" title="0x00.绪论"></a>0x00.绪论</h1><p>为了保持编程的一个手感（毕竟疫情以来打的代码比以前少得多了），同时也为了提高自己的姿势水平（x），打算从今天开始刷Leetcode提供的每日一题并在此做一个小小的记录（x）</p>
<p>希望几年以后这里已经积累了上千道题⑧（<del>没可能的</del></p>
<img src="https://i.loli.net/2020/10/15/rqasE7pNAxQXy9l.png" alt="image.png" style="zoom:50%;" />

<a id="more"></a>

<h1 id="0x01-2020"><a href="#0x01-2020" class="headerlink" title="0x01. 2020"></a>0x01. 2020</h1><h2 id="September"><a href="#September" class="headerlink" title="September"></a>September</h2><h3 id="16-226-翻转二叉树（简单）"><a href="#16-226-翻转二叉树（简单）" class="headerlink" title="16 - 226. 翻转二叉树（简单）"></a>16 - <a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树（简单）</a></h3><blockquote>
<p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a> 启发的 ：</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
</blockquote>
<p>很常规的也很简单的一道题目，只需<strong>逐层交换左右节点</strong>即可（<del>homebrew的开发者居然写不出这个题么</del>（<del>估计是太紧张le</del>（<del>👈不要在意这家伙天天乱讲</del></p>
<h4 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h4><p>一层一层交换结点的做法，我们很容易就想到递归，故构造代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">temp</span>;</span></span><br><span class="line">    temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = temp;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，递归调用会占用大量的栈空间（每次进行函数调用都会生成一个新的栈帧），所以空间复杂度上不是很好看（</p>
<p><img src="https://i.loli.net/2020/09/16/PaIkMX54n7zH1bJ.png" alt="image.png"></p>
<h4 id="解法二：广度优先搜索（队列）"><a href="#解法二：广度优先搜索（队列）" class="headerlink" title="解法二：广度优先搜索（队列）"></a>解法二：广度优先搜索（队列）</h4><p>大概过程如下：</p>
<ul>
<li>头结点入队</li>
<li>交换左右结点</li>
<li>左右结点入队</li>
<li>头结点出队</li>
</ul>
<p>队列为空时停止即可</p>
<p>因为数据范围不像OI那么变态（x），所以直接用一个很小的数组来储存即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">invertTree</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, <span class="built_in">end</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * (<span class="title">queue</span>[1000]), *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">queue</span>[start] = root;</span><br><span class="line">    <span class="keyword">while</span>(start!=<span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>[start] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;left = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">queue</span>[start]-&gt;right = temp;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>] = <span class="built_in">queue</span>[start]-&gt;left;</span><br><span class="line">            <span class="built_in">queue</span>[<span class="built_in">end</span>+<span class="number">1</span>] = <span class="built_in">queue</span>[start]-&gt;right;</span><br><span class="line">            <span class="built_in">end</span> += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/16/Y68GBXM2hlSKgzs.png" alt="image.png"></p>
<blockquote>
<p>以及这个故事实在是太搞了</p>
<p><img src="https://i.loli.net/2020/09/16/NW26F4OInxfqbmy.png" alt="image.png"></p>
</blockquote>
<h3 id="17-685-冗余连接-II（困难）"><a href="#17-685-冗余连接-II（困难）" class="headerlink" title="17 - 685. 冗余连接 II（困难）"></a>17 - <a href="https://leetcode-cn.com/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II（困难）</a></h3><blockquote>
<p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p>示例 1:</p>
<p>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>  1<br> / <br>v   v<br>2–&gt;3<br>示例 2:</p>
<p>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 &lt;- 1 -&gt; 2<br>     ^    |<br>     |    v<br>     4 &lt;- 3<br>注意:</p>
<p>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/redundant-connection-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><del>第二天就直接上困难难度的题，真有你的啊leetcode</del></p>
<p><del>暂时做不出来，歇菜了Or2</del></p>
<h4 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h4><p>半夜三点多把前置题：<a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a>给做了（见<a href="https://arttnba3.cn/2020/09/17/[OJ-0x0005-Leetcode]树部分write-up-by-arttnba3/">这里</a>），感觉稍微有了点头绪，<del>其实还是啥都不知道</del>…</p>
<p>晚上大概想清楚了，同样是采用并查集的思想，不过考虑到该图为有向图，同时题目给定的图<strong>必定存在一条边使得该图无法成为一颗树</strong></p>
<p>可能存在如下情况：</p>
<ul>
<li><strong>一个节点的入度大于等于2</strong>（<strong>存在两个及以上父结点，本题数据构造保证只可能存在两个父结点的情况</strong>）</li>
<li><strong>图中存在回路</strong></li>
<li><strong>以上两种情况同时存在</strong></li>
</ul>
<p>如下图所示（字丑见谅QwQ）：</p>
<p><img src="https://i.loli.net/2020/09/18/HTi1XVUF7SuIRM3.png" alt="33A2C56517F4926A49A4C03363AECFD0.png"></p>
<p>故我们很容易（并不Or2）能够得到解开这道题的算法：</p>
<ul>
<li><strong>将每一个结点初始化为一棵单独的树，其父结点初始化为自身</strong></li>
<li><strong>使用两个数组分别保存每个结点的父结点与所属的树的根结点</strong></li>
<li><strong>遍历每一条边，重新记录下每个结点的父结点与根节点</strong></li>
<li><strong>当一个结点的入度大于1时，记录该边为争议边</strong></li>
<li><strong>当一条边的始末结点同属于一棵树时，记录该条边为回路边</strong></li>
<li><strong>两种情况都不存在，则将该边的末结点的父结点标为该边的始结点，并合并两结点所在的树</strong></li>
<li><strong>当争议边不存在时，直接删除回路边</strong></li>
<li><strong>争议边若存在，若同时存在回路边，则删除争议边末尾结点及其父结点所构成边，否则删除争议边</strong></li>
</ul>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * ancestors;<span class="comment">//记录每个节点的根结点</span></span><br><span class="line"><span class="keyword">int</span> * parent;<span class="comment">//记录每个节点的父结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_x</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ancestors[x] ? x : (ancestors[x] = find_x(ancestors[x]));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_ancestor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ancestors[find_x(a)] = find_x(b);<span class="comment">//将两棵树合并为一棵树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="keyword">int</span>** edges, <span class="keyword">int</span> edgesSize, <span class="keyword">int</span>* edgesColSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ancestors = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line">    parent = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(edgesSize+<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = ancestors[i] = i;<span class="comment">//初始化每个结点为单独的一棵树（并查集），结点的父结点标记为自身</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//conflict：可能存在争议的边</span></span><br><span class="line">    <span class="comment">//circle：可能形成回路的边</span></span><br><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>, a_start, a_end, conflict = <span class="number">-1</span>, <span class="built_in">circle</span> = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edgesSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        start = edges[i][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">end</span> = edges[i][<span class="number">1</span>];</span><br><span class="line">        a_start = find_x(start);</span><br><span class="line">        a_end = find_x(<span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">if</span>(parent[<span class="built_in">end</span>] != <span class="built_in">end</span>)<span class="comment">//该条边的尾结点已经与其他结点相连（即加上这条边后入度大于1）</span></span><br><span class="line">        &#123;</span><br><span class="line">            conflict = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            parent[<span class="built_in">end</span>] = start;</span><br><span class="line">            <span class="keyword">if</span>(a_start == a_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">circle</span> = i;<span class="comment">//该条边两结点的根结点相同，可能形成回路</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                union_ancestor(start, <span class="built_in">end</span>);<span class="comment">//将两棵树合并为一棵树（并查集）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ret = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(conflict&lt;<span class="number">0</span>)<span class="comment">//不存在争议边，只存在形成回路的边</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = edges[<span class="built_in">circle</span>][<span class="number">0</span>];</span><br><span class="line">        ret[<span class="number">1</span>] = edges[<span class="built_in">circle</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//存在争议边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">circle</span>&gt;<span class="number">0</span>)<span class="comment">//同时存在回路边</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = parent[edges[conflict][<span class="number">1</span>]];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = edges[conflict][<span class="number">0</span>];</span><br><span class="line">            ret[<span class="number">1</span>] = edges[conflict][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/18/IahfqNWwzCoA6GU.png" alt="image.png"></p>
<h3 id="18-47-全排列-II（中等）"><a href="#18-47-全排列-II（中等）" class="headerlink" title="18 - 47. 全排列 II（中等）"></a>18 - <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II（中等）</a></h3><p>明早起来再看，先咕咕咕了（</p>
<h3 id="19-404-左叶子之和（简单）"><a href="#19-404-左叶子之和（简单）" class="headerlink" title="19 - 404. 左叶子之和（简单）"></a>19 - <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和（简单）</a></h3><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<pre><code>3</code></pre><p>   / \<br>  9  20<br>        / \<br>      15   7</p>
<p>在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-left-leaves</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h5 id="解法一：深度优先搜索（DFS）"><a href="#解法一：深度优先搜索（DFS）" class="headerlink" title="解法一：深度优先搜索（DFS）"></a>解法一：深度优先搜索（DFS）</h5><p>一层一层地搜下去，若左结点为叶子结点（无子女）则加上左结点的值，否则搜索子结点，若右结点不为子结点则搜索右结点的子节点</p>
<p>得代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += root-&gt;left ? (isLeaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left)) : <span class="number">0</span>;</span><br><span class="line">    ans += (root-&gt;right!=<span class="literal">NULL</span>&amp;&amp;!isLeaf(root-&gt;right)) ? dfs(root-&gt;right) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? dfs(root) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用三目运算符的一行流</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root ? (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right ? root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right) : sumOfLeftLeaves(root-&gt;left)+sumOfLeftLeaves(root-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/09/19/aIl9nXHm8vPQ6ZL.png" alt="image.png"></p>
<h5 id="解法二：广度优先搜索（BFS）-队列"><a href="#解法二：广度优先搜索（BFS）-队列" class="headerlink" title="解法二：广度优先搜索（BFS）+ 队列"></a>解法二：广度优先搜索（BFS）+ 队列</h5><p>这个解法是从官方的题解上看来的</p>
<p>使用队列数据结构来实现广度优先搜索</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeafNode</span><span class="params">(struct TreeNode *node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> **<span class="title">q</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span> *) * 1001);</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    q[right++] = root;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">node</span> = <span class="title">q</span>[<span class="title">left</span>++];</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeafNode(node-&gt;left)) </span><br><span class="line">            &#123;</span><br><span class="line">                ans += node-&gt;left-&gt;val;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isLeafNode(node-&gt;right)) </span><br><span class="line">            &#123;</span><br><span class="line">                q[right++] = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这么做有一个缺点就是需要提前开辟较大的空间</p>
<p><img src="https://i.loli.net/2020/09/19/MSdXJub9jvfs6Ge.png" alt="image.png"></p>
<h3 id="20-78-子集（中等）"><a href="#20-78-子集（中等）" class="headerlink" title="20 - 78. 子集（中等）"></a>20 - <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集（中等）</a></h3><blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<blockquote>
<p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>本题要求我们返回一个数组中的所有元素所组成的集合的所有子集（包括空集）</p>
<h4 id="解法：迭代法遍历数组"><a href="#解法：迭代法遍历数组" class="headerlink" title="解法：迭代法遍历数组"></a>解法：迭代法遍历数组</h4><p>考虑到二进制数的特殊性质（000→001→010→011→100→101→110→111），我们使用二进制数的每一位来表示是否选取数组中的该位数可以很方便地遍历完所有选取的情况</p>
<p>如下图所示</p>
<p><img src="https://i.loli.net/2020/09/21/46tKB3T1NSufJcR.png" alt="image.png"></p>
<p>同时由二项式定理可知一共有<strong>2^n</strong>种情况（x=1）</p>
<p><img src="https://i.loli.net/2020/09/21/WjVik4QFfobyUmM.png" alt="image.png"></p>
<p>故构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">subsets</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amount = (<span class="number">1</span> &lt;&lt; numsSize);</span><br><span class="line">    <span class="keyword">int</span> **retn = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*amount);</span><br><span class="line">    *returnSize = amount;</span><br><span class="line">    *returnColumnSizes = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*amount);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">set</span>[numsSize];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;amount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>[n++] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> *temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">        <span class="built_in">memcpy</span>(temp,<span class="built_in">set</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;<span class="comment">//踩坑点</span></span><br><span class="line">        retn[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是二级指针的概念和使用方法</p>
<p><del>以及我想不通为什么returnColumnSizes要用二级指针</del></p>
<p><img src="https://i.loli.net/2020/09/21/pKmsDOZvUP9BgHT.png" alt="image.png"></p>
<h3 id="21-538-把二叉搜索树转换为累加树（简单）"><a href="#21-538-把二叉搜索树转换为累加树（简单）" class="headerlink" title="21 - 538. 把二叉搜索树转换为累加树（简单）"></a>21 - <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树（简单）</a></h3><blockquote>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<p>输入: 原始二叉搜索树:<br>              5<br>            /   <br>           2     13</p>
<p>输出: 转换为累加树:<br>             18<br>            /   <br>          20     13</p>
<p>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/convert-bst-to-greater-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><strong>二叉搜索树</strong>有一个特点就是<strong>结点左子树的结点都比该结点小，右子树的结点都比该结点大</strong>，因而叫二叉搜索树，可以用以大幅缩短搜索的时间</p>
<h4 id="解法：深度优先搜索-反序中序遍历"><a href="#解法：深度优先搜索-反序中序遍历" class="headerlink" title="解法：深度优先搜索 + 反序中序遍历"></a>解法：深度优先搜索 + 反序中序遍历</h4><p>由于二叉查找树的这个特性，我们考虑<strong>递归实现的深度优先搜索</strong>算法，通过<strong>反序中序遍历</strong>来实现，过程如下：</p>
<ul>
<li><strong>遍历右子树，将右子树结点值加到summary</strong></li>
<li><strong>将当前结点值加到summary</strong></li>
<li><strong>将当前结点值置为summary</strong></li>
<li><strong>遍历左子树</strong></li>
</ul>
<p>每个结点需要一个额外的栈空间，因而空间复杂度为<strong>O</strong>(<strong>N</strong>)；需要遍历每个结点一次，因而时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;right,sum);</span><br><span class="line">    *sum+=root-&gt;val;</span><br><span class="line">    root-&gt;val=*sum;</span><br><span class="line">    dfs(root-&gt;left,sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">convertBST</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    dfs(root, &amp;sum);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/21/hJQADZUcMlypLYn.png" alt="image.png"></p>
<h3 id="22-968-监控二叉树（困难）"><a href="#22-968-监控二叉树（困难）" class="headerlink" title="22 - 968. 监控二叉树（困难）"></a>22 - <a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">968. 监控二叉树（困难）</a></h3><blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="image.png"></p>
<p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="image.png"></p>
<p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p>
<p>提示：</p>
<p>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-cameras" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-cameras</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><del>又是hard，真有你的啊leetcode</del></p>
<p>仔细想想，对于一个结点是否需要安装摄像头，其实是<strong>由其子树的状态来决定的</strong>，那么我们可以使用<strong>动态规划算法</strong></p>
<h4 id="解法：递归-深度优先搜索（DFS）-动态规划（DP）"><a href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）"></a>解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</h4><p>大概如下图所示：<br><img src="https://i.loli.net/2020/09/22/5v4sz9fdl2OLau7.png" alt="image.png"></p>
<p>我们考虑有以下几种情况：</p>
<ul>
<li><strong>当一个结点的左或右子树没有被摄像头覆盖上时，这个结点必须要安装一个摄像头来监测其左或右子树，定义为状态码STATUS_CAMERA</strong></li>
<li><strong>当一个结点的左右子树都已经被摄像头覆盖上时，为了实现摄像头数量的最小化，需要在该结点的父结点放置摄像头，即在回到父结点前该结点都是未被覆盖的，定义为状态码STATUS_UNCOVERED</strong></li>
<li><strong>当一个结点的左右子树中存在摄像头，则该结点肯定是被覆盖了的，定义为状态码STATUS_COVERED</strong></li>
<li><strong>对于结点为NULL的情况，我们可以默认他是被覆盖了的结点，即定义为状态码STATUS_COVERED</strong></li>
</ul>
<p>同时，<strong>我们还需要对这棵树的根节点做一次单独的检测，以确定是否要在其上放置摄像头</strong></p>
<p>为了方便判定，我们将STATUS_CAMERA设置为状态码中值相对大的一个</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p><strong>STATUS_ROOT = F(STATUS_LEFT, STATUS_RIGHT)</strong></p>
<h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>n次遍历，线性时间复杂度<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>递归算法要开辟n个栈空间，故为线性空间复杂度<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<h4 id="C语言版"><a href="#C语言版" class="headerlink" title="C语言版"></a>C语言版</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * status code</span></span><br><span class="line"><span class="comment"> * 0: waiting for pwn</span></span><br><span class="line"><span class="comment"> * 1: has been pwn</span></span><br><span class="line"><span class="comment"> * 2: camara here</span></span><br><span class="line"><span class="comment"> *-1: inner error, just a placeholder in fact</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNCOVERED 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_COVERED 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_CAMERA 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_ERROR -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(struct TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amounts=<span class="number">0</span>;<span class="comment">//amounts of camera</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//add a camera to the root if status of root is 0</span></span><br><span class="line">    <span class="keyword">if</span>(dfs(root,&amp;amounts) == STATUS_UNCOVERED)</span><br><span class="line">        amounts++;</span><br><span class="line">    <span class="keyword">return</span> amounts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> * amounts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//NULL pointer signed as status 1</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the status of left and right node</span></span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left, amounts);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right, amounts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if one of both uncovered yet, a camera is needed</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_UNCOVERED || right == STATUS_UNCOVERED)</span><br><span class="line">    &#123;</span><br><span class="line">        (*amounts)++;</span><br><span class="line">        <span class="keyword">return</span> STATUS_CAMERA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if both are covered, father's of root may need a camera</span></span><br><span class="line">    <span class="keyword">if</span>(left == STATUS_COVERED &amp;&amp; right == STATUS_COVERED)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNCOVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if there's at least one camera in both childs, the root is covered</span></span><br><span class="line">    <span class="keyword">if</span>(left + right &gt; STATUS_CAMERA)</span><br><span class="line">        <span class="keyword">return</span> STATUS_COVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//error code(not used)</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/64ytrK3gLNGowbf.png" alt="EE8895_CCLKZDA_OPW4_FT1.png"></p>
<h4 id="Python语言版："><a href="#Python语言版：" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  status</span></span><br><span class="line"><span class="comment">#  0 - waiting for pwn</span></span><br><span class="line"><span class="comment">#  1 - has been pwn</span></span><br><span class="line"><span class="comment">#  2 - camera here</span></span><br><span class="line"><span class="comment"># -1 - error, just a placeholder</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    amounts = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left = self.dfs(root.left)</span><br><span class="line">        right = self.dfs(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">1</span> <span class="keyword">and</span> right == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> right == <span class="number">0</span>:</span><br><span class="line">            self.amounts += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> left + right &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(root) == <span class="number">0</span>:</span><br><span class="line">            self.amounts += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.amounts</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/22/2tbv6R7LizECw3e.png" alt="image.png"></p>
<h3 id="23-617-合并二叉树（简单）"><a href="#23-617-合并二叉树（简单）" class="headerlink" title="23 - 617. 合并二叉树（简单）"></a>23 - <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树（简单）</a></h3><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>    Tree 1                     Tree 2<br>          1                         2<br>         / \                       / \<br>        3   2                     1   3<br>       /                             \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>         3<br>        / \<br>       4   5<br>      / \   \<br>     5   4   7<br>注意: 合并必须从两个树的根节点开始。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>很简单的一道题，<del>3分钟不到就做出来了，今晚可以做个好梦了</del>（<del>确信</del></p>
<h4 id="解法：递归-深度优先搜索（DFS）"><a href="#解法：递归-深度优先搜索（DFS）" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h4><p>逐层递归，合并到t1上：</p>
<ul>
<li><strong>t1、t2若为空则直接返回其中非空的那一个</strong></li>
<li><strong>将t2的val加到t1的val上</strong></li>
<li><strong>合并t1左与t2左</strong></li>
<li><strong>合并t1右与t2右</strong></li>
</ul>
<p>得到代码如下：</p>
<h4 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>搜索的次数和结点数量线性增长，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-1"><a href="#空间复杂度：-1" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>需要的栈空间数量和结点数量线性增长，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="C语言版："><a href="#C语言版：" class="headerlink" title="C语言版："></a>C语言版：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">mergeTrees</span><span class="params">(struct TreeNode* t1, struct TreeNode* t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t1)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(!t2)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    t1-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">    t1-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/23/wXgivj.png" alt="wXgivj.png"></p>
<h4 id="Python语言版：-1"><a href="#Python语言版：-1" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1: TreeNode, t2: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> t1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        t1.val += t2.val</span><br><span class="line">        t1.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        t1.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> t1</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/23/wXgJVx.png" alt="wXgJVx.png"></p>
<h3 id="24-501-二叉搜索树中的众数（简单）"><a href="#24-501-二叉搜索树中的众数（简单）" class="headerlink" title="24 - 501. 二叉搜索树中的众数（简单）"></a>24 - <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数（简单）</a></h3><blockquote>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树<br>例如：<br>给定 BST [1,null,2,2],</p>
<p>   1<br>    \<br>     2<br>    /<br>   2<br>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-mode-in-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法：递归-深度优先搜索（DFS）-1"><a href="#解法：递归-深度优先搜索（DFS）-1" class="headerlink" title="解法：递归 + 深度优先搜索（DFS）"></a>解法：递归 + 深度优先搜索（DFS）</h4><p>考虑到二叉搜索树中<strong>左子树所有结点的值小于当前结点值小于右子树所有结点的值</strong>，故还是采取<strong>深度优先搜索算法</strong></p>
<p>递归中序遍历，由于二叉搜索树的特殊性质，我们遍历的顺序一定是<strong>排序好的</strong></p>
<p>故构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>;<span class="comment">//数量最多的数的数量</span></span><br><span class="line"><span class="keyword">int</span> num;<span class="comment">//前一结点的连续结点个数</span></span><br><span class="line"><span class="keyword">int</span> pre;<span class="comment">//前一结点的值</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//返回的数组的大小</span></span><br><span class="line"><span class="keyword">int</span> *retn;<span class="comment">//返回的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">findMode</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2150</span>);</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> retn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode * root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == pre)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//新序列</span></span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="built_in">max</span>)<span class="comment">//相同结点数量比max还多，则进行重置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">        <span class="built_in">max</span> = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="built_in">max</span>)<span class="comment">//否则，放入数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        retn[<span class="built_in">size</span>++] = root-&gt;val;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = root-&gt;val;<span class="comment">//储存该结点值，继续遍历下一结点</span></span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/24/wxTxSA.png" alt="wxTxSA.png"></p>
<h3 id="25-106-从中序与后序遍历序列构造二叉树（中等）"><a href="#25-106-从中序与后序遍历序列构造二叉树（中等）" class="headerlink" title="25 - 106. 从中序与后序遍历序列构造二叉树（中等）"></a>25 - <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树（中等）</a></h3><blockquote>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>  3

 / \\
9  20
  /  \\
 15   7</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><del>一上来就把我给看懵了，真有你的啊leetcode</del></p>
<h4 id="解法：递归"><a href="#解法：递归" class="headerlink" title="解法：递归"></a>解法：递归</h4><p>这道题主要的突破点是<strong>后序遍历所得的数组</strong></p>
<p>中序遍历的顺序是：<strong>根-&gt;左-&gt;右</strong></p>
<p>后序遍历的顺序是：<strong>左-&gt;右-&gt;根</strong></p>
<p>也就是说，<strong>后序遍历的最后一个结点必定是这一棵树的根结点，而中序遍历所得的结果中根结点的左边所有结点必定属于左子树，右边所有结点必定属于右子树</strong></p>
<p><strong>在后序列表中，前left个值为左子树，left+1到left+right为右子树；</strong><br><strong>在中序列表中，根结点前为左子树，根结点后为右子树；</strong> </p>
<p>依照这个性质，我们便可以<strong>按照中序遍历的顺序重构这一棵树</strong></p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>* inorder, <span class="keyword">int</span> inorderSize, <span class="keyword">int</span>* postorder, <span class="keyword">int</span> postorderSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inorderSize || !postorderSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> = (<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">    <span class="keyword">int</span> root = postorder[postorderSize<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    node-&gt;val = root;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">for</span>(left = <span class="number">0</span>;left&lt;inorderSize;left++)</span><br><span class="line">        <span class="keyword">if</span>(inorder[left] == root)</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> right = inorderSize - left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    node-&gt;left = buildTree(inorder, left, postorder, left);</span><br><span class="line">    node-&gt;right = buildTree(inorder + left + <span class="number">1</span>, right, postorder + left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/25/sYMeb6NL3aSJxdC.png" alt="R8JMRM38V_UU7NZ_F0_6WO6.png"></p>
<h3 id="26-113-路径总和-II（中等）"><a href="#26-113-路径总和-II（中等）" class="headerlink" title="26 - 113. 路径总和 II（中等）"></a>26 - <a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II（中等）</a></h3><blockquote>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>      5
     / \\
    4   8
   /   / \\
  11  13  4
 /  \\    / \\
7    2  5   1</code></pre><p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/path-sum-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法：深度优先搜索（DFS）-递归中序遍历"><a href="#解法：深度优先搜索（DFS）-递归中序遍历" class="headerlink" title="解法：深度优先搜索（DFS）+ 递归中序遍历"></a>解法：深度优先搜索（DFS）+ 递归中序遍历</h4><p>中序遍历，一层一层地搜下去就完事了，用一个栈来保存路径，遇到叶子结点且刚好到了这一层时sum已经被减到0了就保存路径</p>
<p>需要注意的是<strong>在每一层搜索结束后都要将该层结点弹出栈</strong></p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> **retn;</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> nums;</span><br><span class="line"><span class="keyword">int</span> retn_nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    <span class="built_in">set</span>[nums++] = root-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> * path = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        <span class="built_in">memcpy</span>(path, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * nums);</span><br><span class="line">        (*returnColumnSizes)[retn_nums] = nums;</span><br><span class="line">        retn[retn_nums++] = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root-&gt;left,sum,returnColumnSizes);</span><br><span class="line">    dfs(root-&gt;right,sum,returnColumnSizes);</span><br><span class="line">    nums--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">pathSum</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    retn_nums = nums = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span> = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    retn = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="number">1000</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        (*returnColumnSizes)[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,sum,returnColumnSizes);</span><br><span class="line">    *returnSize = retn_nums;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/26/oqx2CRyb9JMavBZ.png" alt="image.png"></p>
<h3 id="27-235-二叉搜索树的最近公共祖先（简单）"><a href="#27-235-二叉搜索树的最近公共祖先（简单）" class="headerlink" title="27 - 235. 二叉搜索树的最近公共祖先（简单）"></a>27 - <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先（简单）</a></h3><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法：深度优先搜索（DFS）"><a href="#解法：深度优先搜索（DFS）" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>二叉搜索树（BST）有一个很重要的性质就是<strong>左子树所有结点都小于当前节点，右子树所有结点都大于当前结点</strong>，所以我们可以直接通过比较结点的值来进行判断</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == q)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag1 = p-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">bool</span> flag2 = q-&gt;val &gt; root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(flag1 != flag2)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p == root || q == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag1)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/27/1sudkorBnCPqV5l.png" alt="@_I_39NAGH0__CROGOJD4XX.png"></p>
<blockquote>
<p>早睡早起身体好（确信</p>
</blockquote>
<h3 id="28-117-填充每个节点的下一个右侧节点指针-II（中等）"><a href="#28-117-填充每个节点的下一个右侧节点指针-II（中等）" class="headerlink" title="28 - 117. 填充每个节点的下一个右侧节点指针 II（中等）"></a>28 - <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II（中等）</a></h3><blockquote>
<p>给定一个二叉树</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="image.png"></p>
<p>输入：root = [1,2,3,4,5,null,7]<br>输出：[1,#,2,3,#,4,5,7,#]<br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p>提示：</p>
<p>树中的节点数小于 6000<br>-100 &lt;= node.val &lt;= 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法一：层次遍历"><a href="#解法一：层次遍历" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h4><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p>
<p>大致过程如下图</p>
<p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p>
<h4 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-2"><a href="#空间复杂度：-2" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<h4 id="C语言版：-1"><a href="#C语言版：-1" class="headerlink" title="C语言版："></a>C语言版：</h4><p>我么可以得到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a Node.</span><br><span class="line"> * struct Node &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct Node *left;</span><br><span class="line"> *     struct Node *right;</span><br><span class="line"> *     struct Node *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">struct Node * last_node, *next_start;</span><br><span class="line"></span><br><span class="line">void connectList(struct Node * node)</span><br><span class="line">&#123;</span><br><span class="line">    if(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Node *connect(struct Node *root) </span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    struct Node *start &#x3D; root;</span><br><span class="line">    while(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node &#x3D; NULL, next_start &#x3D; NULL;</span><br><span class="line">        while(start)</span><br><span class="line">        &#123;</span><br><span class="line">            if(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            if(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start &#x3D; start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start &#x3D; next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/28/tmKaLsnblvDce9H.png" alt="_XU940OX_R1_5XJK_H@N~5I.png"></p>
<h4 id="Python语言版：-2"><a href="#Python语言版：-2" class="headerlink" title="Python语言版："></a>Python语言版：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.last_node: <span class="string">'Node'</span></span><br><span class="line">        self.next_start: <span class="string">'Node'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        start = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">            self.last_node = <span class="literal">None</span></span><br><span class="line">            self.next_start = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> start != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> start.left != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.left</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.left</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.left</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> start.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">                        self.last_node.next = start.right</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">                        self.next_start = start.right</span><br><span class="line"></span><br><span class="line">                    self.last_node = start.right</span><br><span class="line"></span><br><span class="line">                start = start.next</span><br><span class="line"></span><br><span class="line">            start = self.next_start</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectList</span><span class="params">(self, node: <span class="string">'Node'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.last_node != <span class="literal">None</span>:</span><br><span class="line">            self.last_node.next = node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.next_start == <span class="literal">None</span>:</span><br><span class="line">            self.next_start = node</span><br><span class="line"></span><br><span class="line">        self.last_node = node</span><br></pre></td></tr></table></figure>



<p>![XTJUK27UN3_66_OSL5`_BZB.png](<a href="https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/28/ywXFL85CP4Zm2B6.png</a>)</p>
<h3 id="29-145-二叉树的后序遍历（中等）"><a href="#29-145-二叉树的后序遍历（中等）" class="headerlink" title="29 - 145. 二叉树的后序遍历（中等）"></a>29 - <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历（中等）</a></h3><blockquote>
<p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<p>输入: [1,null,2,3]<br>   1<br>    <br>     2<br>    /<br>   3 </p>
<p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法一：深度优先搜索（DFS）-递归后续遍历"><a href="#解法一：深度优先搜索（DFS）-递归后续遍历" class="headerlink" title="解法一：深度优先搜索（DFS） + 递归后续遍历"></a>解法一：深度优先搜索（DFS） + 递归后续遍历</h4><p>后序遍历的顺序是<strong>左→右→根</strong>，使用递归可以三分钟内解决</p>
<h4 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-3"><a href="#空间复杂度：-3" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> * retn;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    retn[<span class="built_in">size</span>++] = root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">postorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        *returnSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root);</span><br><span class="line">    *returnSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/09/29/Smo2vrKwWfjH1Ta.png" alt="_B35__WY2L_Z`E_`27DA_FM.png"></p>
<h3 id="30-701-二叉搜索树中的插入操作（中等）"><a href="#30-701-二叉搜索树中的插入操作（中等）" class="headerlink" title="30 - 701. 二叉搜索树中的插入操作（中等）"></a>30 - <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作（中等）</a></h3><blockquote>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p>例如, </p>
<p>给定二叉搜索树:</p>
<pre><code>    4
   / \
  2   7
 / \
1   3</code></pre><p>和 插入的值: 5<br>你可以返回这个二叉搜索树:</p>
<pre><code>     4
   /   \
  2     7
 / \   /
1   3 5</code></pre><p>或者这个树也是有效的:</p>
<pre><code>     5
   /   \
  2     7
 / \   
1   3
     \
      4</code></pre><p>提示：</p>
<p>给定的树上的节点数介于 0 和 10^4 之间<br>每个节点都有一个唯一整数值，取值范围从 0 到 10^8<br>-10^8 &lt;= val &lt;= 10^8<br>新值和原始二叉搜索树中的任意节点值都不同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法：深度优先搜索（DFS）-1"><a href="#解法：深度优先搜索（DFS）-1" class="headerlink" title="解法：深度优先搜索（DFS）"></a>解法：深度优先搜索（DFS）</h4><p>深度优先搜索遍历这棵树， <strong>插入值大于结点值则往右子树插，否则往左子树插</strong></p>
<p><strong>递归</strong>可以很方便地解决这个问题</p>
<h4 id="时间复杂度：-4"><a href="#时间复杂度：-4" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>每个结点都有可能过一遍，所以时间复杂度是<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-4"><a href="#空间复杂度：-4" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>每个结点都要开辟一个单独的栈帧空间，故空间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(val &gt; root-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;right-&gt;val = val;</span><br><span class="line">            root-&gt;right-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;right-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">            root-&gt;left-&gt;val = val;</span><br><span class="line">            root-&gt;left-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            root-&gt;left-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">insertIntoBST</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = (struct TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;val = val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![Z08G_KN_4GTD1`J_3NC0__F.png](<a href="https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png" target="_blank" rel="noopener">https://i.loli.net/2020/09/30/EUIqglNFiRvJCoz.png</a>)</p>
<blockquote>
<p>又是能够早睡的一个晚上（确信</p>
<p>九月结束🌶</p>
</blockquote>
<h2 id="October"><a href="#October" class="headerlink" title="October"></a>October</h2><h3 id="1-LCP-19-秋叶收藏集（中等）"><a href="#1-LCP-19-秋叶收藏集（中等）" class="headerlink" title="1 - LCP 19. 秋叶收藏集（中等）"></a>1 - <a href="https://leetcode-cn.com/problems/UlBDOe/" target="_blank" rel="noopener">LCP 19. 秋叶收藏集（中等）</a></h3><blockquote>
<p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。<br>出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p>
<p>示例 1：</p>
<p>输入：leaves = “rrryyyrryyyrr”</p>
<p>输出：2</p>
<p>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p>
<p>示例 2：</p>
<p>输入：leaves = “ryr”</p>
<p>输出：0</p>
<p>解释：已符合要求，不需要额外操作</p>
<p>提示：</p>
<p>3 &lt;= leaves.length &lt;= 10^5<br>leaves 中只包含字符 ‘r’ 和字符 ‘y’</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/UlBDOe" target="_blank" rel="noopener">https://leetcode-cn.com/problems/UlBDOe</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>最近忙着自闭（x）</p>
<p>解法动态规划，题解有时间再回来写（咕咕咕</p>
<p><img src="https://i.loli.net/2020/10/02/HrSx812GPa97JtT.png" alt="image.png"></p>
<h3 id="2-771-宝石与石头（简单）"><a href="#2-771-宝石与石头（简单）" class="headerlink" title="2 - 771. 宝石与石头（简单）"></a>2 - <a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">771. 宝石与石头（简单）</a></h3><blockquote>
<p> 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<p>示例 1:</p>
<p>输入: J = “aA”, S = “aAAbbbb”<br>输出: 3<br>示例 2:</p>
<p>输入: J = “z”, S = “ZZ”<br>输出: 0<br>注意:</p>
<p>S 和 J 最多含有50个字母。<br> J 中的字符不重复。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jewels-and-stones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>用一个数组来保存有的宝石再遍历石头即可</p>
<p>因为是字符型，方便起见可以直接用一个128大小的数组来储存信息</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="keyword">char</span> * J, <span class="keyword">char</span> * S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*J)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(<span class="built_in">map</span>[*J]))</span><br><span class="line">            <span class="built_in">map</span>[*J] = <span class="number">1</span>;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(*S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">map</span>[*S]))</span><br><span class="line">            num++;</span><br><span class="line">        S++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![KE97BAWWD__F`_X6X__``79.png](<a href="https://i.loli.net/2020/10/03/fGq8SYicjhrBIeN.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/03/fGq8SYicjhrBIeN.png</a>)</p>
<h3 id="3-1-两数之和（简单）"><a href="#3-1-两数之和（简单）" class="headerlink" title="3 - 1. 两数之和（简单）"></a>3 - <a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和（简单）</a></h3><blockquote>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p><del>不忘初心牢记使命</del></p>
<p>是Leetcode的第一题呢</p>
<p><strong>暴力枚举</strong>即可</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * retn = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                retn[<span class="number">0</span>] = i;</span><br><span class="line">                retn[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">return</span> retn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>![R`X_RZK1I6_HG7_PV81~RNB.png](<a href="https://i.loli.net/2020/10/03/f8VGlqdrtjUIRsO.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/03/f8VGlqdrtjUIRsO.png</a>)</p>
<h3 id="4-2-两数相加（中等）"><a href="#4-2-两数相加（中等）" class="headerlink" title="4 - 2. 两数相加（中等）"></a>4 - <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加（中等）</a></h3><blockquote>
<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>呐，梦开始的地方呢。</p>
<h4 id="解法：模拟法"><a href="#解法：模拟法" class="headerlink" title="解法：模拟法"></a>解法：模拟法</h4><p>模拟常规的加法过程即可</p>
<p>需要注意的是原结点的空间是可被复用的</p>
<h4 id="时间复杂度：-5"><a href="#时间复杂度：-5" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>需要遍历max(m,n)个结点（其中m为l1长度，n为l2长度），故时间复杂度为<strong>O</strong>(<strong>MAX</strong>(<strong>M,N</strong>))</p>
<h4 id="空间复杂度：-5"><a href="#空间复杂度：-5" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>只需要临时变量的常数空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!l1)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(!l2)</span><br><span class="line">        <span class="keyword">return</span> l1; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">tail</span>, *<span class="title">retn</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> plus = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l1-&gt;val += l2-&gt;val + plus;</span><br><span class="line">        plus = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        l1-&gt;val += plus;</span><br><span class="line">        plus = l1-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l1-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)</span><br><span class="line">        tail-&gt;next = l2;</span><br><span class="line">    <span class="keyword">while</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;val += plus;</span><br><span class="line">        plus = l2-&gt;val / <span class="number">10</span>;</span><br><span class="line">        l2-&gt;val %= <span class="number">10</span>;</span><br><span class="line">        tail = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(plus)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next = (struct ListNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        tail-&gt;next-&gt;val = plus;</span><br><span class="line">        tail-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/04/uSQzNqR4AcZYTtX.png" alt="image.png"></p>
<h3 id="5-18-四数之和（中等）"><a href="#5-18-四数之和（中等）" class="headerlink" title="5 - 18. 四数之和（中等）"></a>5 - <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和（中等）</a></h3><blockquote>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/4sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/4sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>双指针哈希，留周末再写解法了</p>
<h3 id="6-834-树中距离之和（困难）"><a href="#6-834-树中距离之和（困难）" class="headerlink" title="6 - 834. 树中距离之和（困难）"></a>6 - <a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/" target="_blank" rel="noopener">834. 树中距离之和（困难）</a></h3><blockquote>
<p>给定一个无向、连通的树。树中有 N 个标记为 0…N-1 的节点以及 N-1 条边 。</p>
<p>第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。</p>
<p>返回一个表示节点 i 与其他所有节点距离之和的列表 ans。</p>
<p>示例 1:</p>
<p>输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]<br>输出: [8,12,6,10,10,10]<br>解释:<br>如下为给定的树的示意图：<br>  0<br> / <br>1   2<br>   /|<br>  3 4 5</p>
<p>我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)<br>也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。<br>说明: 1 &lt;= N &lt;= 10000</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-distances-in-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>动态规划，周末写解法，最近忙的很</p>
<h3 id="7-75-颜色分类（中等）"><a href="#7-75-颜色分类（中等）" class="headerlink" title="7 - 75. 颜色分类（中等）"></a>7 - <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类（中等）</a></h3><blockquote>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p>示例:</p>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]<br>进阶：</p>
<p>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sort-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-colors</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>因为只需要排序三种颜色，故考虑将数组分成三块，两趟遍历，第一趟把所有的0放在前面，第二趟把所有的1放在中间即可，在交换的过程中2自然会全部堆到末尾</p>
<h4 id="时间复杂度：-6"><a href="#时间复杂度：-6" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>最坏情况下两趟完整遍历，最好情况下遍历一趟，时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-6"><a href="#空间复杂度：-6" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>只需要常数级别的额外空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numsSize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/07/MEFrixChODK4c1n.png" alt="IF_F__@A8_F7PD_X_RFR8AA.png"></p>
<h3 id="8-344-反转字符串（简单）"><a href="#8-344-反转字符串（简单）" class="headerlink" title="8 - 344. 反转字符串（简单）"></a>8 - <a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串（简单）</a></h3><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p>示例 1：</p>
<p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>原地交换即可</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> sSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">int</span> len = sSize/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=s[i];</span><br><span class="line">        s[i]=s[sSize-i<span class="number">-1</span>];</span><br><span class="line">        s[sSize-i<span class="number">-1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/08/EzXUN93shxaOjVn.png" alt="image.png"></p>
<h3 id="9-141-环形链表（简单）"><a href="#9-141-环形链表（简单）" class="headerlink" title="9 - 141. 环形链表（简单）"></a>9 - <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表（简单）</a></h3><blockquote>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="image.png"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="image.png"></p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="image.png"></p>
<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;= Node.val &lt;= 105<br>pos 为 -1 或者链表中的一个 有效索引 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法一：快慢指针"><a href="#解法一：快慢指针" class="headerlink" title="解法一：快慢指针"></a>解法一：快慢指针</h4><p>老快慢指针人了，<strong>只要链表中存在环那么在遍历过程中步长不一的快慢指针肯定会相遇</strong></p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr1</span> = <span class="title">head</span>, *<span class="title">ptr2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(ptr1 &amp;&amp; ptr2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ptr1 == ptr2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ptr1 = ptr1-&gt;next;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!ptr2)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ptr2 = ptr2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/09/PtGJv5EIz3RgAWd.png" alt="image.png"></p>
<h4 id="解法二：利用题目数据范围漏洞"><a href="#解法二：利用题目数据范围漏洞" class="headerlink" title="解法二：利用题目数据范围漏洞"></a>解法二：利用题目数据范围漏洞</h4><p>题目保证结点数量小于10000，那么<strong>只要遍历能循环超过10000次，链表中就必定存在回路</strong></p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">10000</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/09/23/wXfJ6e.png" alt="wXfJ6e.png"></p>
<h3 id="10-142-环形链表-II（中等）"><a href="#10-142-环形链表-II（中等）" class="headerlink" title="10 - 142. 环形链表 II（中等）"></a>10 - <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II（中等）</a></h3><blockquote>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。</p>
<p>示例 1：</p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="image.png"></p>
<p>示例 2：</p>
<p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="image.png"></p>
<p>示例 3：</p>
<p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="image.png"></p>
<p>进阶：<br>你是否可以不用额外空间解决此题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h4><p>用一个表收集已经遍历过的结点，每遍历过一个结点看这个结点是否在表内即可</p>
<p>当然，每次都要在表内寻找结点，时间复杂度最坏是<strong>O</strong>(<strong>N^2</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">map</span>[10000];</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;index;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="built_in">map</span>[i])</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>[index++] = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时间十分惨不忍睹</p>
</blockquote>
<p><img src="https://i.loli.net/2020/10/10/9kICpfDBudOlQUF.png" alt="image.png"></p>
<h4 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h4><p>我们可以用步长分别为1、2的两个指针遍历该链表，思考如下事实：</p>
<p><img src="https://i.loli.net/2020/10/10/Mo8YQgWPSTHKRwD.png" alt="BFACBC2D2E0D388B926508F2A850E287.png"></p>
<p>当快慢指针相遇后，<strong>慢指针从环的起始点走了距离b</strong>，若是从该时刻开始有一个指针从链表头与慢指针同步长遍历，当两指针相遇时，两个指针分别都走了距离a，<strong>此时慢指针总共从环的起始点走了a+b = n*b + n*c 的距离，刚好回到起始点</strong>，这样我们就找到环的起始点了</p>
<p>构造代码如下：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">slow_ptr</span> = <span class="title">head</span>, *<span class="title">fast_ptr</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(slow_ptr &amp;&amp; fast_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        slow_ptr = slow_ptr-&gt;next;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!fast_ptr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        fast_ptr = fast_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow_ptr == fast_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            slow_ptr = slow_ptr-&gt;next;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">ptr</span> = <span class="title">head</span>;</span></span><br><span class="line">            <span class="keyword">while</span>(ptr != slow_ptr)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">                slow_ptr = slow_ptr-&gt;next;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/10/YJ9p1S3ryl6jkuM.png" alt="_3E__5BJH58~HSP__SZ_ZD5.png"></p>
<h3 id="11-416-分割等和子集（中等）"><a href="#11-416-分割等和子集（中等）" class="headerlink" title="11 - 416. 分割等和子集（中等）"></a>11 - <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集（中等）</a></h3><blockquote>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br>示例 1:</p>
<p>输入: [1, 5, 11, 5]</p>
<p>输出: true</p>
<p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<p>示例 2:</p>
<p>输入: [1, 2, 3, 5]</p>
<p>输出: false</p>
<p>解释: 数组不能分割成两个元素和相等的子集.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>DP，01背包变种，题解先咕咕咕（</p>
<h3 id="12-530-二叉搜索树的最小绝对差（简单）"><a href="#12-530-二叉搜索树的最小绝对差（简单）" class="headerlink" title="12 - 530. 二叉搜索树的最小绝对差（简单）"></a>12 - <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差（简单）</a></h3><blockquote>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p>输入：</p>
<p>   1<br>    <br>     3<br>    /<br>   2</p>
<p>输出：<br>1</p>
<p>解释：<br>最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</p>
<p>提示：</p>
<p>树中至少有 2 个节点。<br>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="解法：深度优先搜索-中序遍历"><a href="#解法：深度优先搜索-中序遍历" class="headerlink" title="解法：深度优先搜索 + 中序遍历"></a>解法：深度优先搜索 + 中序遍历</h4><p>因为是二叉搜索树，所以当进行中序遍历时肯定会按照从小到大的结点进行遍历</p>
<p>最小绝对差肯定出现在相邻值结点中，这里就不再过多赘叙了</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0xffff</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">-1</span>)</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = (root-&gt;val - pre) &lt; ans ? (root-&gt;val - pre) : ans;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre = <span class="number">-1</span>;</span><br><span class="line">    ans = <span class="number">0xffff</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2020/10/12/EUzkxuqK2ja4cFl.png" alt="image.png"></p>
<h3 id="13-24-两两交换链表中的节点（中等）"><a href="#13-24-两两交换链表中的节点（中等）" class="headerlink" title="13 - 24.两两交换链表中的节点（中等）"></a>13 - <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24.两两交换链表中的节点（中等）</a></h3><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>很简单的一个交换结点的题，两两交换即可</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">temp</span>, *<span class="title">temp2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>-&gt;<span class="title">next</span>, *<span class="title">temp3</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">retn</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    temp3-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        temp2 = head-&gt;next-&gt;next;</span><br><span class="line">        temp = head-&gt;next;</span><br><span class="line">        temp3-&gt;next = temp;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head-&gt;next = temp2;</span><br><span class="line">        temp3 = head;</span><br><span class="line">        head = temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2020/10/14/WenKdZaqkslmrFg.png" alt="image.png" style="zoom:50%;" />

<h3 id="14-1002-查找常用字符（简单）"><a href="#14-1002-查找常用字符（简单）" class="headerlink" title="14 - 1002. 查找常用字符（简单）"></a>14 - <a href="https://leetcode-cn.com/problems/find-common-characters/" target="_blank" rel="noopener">1002. 查找常用字符（简单）</a></h3><blockquote>
<p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]<br>示例 2：</p>
<p>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]</p>
<p>提示：</p>
<p>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 100<br>A[i][j] 是小写字母</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-common-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-common-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>直接一个个数即可</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> ** <span class="title">commonChars</span><span class="params">(<span class="keyword">char</span> ** A, <span class="keyword">int</span> ASize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ** retn = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) * <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> ** count = (<span class="keyword">int</span>**)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*), <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        count[i] = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">30</span>);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ASize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *ptr = A[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;ptr[j];j++)</span><br><span class="line">            count[i][ptr[j]-<span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0xffff</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ASize;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[j][i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">min</span> &gt; count[j][i] ? count[j][i] : <span class="built_in">min</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">min</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                retn[*returnSize] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">2</span>);</span><br><span class="line">                retn[*returnSize][<span class="number">0</span>] = <span class="string">'a'</span> + i;</span><br><span class="line">                retn[(*returnSize)++][<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![7RM_2__VRFRFEI`8__F5YZW.png](<a href="https://i.loli.net/2020/10/14/Hu76mRdEKPnQY1b.png" target="_blank" rel="noopener">https://i.loli.net/2020/10/14/Hu76mRdEKPnQY1b.png</a>)</p>
<h3 id="15-116-填充每个节点的下一个右侧节点指针（中等）"><a href="#15-116-填充每个节点的下一个右侧节点指针（中等）" class="headerlink" title="15 - 116. 填充每个节点的下一个右侧节点指针（中等）"></a>15 - <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针（中等）</a></h3><blockquote>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png" alt="image.png"></p>
<p>输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}</p>
<p>输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}</p>
<p>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</p>
<p>提示：</p>
<p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p>注：本题和2020.9.28的每日一题几乎完全一样</p>
</blockquote>
<h4 id="解法一：层次遍历-1"><a href="#解法一：层次遍历-1" class="headerlink" title="解法一：层次遍历"></a>解法一：层次遍历</h4><p>我们考虑到当我们填充next指针将每一层的结点都连接起来后，<strong>该层所有结点便构成了一个单向链表</strong>，我们可以<strong>通过遍历每一层的链表来构造下一层的链表</strong></p>
<p>大致过程如下图</p>
<p><img src="https://i.loli.net/2020/09/28/485DnfumcRterSM.png" alt="BD12E33FCF6E3B97FC6DB3AF5B645CF2.png"></p>
<h4 id="时间复杂度：-7"><a href="#时间复杂度：-7" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>由于每个结点都要遍历一次，故时间复杂度为<strong>O</strong>(<strong>N</strong>)</p>
<h4 id="空间复杂度：-7"><a href="#空间复杂度：-7" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>由于没有使用到额外的空间，故空间复杂度为<strong>O</strong>(<strong>1</strong>)</p>
<p>构造代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a Node.</span></span><br><span class="line"><span class="comment"> * struct Node &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct Node *left;</span></span><br><span class="line"><span class="comment"> *     struct Node *right;</span></span><br><span class="line"><span class="comment"> *     struct Node *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">last_node</span>, *<span class="title">next_start</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectList</span><span class="params">(struct Node * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(last_node)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!next_start)</span><br><span class="line">    &#123;</span><br><span class="line">        next_start = node;</span><br><span class="line">    &#125;</span><br><span class="line">    last_node = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">connect</span><span class="params">(struct Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">start</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(start)</span><br><span class="line">    &#123;</span><br><span class="line">        last_node = <span class="literal">NULL</span>, next_start = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;left)</span><br><span class="line">                connectList(start-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(start-&gt;right)</span><br><span class="line">                connectList(start-&gt;right);</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        start = next_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/10/15/p3if4WBZnAScgLI.png" alt="image.png"></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    arttnba3
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/" title="【OJ-0x0004-Leetcode】每日一题部分write up by arttnba3">http://arttnba3.cn/2020/09/16/%E3%80%90OJ-0x0004-Leetcode%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E9%83%A8%E5%88%86write-up-by-arttnba3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" <i class="fa fa-tag"></i> 算法</a>
          
            <a href="/tags/C-C/" <i class="fa fa-tag"></i> C/C++</a>
          
            <a href="/tags/%E9%A2%98%E8%A7%A3/" <i class="fa fa-tag"></i> 题解</a>
          
            <a href="/tags/%E9%93%BE%E8%A1%A8/" <i class="fa fa-tag"></i> 链表</a>
          
            <a href="/tags/Leetcode/" <i class="fa fa-tag"></i> Leetcode</a>
          
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" <i class="fa fa-tag"></i> 动态规划</a>
          
            <a href="/tags/%E6%A0%91/" <i class="fa fa-tag"></i> 树</a>
          
            <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" <i class="fa fa-tag"></i> 二叉树</a>
          
            <a href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/" <i class="fa fa-tag"></i> 广度优先搜索（BFS）</a>
          
            <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/" <i class="fa fa-tag"></i> 深度优先搜索（DFS）</a>
          
            <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" <i class="fa fa-tag"></i> 双指针</a>
          
            <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" <i class="fa fa-tag"></i> 哈希表</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/08/%E3%80%90CTF%E9%A2%98%E8%A7%A3-0x04%E3%80%91BUUOJ-Pwn-write-up-by-arttnb3/" rel="next" title="【CTF题解-0x04】BUUCTF-Pwn write up by arttnb3">
                <i class="fa fa-chevron-left"></i> 【CTF题解-0x04】BUUCTF-Pwn write up by arttnb3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/17/%E3%80%90OJ-0x0005-Leetcode%E3%80%91%E6%A0%91%E9%83%A8%E5%88%86write-up-by-arttnba3/" rel="prev" title="【OJ-0x0005-Leetcode】树部分write up by arttnba3">
                【OJ-0x0005-Leetcode】树部分write up by arttnba3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  

  

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="arttnba3" />
            
              <p class="site-author-name" itemprop="name">arttnba3</p>
              <p class="site-description motion-element" itemprop="description">- 想成为你心目中的第一啊 -</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/arttnba3" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1543127579@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://wpa.qq.com/msgrd?v=3&uin=1543127579&site=qq&menu=yes" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/arttnba3" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/13389180/arttnba3" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/arttnba" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends' Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.wootec.top" title="Reverier" target="_blank">Reverier</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://luoq1an.github.io" title="luoqian" target="_blank">luoqian</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ll1ng.github.io" title="ling" target="_blank">ling</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://shal10w.github.io" title="shallow" target="_blank">shallow</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://eqqie.cn" title="eqqie" target="_blank">eqqie</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://cor1e.cn" title="cor1e" target="_blank">cor1e</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yunq1ao.com" title="yunqiao" target="_blank">yunqiao</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mercer5.github.io" title="mercer" target="_blank">mercer</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-绪论"><span class="nav-number">1.</span> <span class="nav-text">0x00.绪论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-2020"><span class="nav-number">2.</span> <span class="nav-text">0x01. 2020</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#September"><span class="nav-number">2.1.</span> <span class="nav-text">September</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-226-翻转二叉树（简单）"><span class="nav-number">2.1.1.</span> <span class="nav-text">16 - 226. 翻转二叉树（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：递归"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">解法一：递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二：广度优先搜索（队列）"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">解法二：广度优先搜索（队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-685-冗余连接-II（困难）"><span class="nav-number">2.1.2.</span> <span class="nav-text">17 - 685. 冗余连接 II（困难）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：并查集"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">解法：并查集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-47-全排列-II（中等）"><span class="nav-number">2.1.3.</span> <span class="nav-text">18 - 47. 全排列 II（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-404-左叶子之和（简单）"><span class="nav-number">2.1.4.</span> <span class="nav-text">19 - 404. 左叶子之和（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#解法一：深度优先搜索（DFS）"><span class="nav-number">2.1.4.0.1.</span> <span class="nav-text">解法一：深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#解法二：广度优先搜索（BFS）-队列"><span class="nav-number">2.1.4.0.2.</span> <span class="nav-text">解法二：广度优先搜索（BFS）+ 队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-78-子集（中等）"><span class="nav-number">2.1.5.</span> <span class="nav-text">20 - 78. 子集（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：迭代法遍历数组"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">解法：迭代法遍历数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-538-把二叉搜索树转换为累加树（简单）"><span class="nav-number">2.1.6.</span> <span class="nav-text">21 - 538. 把二叉搜索树转换为累加树（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索-反序中序遍历"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">解法：深度优先搜索 + 反序中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-968-监控二叉树（困难）"><span class="nav-number">2.1.7.</span> <span class="nav-text">22 - 968. 监控二叉树（困难）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）-动态规划（DP）"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS） + 动态规划（DP）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态转移方程"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">状态转移方程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度："><span class="nav-number">2.1.7.3.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度："><span class="nav-number">2.1.7.4.</span> <span class="nav-text">空间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C语言版"><span class="nav-number">2.1.7.5.</span> <span class="nav-text">C语言版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python语言版："><span class="nav-number">2.1.7.6.</span> <span class="nav-text">Python语言版：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-617-合并二叉树（简单）"><span class="nav-number">2.1.8.</span> <span class="nav-text">23 - 617. 合并二叉树（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）"><span class="nav-number">2.1.8.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-1"><span class="nav-number">2.1.8.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-1"><span class="nav-number">2.1.8.3.</span> <span class="nav-text">空间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C语言版："><span class="nav-number">2.1.8.4.</span> <span class="nav-text">C语言版：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python语言版：-1"><span class="nav-number">2.1.8.5.</span> <span class="nav-text">Python语言版：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-501-二叉搜索树中的众数（简单）"><span class="nav-number">2.1.9.</span> <span class="nav-text">24 - 501. 二叉搜索树中的众数（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：递归-深度优先搜索（DFS）-1"><span class="nav-number">2.1.9.1.</span> <span class="nav-text">解法：递归 + 深度优先搜索（DFS）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-106-从中序与后序遍历序列构造二叉树（中等）"><span class="nav-number">2.1.10.</span> <span class="nav-text">25 - 106. 从中序与后序遍历序列构造二叉树（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：递归"><span class="nav-number">2.1.10.1.</span> <span class="nav-text">解法：递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-113-路径总和-II（中等）"><span class="nav-number">2.1.11.</span> <span class="nav-text">26 - 113. 路径总和 II（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索（DFS）-递归中序遍历"><span class="nav-number">2.1.11.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）+ 递归中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-235-二叉搜索树的最近公共祖先（简单）"><span class="nav-number">2.1.12.</span> <span class="nav-text">27 - 235. 二叉搜索树的最近公共祖先（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索（DFS）"><span class="nav-number">2.1.12.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-117-填充每个节点的下一个右侧节点指针-II（中等）"><span class="nav-number">2.1.13.</span> <span class="nav-text">28 - 117. 填充每个节点的下一个右侧节点指针 II（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：层次遍历"><span class="nav-number">2.1.13.1.</span> <span class="nav-text">解法一：层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-2"><span class="nav-number">2.1.13.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-2"><span class="nav-number">2.1.13.3.</span> <span class="nav-text">空间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C语言版：-1"><span class="nav-number">2.1.13.4.</span> <span class="nav-text">C语言版：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python语言版：-2"><span class="nav-number">2.1.13.5.</span> <span class="nav-text">Python语言版：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-145-二叉树的后序遍历（中等）"><span class="nav-number">2.1.14.</span> <span class="nav-text">29 - 145. 二叉树的后序遍历（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：深度优先搜索（DFS）-递归后续遍历"><span class="nav-number">2.1.14.1.</span> <span class="nav-text">解法一：深度优先搜索（DFS） + 递归后续遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-3"><span class="nav-number">2.1.14.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-3"><span class="nav-number">2.1.14.3.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-701-二叉搜索树中的插入操作（中等）"><span class="nav-number">2.1.15.</span> <span class="nav-text">30 - 701. 二叉搜索树中的插入操作（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索（DFS）-1"><span class="nav-number">2.1.15.1.</span> <span class="nav-text">解法：深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-4"><span class="nav-number">2.1.15.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-4"><span class="nav-number">2.1.15.3.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#October"><span class="nav-number">2.2.</span> <span class="nav-text">October</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-LCP-19-秋叶收藏集（中等）"><span class="nav-number">2.2.1.</span> <span class="nav-text">1 - LCP 19. 秋叶收藏集（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-771-宝石与石头（简单）"><span class="nav-number">2.2.2.</span> <span class="nav-text">2 - 771. 宝石与石头（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-两数之和（简单）"><span class="nav-number">2.2.3.</span> <span class="nav-text">3 - 1. 两数之和（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-两数相加（中等）"><span class="nav-number">2.2.4.</span> <span class="nav-text">4 - 2. 两数相加（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：模拟法"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">解法：模拟法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-5"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-5"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-18-四数之和（中等）"><span class="nav-number">2.2.5.</span> <span class="nav-text">5 - 18. 四数之和（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-834-树中距离之和（困难）"><span class="nav-number">2.2.6.</span> <span class="nav-text">6 - 834. 树中距离之和（困难）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-75-颜色分类（中等）"><span class="nav-number">2.2.7.</span> <span class="nav-text">7 - 75. 颜色分类（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-6"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-6"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-344-反转字符串（简单）"><span class="nav-number">2.2.8.</span> <span class="nav-text">8 - 344. 反转字符串（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-141-环形链表（简单）"><span class="nav-number">2.2.9.</span> <span class="nav-text">9 - 141. 环形链表（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：快慢指针"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">解法一：快慢指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二：利用题目数据范围漏洞"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">解法二：利用题目数据范围漏洞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-142-环形链表-II（中等）"><span class="nav-number">2.2.10.</span> <span class="nav-text">10 - 142. 环形链表 II（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：哈希表"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">解法一：哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解法二：快慢指针"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">解法二：快慢指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-416-分割等和子集（中等）"><span class="nav-number">2.2.11.</span> <span class="nav-text">11 - 416. 分割等和子集（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-530-二叉搜索树的最小绝对差（简单）"><span class="nav-number">2.2.12.</span> <span class="nav-text">12 - 530. 二叉搜索树的最小绝对差（简单）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法：深度优先搜索-中序遍历"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">解法：深度优先搜索 + 中序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-24-两两交换链表中的节点（中等）"><span class="nav-number">2.2.13.</span> <span class="nav-text">13 - 24.两两交换链表中的节点（中等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1002-查找常用字符（简单）"><span class="nav-number">2.2.14.</span> <span class="nav-text">14 - 1002. 查找常用字符（简单）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-116-填充每个节点的下一个右侧节点指针（中等）"><span class="nav-number">2.2.15.</span> <span class="nav-text">15 - 116. 填充每个节点的下一个右侧节点指针（中等）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解法一：层次遍历-1"><span class="nav-number">2.2.15.1.</span> <span class="nav-text">解法一：层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度：-7"><span class="nav-number">2.2.15.2.</span> <span class="nav-text">时间复杂度：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度：-7"><span class="nav-number">2.2.15.3.</span> <span class="nav-text">空间复杂度：</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">arttnba3</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">90.1k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'b012ce640e67f72b3101',
      clientSecret: '432cfbb09cfbb0b19100c1ab65cb5efbf906c138',
      repo: 'BlogComment',
      owner: 'arttnba3',
      admin: ['arttnba3'],
      id: location.pathname,
      distractionFreeMode: 'false'
    })
    gitalk.render('gitalk-container')
  </script>

  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
